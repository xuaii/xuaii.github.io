[{"categories":null,"content":"既然我的世界是图灵完备的，那么一定可以将c/c++等静态语言编译成红石电路，只用提供一些基础的模块就能（输入输出，各种库）编译出确定的红石电路。 要通过代码控制我的世界，就要有 Minecraft 的API接口 Mine Player API 用于创建游戏机器人，通过对机器人的操作可以按照编译出的指令执行创建/设置方块，并且可以在游戏中录制建造过程，API功能如下： Entity knowledge and tracking. Block knowledge. You can query the world around you. Milliseconds to find any block. Physics and movement - handle all bounding boxes Attacking entities and using vehicles. Inventory management. Crafting, chests, dispensers, enchantment tables. Digging and building. Miscellaneous stuff such as knowing your health and whether it is raining. Activating blocks and using items. Chat. 使用 ANTLR4 将目标语言翻译成 AST 解析 AST 并生成 机器人行动指令 (RAC) 根据行动指令在我的世界中创建机器 要实现上述功能需要以下模块： 机器人控制器 该模块使用 Mine Player API 控制机器人操作方块 当接收到某个指令，需要指挥机器人行动 维护一个 世界对象，需要计算 创建/销毁 的位置 AST 解析器 遍历 AST 生成指令（这里的指令是位置无关的，例如创建一个变量，但是不需要知道在什么位置创建，需要 机器人控制器来计算合理的位置） 设计一个合适的 中间语言(RAC) 来表示机器人行为（位置无关） ","date":"2023-01-03","objectID":"/wa-keng-jiang-gao-ji-cheng-xu-yu-yan-bian-yi-cheng-hong-shi-dian-lu/:0:0","tags":null,"title":"[挖坑] 将高级语言编译为红石电路","uri":"/wa-keng-jiang-gao-ji-cheng-xu-yu-yan-bian-yi-cheng-hong-shi-dian-lu/"},{"categories":null,"content":"转自知乎 Oculus应该卖给谁？好大的一个问题啊。 卖给谁都可以，但就是不该卖给Facebook！ 卖给Apple多合适，那里有全世界最好的消费电子产品。卖给Google也不错，安卓系统逐渐统治世界，Google眼镜刚被《时代》杂志评为那一年最令人期待的硬件产品。 还可以选微软，VR（Virtual Reality，虚拟现实）最直观的使用场景就是游戏，这和微软Xbox游戏机一脉相承。就连亚马逊，好歹也做出了Kindle，在人类出版界放了一场大火。 再看看Facebook呢？一点做硬件的经验都没有。扎克伯格(Mark Zuckerberg)曾经放出狠话要做手机，折腾了半天，只是竹篮打水一场空。 不仅如此，Oculus还非常不facebook。CTO压根没有Facebook账户，CEO的办公室里赫然挂着一副对Facebook不敬的工艺品，员工把嘲笑Facebook当作工作的日常，FB是一个典型的反面教材：僵化的公司、糟糕的设计、隐私的小偷。 当扎克伯格千里迢迢来拜访Oculus全体员工，一位叫Dycus的员工，当着全公司的面问小扎：很多人（当然，不包括我哈），都觉得Facebook是邪恶的（Facebook is evil），你觉得，这会怎么影响Oculus的形象？ 图：戴着Oculus的扎克伯格 但是扎克伯格却像被施了法术，对Oculus着了魔。 扎克伯格带着Facebook一众高管轮流戴了一会Oculus的VR头盔。 当时还只是样品，距离成品上市，还有很远的距离。即使到了今天，VR头盔都没有克服最大的bug——晕眩。更别说7年前了。小扎卸下头盔的刹那，估计和学生时代在哈佛大学通宵宿醉后一样的难受，但是，小扎连同CTO和负责产品的VP，对这个新奇的玩意赞不绝口，反复说着：holy crap（专业翻译：我X, NB啊）。 5天后，这位全球最大社交网络的管理者亲自去了这家创业公司的办公室。 这一天，这位全世界最富有的80后背了一个麦当劳的购物袋。这真是神来之笔。本来对Facebook没有一点好感的年轻极客们，瞬间议论纷纷：真是没想到，互联网超级大佬，原来是和我一样的人。 在狠狠拉了一波好感值后，扎克伯格为这家创办仅仅2年的公司开出了无法拒绝的价码——30亿美元。以及反复的劝诱和许诺：Oculus会成为Facebook唯一的平台，我要让Oculus成为VR的领导者！ 怎么拉近资本和创业者的距离，小扎可能是全世界最懂这件事的人。当年Facebook刚刚成立，小扎要去红杉资本的办公室谈融资。在肖恩·帕克（Sean Parker）的教唆下，他穿着睡衣走进了高大上的办公室。 西装革履的中年油腻男被挑逗得欲火焚身，这才是TMD真极客！投他，必须投他！ 那只麦当劳的手提袋，很难说不是一场精心设计的轮回。这位哈佛辍学生，有一个木讷的外表，以至于常常让我们忽略了他极其精明和复杂的内心世界。 但是。 搞VR？！你还是想想清楚吧，这个专门绞杀科技巨头的战场，早已白骨累累。 01 从弗兰克鲍姆的《万能钥匙》到赫胥黎的《美丽新世界》，从伍迪艾伦的《沉睡者》（1973年），到斯皮尔伯格的《头号玩家》（2018年），VR（虚拟现实）是所有科幻小说、科幻电影的必备元素。 带上一套装备，通过视觉、嗅觉、触觉，让人走进一个完全虚拟的世界。还有比这更cool的科技产品吗？ 斯皮尔伯格的电影《头号玩家》主题就是一个VR游戏 写出《数字化生存》的MIT（麻省理工）教授尼葛洛庞帝说，他从1969年就开始关注VR。 没错，在连彩色电视机都没有普及的60年代，真极客们就已经在尝试做VR头盔。90年代，任天堂、世嘉，以及乔布斯实习过的雅达利，先后对着VR设备，大搞特搞。 世嘉（SEGA）搞得最轰动。产品宣传了三年，发布会开了又开，《大众科技》的杂志封面也如愿登过了。结果，临门一脚，突然宣布不发布了，放了全世界一个大鸽子。世嘉的理由是：VR游戏太过真实，玩家在游戏过程中不由自主地移动，容易受伤。 拉倒吧。 受伤是真的，但不是因为移动，而是因为晕眩导致的恶心头疼。VR营造了一个深度沉浸的世界，如果技术跟不上，虚拟画面和现实动作有延时，会造成严重的晕眩，类似现实中的晕车。 从此，晕眩感成为横亘在VR产业面前的一道天堑，或者说一道魔咒。人类科技界对VR的第一次攻关，以被团灭的方式告终。 紧接着，互联网来了。亚马逊、Google先后问世，那些利用互联网连接存量资源，那些消费主义的迎合者，成了硅谷的新宠。 时代换了一批新的宾客，但是极客的火苗没有完全熄灭。把科幻小说里最cool的装备变成现实，也是科技新贵的梦。 Google先做AR(Augmented reality，增强现实)，谷歌眼镜（Google Glass）才出了几张宣传照，全世界科技迷就自嗨到了高潮，不仅有英国王子这样的社会名流野生代言，而且频频被各类媒体评价为人类最具创新、最值得期待的产品。Google又感动又兴奋，再接再厉做了一个VR的平台Daydream，满腔热血期待复制一个安卓的神话。 三星，作为当时全球出货量第一的手机品牌，也狠狠表示了一把，弄出个Gear VR。但是，Google眼镜、Daydream，GearVR，全部火不过两年，最终销声匿迹。 目前为止，人类最重要的硬件还是智能手机。Google和三星是这个行业绝对的领导者，在产业链里是一呼百应。那么强的能力，那么厚的背景，在VR行业也不过是碰一鼻子灰，羞羞地找个台阶下。 这就是Facebook收购Oculus的背景。在硅谷，Facebook的标签是侵犯隐私、抄袭模仿、功利主义，这样的扎克伯格可能做出人类最新奇的硬件吗？ 02 2016年，小扎正在为Facebook进入中国努力。顶着大雾霾，毅然决然地在天安门前跑步，是个又红又专的好少年。 那次扎克伯格来北京，目的是参加由国务院发展研究中心主办的中国发展高层论坛。 93岁的基辛格老爷子做了《避免修昔底德陷阱》的演讲，接下来就是扎克伯格和马云的谈话。扎克伯克表示，前两年我收购了Oculus，今年会推出一款VR头盔，今年消费级VR就会爆发，五到十年之后，VR手机会成为市场主流。 马云说，行啊，我会帮你。 其实，不只是姓赵。姓马，也是有鄙视链的。 就拿马克·扎克伯格、马云、马斯克来说。 小扎像个中国人，场面上说话一定圆滑，不轻易得罪人。和马云聊天客客气气的，上来先介绍自己正在学习中文，但是还很糟，所以辛苦马云今天用英语交流，谢谢大家的理解。 你再看看马斯克？那副得瑟劲。同样是来中国参加对话，马斯克一点不给马老师面子，把马氏鸡汤里的逻辑矛盾、事实错误全指了出来。喜欢阿里的人千万别放心上，其实玩硬核科技的马斯克最看不起的人，是马克·扎克伯格。马斯克不带修饰地说过：Facebook垃圾（Facebook sucks），窃取隐私、只会垄断，扎克伯格小朋友对于AI一无所知……然后，以身作则地把自己的Facebook账户注销了。 小扎心里是真苦啊。Facebook是全世界市值前五的互联网公司，说起来有头有脸，但是收入的95%都是广告。扎克伯格气不过的时候也想回怼两句，但是射火箭、卖电动的马斯克恐怕要怼一句更厉害的回来，“你个卖广告的，装什么B”，那年轻的小扎又要气得几天睡不着觉了。 马家人的鄙视链说到底就是一句话：互联网企业压根不是科技公司。 清醒点，好不好，你不过是做了一个网页，因为上线得足够早，早早占了个好坑，很多人用。形成了平台，形成了垄断，独占了数据，仅此而已。巴西男足踢中国男足，即使教练席栓一条狗，也能赢。是的，仅此而已。这怎么能配叫高科技？ 在马斯克眼中，扎克伯格就是这种不配的典型。 这就是扎克伯格坚持做VR的第二个背景。 何止是Google、三星，中国也多的是利用VR吹牛逼的大公司。就在扎克伯格和马云亲切交谈的那一年，阿里推出VR购物 “Buy＋”，目标是利用VR让网购变成逛商场的模样。另一个大手笔是领投了美国很火的AR创业公司Magic Leap，7.94亿美元的融资。 同一年，马化腾也给VR站过台，“VR是一场大洗牌，即将开始。就像移动互联网转型一样，上不了船的人将逐渐落伍”。当年由微信引发的“船票论”再次甚嚣尘上。据说腾讯启动了多款VR游戏的制作。还扬言也像Facebook一样做VR硬件，连原型机都搞出来了。然后，就没有然后了。 VR这件事，科技感爆棚，但是每次一燃，就会被泼下一盆又一盆的冷水。归根结底，有这样几个过不去的坎——晕动症、功能单一、缺乏优质内容、设备臃肿、价格昂贵…… 没过多久，Google、三星、阿里、腾讯都撤了，它们都不过是匆匆的过客，都没有成为推动行业前进的力量。 意外的是扎克伯格却固执地坚持了一下。 为什么？ 往低了说，是守护Facebook的社交边界。扎克伯格这个人，永远在警惕Facebook可能的颠覆者。Facebook的入职手册中，写着这样一句话：如果我们不去创造出能杀死Facebook的产品，有人会去做。 马化腾也表示过，VR/AR很可能是下一代社交，颠覆微信的那一种。 的确，微信毕竟只是一个平面的聊天框。用脚趾头就能想明白，如果VR创建一个虚拟space，渣男撩妹的空间会大很多很多。 Facebook开发的VR社交平台Horizon 往高了说，扎克伯格就是憋了一口气，去TMD马家人鄙视链。我要亲自证明Facebook的科技感——我来做一个新硬件，我来扩展人类的边界，我来打碎虚拟世界和现实世界的这面墙。 你们给我看清楚了。 03 扎克伯格有个枯燥且乏味的爱好——寻访有社交竞争力的创业公司，和创始人一见如故，再开一个你无法say no的条件，接着带你飞一段，然后闹掰，最终交恶。 扎克伯格先后收购Instagr","date":"2023-01-03","objectID":"/zhuan-zai-vr-che-diao-liao-zhong-guo-ke-ji-quan-de-zhe-xiu-bu/:0:0","tags":null,"title":"[转载] VR 扯掉了中国科技圈的遮羞布","uri":"/zhuan-zai-vr-che-diao-liao-zhong-guo-ke-ji-quan-de-zhe-xiu-bu/"},{"categories":null,"content":"原文 当今互联网到处存在着一些中间件(Middle Boxes),如NAT和防火墙,导致两个(不在同一内网)中的客户端无法直接通信. 这些问题即便是到了IPV6时代也会存在,因为即使不需要NAT,但还有其他中间件如防火墙阻挡了链接的建立. 目前部署的中间件多都是在C/S架构上设计的,其中相对隐匿的客户机主动向周知的服务端(拥有静态IP地址和DNS名称)发起链接请求. 大多数中间件实现了一种非对称的通讯模型,即内网中的主机可以初始化对外的链接,而外网的主机却不能初始化对内网的链接, 除非经过中间件管理员特殊配置. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:0:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"前言 在中间件为常见的NAPT的情况下（也是本文主要讨论的）,内网中的客户端没有单独的公网IP地址, 而是通过NAPT转换,和其他同一内网用户共享一个公网IP. 这种内网主机隐藏在中间件后的不可访问性对于一些客户端软件如浏览器来说 并不是一个问题,因为其只需要初始化对外的链接,从某方面来看反而还对隐私保护有好处. 然而在P2P应用中, 内网主机（客户端）需要对另外的终端（Peer）直接建立链接,但是发起者和响应者可能在不同的中间件后面, 两者都没有公网IP地址. 而外部对NAT公网IP和端口主动的链接或数据都会因内网未请求被丢弃掉. 本文讨论的就是如何跨越NAT实现内网主机直接通讯的问题. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:1:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"一些术语 ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"防火墙(Firewall) 防火墙主要限制内网和公网的通讯,通常丢弃未经许可的数据包. 防火墙会检测(但是不修改)试图进入内网数据包的IP地址和TCP/UDP端口信息. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:1","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"网络地址转换器(NAT) NAT不止检查进入数据包的头部,而且对其进行修改,从而实现同一内网中不同主机共用更少的公网IP（通常是一个）. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:2","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"基本NAT(Basic NAT) 基本NAT会将内网主机的IP地址映射为一个公网IP,不改变其TCP/UDP端口号. 基本NAT通常只有在当NAT有公网IP池的时候才有用. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:3","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"网络地址-端口转换器(NAPT) 到目前为止最常见的即为NAPT,其检测并修改出入数据包的IP地址和端口号,从而允许多个内网主机同时共享一个公网IP地址. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:4","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"锥形NAT(Cone NAT) 在建立了一对（公网IP,公网端口）和（内网IP,内网端口）二元组的绑定之后,只要还有一个会话还是激活的,Cone NAT会重用这组绑定用于接下来该应用程序的所有会话（同一内网IP和端口）. 例如,假设客户端A建立了两个连续的对外会话,从相同的内部端点（10.0.0.1:1234）到两个不同的外部服务端S1和S2. Cone NAT只为两个会话映射了一个公网端点（155.99.25.11:62000）, 确保客户端端口的“身份”在地址转换的时候保持不变. 由于基本NAT和防火墙都不改变数据包的端口号,因此这些类型的中间件也可以看作是退化的Cone NAT. Server S1 Server S2 18.181.0.31:1235 138.76.29.7:1235 | | | | +----------------------+----------------------+ | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 155.99.25.11:62000 v | v 155.99.25.11:62000 v | Cone NAT 155.99.25.11 | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 10.0.0.1:1234 v | v 10.0.0.1:1234 v | Client A 10.0.0.1:1234 其中Cone NAT根据NAT如何接收已经建立的（公网IP,公网端口）对的输入数据还可以细分为以下三类： 1. 全锥形NAT(Full Cone NAT) 在一个新会话建立了公网/内网端口绑定之后,全锥形NAT接下来会接受对应公网端口的所有数据,无论是来自哪个（公网）终端. 全锥NAT有时候也被称为“混杂”NAT（promiscuous NAT）. 2. 受限锥形NAT(Restricted Cone NAT) 受限锥形NAT只会转发符合某个条件的输入数据包. 条件为：外部（源）IP地址匹配内网主机之前发送一个或多个数据包的结点的IP地址. AT通过限制输入数据包为一组“已知的”外部IP地址,有效地精简了防火墙的规则. 3. 端口受限锥形NAT(Port-Restricted Cone NAT) 端口受限锥形NAT也类似,只当外部数据包的IP地址和端口号都匹配内网主机发送过的地址和端口号时才进行转发. 端口受限锥形NAT为内部结点提供了和对称NAT相同等级的保护,以隔离未关联的数据. 4. 对称NAT(Symmetric NAT) 对称NAT正好相反,不在所有公网-内网对的会话中维持一个固定的端口绑定. 其为每个新的会话开辟一个新的端口. 如下图所示： Server S1 Server S2 18.181.0.31:1235 138.76.29.7:1235 | | | | +----------------------+----------------------+ | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 155.99.25.11:62000 v | v 155.99.25.11:62001 v | Symmetric NAT 155.99.25.11 | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 10.0.0.1:1234 v | v 10.0.0.1:1234 v | Client A 10.0.0.1:1234 ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:2:5","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"P2P通信技术 根据客户端的不同,客户端之间进行P2P传输的方法也略有不同,这里介绍了现有的穿越中间件进行P2P通信的几种技术. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:3:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"中继（Relaying） 这是最可靠但也是最低效的一种P2P通信实现. 其原理是通过一个有公网IP的服务器中间人对两个内网客户端的通信数据进行中继和转发. 如下图所示： Server S | | +----------------------+----------------------+ | | NAT A NAT B | | | | Client A Client B 客户端A和客户端B不直接通信,而是先都与服务端S建立链接,然后再通过S和对方建立的通路来中继传递的数据. 这钟方法的缺陷很明显, 当链接的客户端变多之后,会显著增加服务器的负担,完全没体现出P2P的优势. 但这种方法的好处是能保证成功,因此在实践中也常作为一种备选方案. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:3:1","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"逆向链接（Connection reversal） 第二种方法在当两个端点中有一个不存在中间件的时候有效. 例如,客户端A在NAT之后而客户端B拥有全局IP地址,如下图： Server S 18.181.0.31:1235 | | +----------------------+----------------------+ | | NAT A | 155.99.25.11:62000 | | | | | Client A Client B 10.0.0.1:1234 138.76.29.7:1234　客户端A内网地址为10.0.0.1,且应用程序正在使用TCP端口1234. A和服务器S建立了一个链接,服务器的IP地址为18.181.0.31,监听1235端口. NAT A给客户端A分配了TCP端口62000,地址为NAT的公网IP地址155.99.25.11, 作为客户端A对外当前会话的临时IP和端口. 因此S认为客户端A就是155.99.25.11:62000. 而B由于有公网地址,所以对S来说B就是138.76.29.7:1234. 当客户端B想要发起一个对客户端A的P2P链接时,要么链接A的外网地址155.99.25.11:62000,要么链接A的内网地址10.0.0.1:1234,然而两种方式链接都会失败. 链接10.0.0.1:1234失败自不用说,为什么链接155.99.25.11:62000也会失败呢？来自B的TCP SYN握手请求到达NAT A的时候会被拒绝,因为对NAT A来说只有外出的链接才是允许的. 在直接链接A失败之后,B可以通过S向A中继一个链接请求,从而从A方向“逆向“地建立起A-B之间的点对点链接. 很多当前的P2P系统都实现了这种技术,但其局限性也是很明显的,只有当其中一方有公网IP时链接才能建立. 越来越多的情况下, 通信的双方都在NAT之后,因此就要用到我们下面介绍的第三种技术了. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:3:2","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"UDP打洞（UDP hole punching） 第三种P2P通信技术,被广泛采用的,名为“P2P打洞“. P2P打洞技术依赖于通常防火墙和Cone NAT允许正当的P2P应用程序在中间件中打洞且与对方建立直接链接的特性. 下面主要考虑两种常见的场景,以及应用程序如何设计去完美地处理这些情况. 第一种场景代表了大多数情况,即两个需要直接链接的客户端处在两个不同的NAT之后； 第二种场景是两个客户端在同一个NAT之后,但客户端自己可能并不知道(比如同一ISP下面的不同子网). 端点在不同的NAT之后 假设客户端A和客户端B的地址都是内网地址,且在不同的NAT后面. A、B上运行的P2P应用程序和服务器S都使用了UDP端口1234,A和B分别初始化了 与Server的UDP通信,地址映射如图所示: Server S 18.181.0.31:1234 | | +----------------------+----------------------+ | | NAT A NAT B 155.99.25.11:62000 138.76.29.7:31000 | | | | Client A Client B 10.0.0.1:1234 10.1.1.3:1234 现在假设客户端A打算与客户端B直接建立一个UDP通信会话. 如果A直接给B的公网地址138.76.29.7:31000发送UDP数据,NAT B将很可能会无视进入的 数据（除非是Full Cone NAT）,因为源地址和端口与S不匹配,而最初只与S建立过会话. B往A直接发信息也类似. 假设A开始给B的公网地址发送UDP数据的同时,给服务器S发送一个中继请求,要求B开始给A的公网地址发送UDP信息. A往B的输出信息会导致NAT A打开 一个A的内网地址与与B的外网地址之间的新通讯会话,B往A亦然. 一旦新的UDP会话在两个方向都打开之后,客户端A和客户端B就能直接通讯, 而无须再通过引导服务器S了. UDP打洞技术有许多有用的性质. 一旦一个的P2P链接建立,链接的双方都能反过来作为“引导服务器”来帮助其他中间件后的客户端进行打洞, 极大减少了服务器的负载. 应用程序不需要知道中间件具体是什么（如果有的话）,因为以上的过程在没有中间件或者有多个中间件的情况下 也一样能建立通信链路. 端点在相同的NAT之后 现在考虑这样一种情景,两个客户端A和B正好在同一个NAT之后（而且可能他们自己并不知道）,因此在同一个内网网段之内. 客户端A和服务器S建立了一个UDP会话,NAT为此分配了公网端口62000,B同样和S建立会话,分配到了端口62001,如下图： Server S 18.181.0.31:1234 | | NAT A-S 155.99.25.11:62000 B-S 155.99.25.11:62001 | +----------------------+----------------------+ | | Client A Client B 10.0.0.1:1234 10.1.1.3:1234 假设A和B使用了上节介绍的UDP打洞技术来建立P2P通路,那么会发生什么呢？首先A和B会得到由S观测到的对方的公网IP和端口号,然后给对方的地址发送信息. 两个客户端只有在NAT允许内网主机对内网其他主机发起UDP会话的时候才能正常通信,我们把这种情况称之为\"回环传输“(loopback transmission),因为从内部 到达NAT的数据会被“回送”到内网中而不是转发到外网. 例如,当A发送一个UDP数据包给B的公网地址时,数据包最初有源IP地址和端口地址10.0.0.1:1234和 目的地址155.99.25.11:62001,NAT收到包后,将其转换为源155.99.25.11:62000（A的公网地址）和目的10.1.1.3:1234,然后再转发给B. 即便NAT支持 回环传输,这种转换和转发在此情况下也是没必要的,且有可能会增加A与B的对话延时和加重NAT的负担. 对于这个情况,优化方案是很直观的. 当A和B最初通过S交换地址信息时,他们应该包含自身的IP地址和端口号（从自己看）,同时也包含从服务器看的自己的 地址和端口号. 然后客户端同时开始从对方已知的两个的地址中同时开始互相发送数据,并使用第一个成功通信的地址作为对方地址. 如果两个客户端在同一个 NAT后,发送到对方内网地址的数据最有可能先到达,从而可以建立一条不经过NAT的通信链路；如果两个客户端在不同的NAT之后,发送给对方内网地址的数据包 根本就到达不了对方,但仍然可以通过公网地址来建立通路. 值得一提的是,虽然这些数据包通过某种方式验证,但是在不同NAT的情况下完全有可能会导致A往B 发送的信息发送到其他A内网网段中无关的结点上去的. 端点在多级NAT之后 在一些拓朴结构中,可能会存在多级NAT设备,在这种情况下,如果没有关于拓朴的具体信息, 两个Peer要建立“最优”的P2P链接是不可能的,下面来说为什么. 以下图为例： Server S 18.181.0.31:1234 | | NAT X A-S 155.99.25.11:62000 B-S 155.99.25.11:62001 | | +----------------------+----------------------+ | | NAT A NAT B 192.168.1.1:30000 192.168.1.2:31000 | | | | Client A Client B 10.0.0.1:1234 10.1.1.3:1234 假设NAT X是一个网络提供商ISP部署的工业级NAT,其下子网共用一个公网地址155.99.25.11,NAT A和NAT B分别是其下不同用户的网关部署的NAT. 只有服务器S 和NAT X有全局的路由地址. Client A在NAT A的子网中,同时Client B在NAT B的子网中,每经过一级NAT都要进行一次网络地址转换. 现在假设A和B打算建立直接P2P链接,用一般的方法（通过Server S来打洞）自然是没问题的,那能不能优化呢？一种想当然的优化办法是A直接把信息发送给NAT B的 内网地址192.168.1.2:31000,且B通过NAT B把信息发送给A的路由地址192.168.1.1:30000,不幸的是,A和B都没有办法得知这两个目的地址,因为S只看见了客户端 ‵全局‵地址155.99.25.11. 退一步说,即便A和B通过某种方法得知了那些地址,我们也无法保证他们是可用的. 因为ISP分配的子网地址可能和NAT A B分配的子网地址 域相冲突. 因此客户端没有其他选择,只能使用S来进行打洞并进行回环传输. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:3:3","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"固定端口绑定 UDP打洞技术有一个主要的条件：只有当两个NAT都是Cone NAT（或者非NAT的防火墙）时才能工作. 因为其维持了一个给定的（内网IP,内网UDP）二元组 和（公网IP, 公网UDP）二元组固定的端口绑定,只要该UDP端口还在使用中,就不会变化. 如果像对称NAT一样,给每个新会话分配一个新的公网端口,就 会导致UDP应用程序无法使用跟外部端点已经打通了的通信链路. 由于Cone NAT是当今最广泛使用的,尽管有一小部分的对称NAT是不支持打洞的,UDP打洞 技术也还是被广泛采纳应用. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:3:4","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"具体实现 一般的网络编程,都是客户端比服务端要难,因为要处理与服务器的通信同时还要处理来自用户的事件；对于P2P客户端来说更是如此,因为P2P客户端不止作 为客户端,同时也作为对等连接的服务器端. 这里的大体思路是,输入命令传输给服务器之后,接收来自服务器的反馈,并执行相应代码. 例如A想要与B建立 通信链路,先给服务器发送punch命令以及给B发送数据,服务器接到命令后给B发送punch_requst信息以及A的端点信息,B收到之后向A发送数据打通通路,然 后A与B就可以进行P2P通信了. 经测试,打通通路后即便把服务器关闭,A与B也能正常通信. 一个UDP打洞的例子见P2P-Over-MiddleBoxes-Demo ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:4:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"TCP打洞(TCP Hole Punching) 关于TCP打洞,有一点需要提的是,因为TCP是基于连接的,所以任何未经连接而发送的数据都会被丢弃,这导致在recv的时候是无法直接从peer端读取数据. 其实这对UDP也一样,如果对UDP的socket进行了connect,其也会忽略连接之外的数据,详见connect(2). 所以,如果我们要进行TCP打洞,通常需要重用本地的endpoint来发起新的TCP连接,这样才能将已经打开的NAT利用起来. 具体来说,则是要设置socket的 SO_REUSEADDR或SO_REUSEPORT属性,根据系统不同,其实现也不尽一致. 一般来说,TCP打洞的步骤如下： A 发送 SYN 到 B(出口地址,下同）,从而创建NAT A的一组映射 B 发送 SYN 到 A, 创建NAT B的一组映射 根据时序不同,两个SYN中有一个会被对方的NAT丢弃,另一个成功通过NAT 通过NAT的SYN报文被其中一方收到,即返回SYNACK, 完成握手 至此,TCP的打洞成功,获得一个不依赖于服务器的链接 由于TCP连接是由操作系统控制的, 而不是由应用控制的, 而且TCP包的序列号是随机生成, 所以TCP打洞的成功率就相对较低. 因此如果NAT对接收到的包进行TCP序列号检测时若没有现有的连接可以对应, 该TCP包很可能会被NAT丢弃掉. ","date":"2023-01-03","objectID":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/:5:0","tags":null,"title":"[转载] p2p 内网穿透技术","uri":"/zhuan-zai-p2p-nei-wang-chuan-tou-ji-zhu/"},{"categories":null,"content":"脚本语言是快速编写富有弹性的代码的重要方法之一，在 Unix 系统自动化管理中已经应用了多种脚本语言。现在，在许多应用开发中，也提供了脚本层，这大大方便用户实现通用任务自动处理或者编写应用扩展，许多成功的应用，诸如 GIMP、Emacs、MS Office、PhotoShop、AutoCAD 等都应用了脚本技术。在某种意义上，一切皆可脚本化。 在另一篇文章中，我们已经介绍了如何在 C 应用中嵌入 Python 语言，通过这项技术，可以让应用的高级用户来修改或定制化他们的程序，你可以充分利用 Python 的语言能力而不用自己去实现嵌入语言。Python 是一个不错的的选择，因为它提供了干净直观的 C 语言 API。关于如何在 C 应用中嵌入 Python 解释器，你可以参考：让Python成为嵌入式语言一文。 现在我们来更深入地探讨一些问题。 鉴于许多复杂的应用都会利用多线程技术，本文将着重介绍如何创建线程安全的界面来调用Python解释器。 这里的所有例子都是用 Python 2.7.2，所有的 Python 函数都以extern “C”定义，因此对于 C 和 C++，其使用是别无二致的。 ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:0:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"Python C 和线程 在C程序中创建执行线程是很简单的。在 Linux 中，通常的做法是使用 POSIX 线程（pthread) API 并调用 pthread_create 函数。关于如何使用 pthreads，你可以参考 Felix Garcia 和Javier Fernandez 著的 “POSIX Thread Libraries”一文。为了支持多线程， Python 使用了互斥使访问内部数据结构串行化。这种互斥即 “全局解释器锁 – global interpreter lock”，当某个线程想使用 Python 的C API的时候，它必须获得 全局解释器锁，这避免了会导致解析器状态崩溃的竞争条件（race condition)。 互斥的锁定和释放是通过 PyEval_AcquireLock 和 Eval_ReleaseLock 来描述的。调用了 PyEval_AcquireLock 之后，可以安全地假定你的线程已经持有了锁，其他相关线程不是被阻塞就是在执行与 Python 解析器无关的代码。现在你可以任意调用 Python 函数了。一旦取得了锁，你必须确保调用 PyEval_ReleaseLock 来释放它，否则就会导致线程死锁并冻结其他 Python 线程。 更复杂的情况是，每个运行 Python 的线程维护着自己的状态信息。这些和特定线程相关的数据存储在称为 PyThreadState 的对象中。当在多线程应用中用 C 语言调用 Python API 函数时，你必须维护自己的 PyThreadState 对象以便能安全地执行并发的 Python 代码。 如果你对开发多线程应用相当有经验，你可能会发现全局解释器锁的概念相当不方便。不过，现在它已经不像首次出现时那样糟糕了。当 Python 对脚本进行解释时，它会定期切换出当前 PyThreadState 对象并释放全局解释器锁，从而将控制权释放给其他线程。之前被阻塞的线程可以试图锁定全局解释器锁从而被运行。有些时候，原来的线程会再次获得全局解释器锁再次切回解释器。 这意味着当调用 PyEval_SimpleString 时，即使你持有全局解释器锁，其他线程仍有机会被执行，这样的副作用无可避免。另外，当你调用以 C 语言写就的 Python 模块（包括许多内置模块） 存在着将控制权释放给其他线程的可能性。基于这个原因，当你用两个 C 线程来执行计算密集的 Python 脚本，它们确实能分享 CPU 时间并发运行，但由于全局解释器锁的存在，在多处理器的计算机上，Python 无法通过线程充分计算机的 CPU 处理能力。 ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:1:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"启用线程支持 在多线程的 C 程序使用 Python API 之前，必须调用一些初始化例程。如果编译解释器库时启用了多线程支持（通常情况如此），你就有了一个是否启用线程的运行时选项。除非你计划使用线程，否则不建议启用该选项。未启用该选项，Python 可以避免因互斥锁定其内部数据结构而产生的系统开销。但是如果你打算用 Python 来扩展多线程应用，你就需要在初始化解释器的时候启用线程支持。我个人建议，应该在主线程执行时就初始化 Python，最好是在应用程序启动的时候，就调用下面两行代码： // initialize Python Py_Initialize(); // initialize thread support PyEval_InitThreads(); 这两个函数都返回 void，所以无需检查错误代码。现在，我们可以假定 Python 解释器已准备好执行 Python 代码。Py_Initialize 分配解释器库使用的全局资源。调用PyEval_InitThreads 则启用运行时线程支持。这导致 Python 启用其内部的互斥锁机制，用于解释器内代码关键部分的系列化访问。此函数的另一个作用是锁定全局解释器锁。该函数完成后，需要由用户负责释放该锁。不过，在释放锁之前, 你应该捕获当前 PyThreadState 对象的指针。后续创建新的 Python 线程以及结束使用 Python 时要正确关闭解释器，都需要用到该对象。下面这段代码用来捕获 PyThreadState 对象指针: PyThreadState * mainThreadState = NULL; // save a pointer to the main PyThreadState object mainThreadState = PyThreadState_Get(); // release the lock PyEval_ReleaseLock(); ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:2:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"创建新的执行线程 在 Python 里，每个执行 Python 代码的线程都需要一个 PyThreadState 对象。解释器使用此对象来管理每个线程独立的数据空间。理论上，这意味着一个线程中的动作不会牵涉到另一个线程的状态。例如，你在一个线程中抛出异常，其他 Python 代码片段仍会继续运行，就好象什么事情都没有发生一样。你必须帮助 Python 管理每个线程的数据。为此，你需要为每个执行 Python 代码的 C 线程手工创建一个 PyThreadState 对象.要创建 PyThreadState 对象，你需要用到既有的 PyInterpreterState 对象。PyInterpreterState 对象带有为所有参与的线程所共享的信息。当你初始化 Python 时，它就会创建一个 PyInterpreterState 对象，并将它附加在主线程的 PyThreadState 对象上。你可以使用该解释器对象为你自己的 C 现成创建新的 PyThreadState。请参考下面代码 // get the global lock PyEval_AcquireLock(); // get a reference to the PyInterpreterState PyInterpreterState * mainInterpreterState = mainThreadState-\u003einterp; // create a thread state object for this thread PyThreadState * myThreadState = PyThreadState_New(mainInterpreterState); // free the lock PyEval_ReleaseLock(); ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:3:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"执行 Python 代码 现在我们已创建 PyThreadState 对象，你的 C 线程就可以开始使用 Python API 执行 Python 脚本。从 C 线程执行 Python 代码时，你必须遵守一些简单的规则。首先，您在进行任何会改变当前线程状态的操作前必须持有全局解释器锁。第二，必须在执行任何 Python 代码之前，必须将该线程特定的 PyThreadState 对象加载到解释器。一旦您已经满足这些条件，您可以通过诸如 PyEval_SimpleString 函数来执行任意的 Python 代码，并记得在执行结束时切出 PyThreadState 对象并释放全局解释器锁。请参考下面代码，注意代码中“锁定、 切换、 执行、 切换，解锁”的对称关系： // grab the global interpreter lock PyEval_AcquireLock(); // swap in my thread state PyThreadState_Swap(myThreadState); // execute some python code PyEval_SimpleString(\"import sys\\n\"); PyEval_SimpleString(\"sys.stdout.write(‘Hello from a C thread!\\n‘)\\n\"); // clear the thread state PyThreadState_Swap(NULL); // release our hold on the global interpreter PyEval_ReleaseLock(); ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:4:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"清除线程 一旦你的 C 线程不再需要 Python 解释器，你必须释放相关资源。为此，需要删除该线程的 PyThreadState 对象，相关代码如下： // grab the lock PyEval_AcquireLock(); // swap my thread state out of the interpreter PyThreadState_Swap(NULL); // clear out any cruft from thread state object PyThreadState_Clear(myThreadState); // delete my thread state object PyThreadState_Delete(myThreadState); // release the lock PyEval_ReleaseLock(); 通过使用 Python API ，这个线程很有效率地完成了上述工作。现在你可以安全地调用 pthread_ext 来结束该线程的运行。 ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:5:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"关闭解释器 一旦应用不在需要 Python 解释器，你可以用下面的代码将 Python 关闭掉： // shut down the interpreter PyEval_AcquireLock(); Py_Finalize(); 注意：因为 Python 已经被关系，这里就不需要释放锁。请确保在调用 Py_Finalize 之前用 PyThreadState_Clear 和 PyThreadState_Delete 删除掉所有线程状态对象。 ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:6:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"小结： 作为嵌入式语言，Python 是一个不错的选择。Python 解释器同时支持嵌入和扩展，它允许 C 应用程序代码和嵌入的 Python 脚本之间的双向通信。此外，多线程支持促进了与多线程应用程序的集成，而且不影响性能。 你可以从本文的后面下载有关案例Python embedded HTTP Server (29)，该案例实现了一个内嵌 Python 解释器的多线程 HTTP 服务器。此外我推荐您去 http://www.python.org/docs/api/ 阅读有关的 Python C API 文档。另外 Python 解释器本身的代码也是一个很有价值的参考。 ","date":"2023-01-03","objectID":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/:7:0","tags":null,"title":"[转载] c 多线程调用 python","uri":"/zhuan-zai-cduo-xian-cheng-diao-yong-python/"},{"categories":null,"content":"在各个Godot初学者教程中，实现第一个人物控制器都是使用的状态机，常见的有以下写法： ","date":"2023-01-03","objectID":"/zhuang-tai-ji-de-ji-chong-xie-fa/:0:0","tags":null,"title":"状态机的几种写法","uri":"/zhuang-tai-ji-de-ji-chong-xie-fa/"},{"categories":null,"content":"写法一 全在 Update 中 using Godot; using System; public class ScriptName : Node { // fields [Export] float Speed； [Export] float JumpHeight; private State state = State.Idle; public enum State : int { Run, Jump, Idle, Fall } public void Update { switch(state) { case State.Idel: // code case State.Run: // code case State.Jump: // code case State.Fall: // code default: // code } } } 优点 ： 至少能实现功能， 缺点： 不利于维护，不方便拓展 ","date":"2023-01-03","objectID":"/zhuang-tai-ji-de-ji-chong-xie-fa/:1:0","tags":null,"title":"状态机的几种写法","uri":"/zhuang-tai-ji-de-ji-chong-xie-fa/"},{"categories":null,"content":"写法二 写成状态类和状态机类 public interface IState { void Enter(); void Exit(); void Update(float delta); void PhysicsUpdate(float delta); } public class StateBase\u003cT\u003e : IState { private StateMachine _machine; private T agent; public virtual void Enter() { } public virtual void Exit() { } public virtual void Update(float delta) { } public virtual void PhysicsUpdate(float delta) { } } public class StateMachine : Node { Dictionary\u003cstring, IState\u003e StateInfo; IState CurrentState; public void ChangeTo\u003cT\u003e() where T : IState { ... } public override void _Process(float delta){ CurrentState.Update(delta); } public override void _Process(float delta) { CurrentState.PhysicsUpdate(delta); } } class RunState : StateBase\u003cT\u003e { ... } class JumpState : StateBase\u003cT\u003e { ... } class IdleState : StateBase\u003cT\u003e { if(Mathf.Abs(horizontalInput) \u003e 0.01) { _machine.ChangeTo\u003cRunState\u003e(); } if(verticalInput \u003e 0.1) { _machine.ChangeTo\u003cJump\u003e(); } } 优点:比写法一便于维护 缺点：如果要实现一个 Player 的状态机 和一个Enemy的状态机，他们都有相似的移动逻辑，但是Player状态机多出一些技能相关的状态；如果采用上述写法，ChangeTo()是硬编码在状态内部的，这样就不方便添加边和状态以拓展状态机 ","date":"2023-01-03","objectID":"/zhuang-tai-ji-de-ji-chong-xie-fa/:2:0","tags":null,"title":"状态机的几种写法","uri":"/zhuang-tai-ji-de-ji-chong-xie-fa/"},{"categories":null,"content":"写法三 ：基于 GraphEditor的状态机 Godot Asset Store 有很多基于 GraphEdit 的状态机实现，通过： 为状态绑定状态脚本 为转移边绑定脚本或者添加转换条件 减少状态 和 转移边 的耦合。 它们都有一个共同的缺点：不支持 c# 或者c#版本bug多 所以能不能实现一个足够简单的，C#版本的，解耦状态和转化边的状态机呢？ ","date":"2023-01-03","objectID":"/zhuang-tai-ji-de-ji-chong-xie-fa/:3:0","tags":null,"title":"状态机的几种写法","uri":"/zhuang-tai-ji-de-ji-chong-xie-fa/"},{"categories":null,"content":"写法四 ","date":"2023-01-03","objectID":"/zhuang-tai-ji-de-ji-chong-xie-fa/:4:0","tags":null,"title":"状态机的几种写法","uri":"/zhuang-tai-ji-de-ji-chong-xie-fa/"},{"categories":null,"content":"状态类 using Godot; using Godot.Collections; namespace StateMachine.Base { public interface IState { string StateName {get;} void Init(Object agent, Dictionary\u003cstring, object\u003e blackboard, IStateMachine machine); void OnEnter(); void OnExit(); void Update(float delta); void PhysicsUpdate(float delta); void Exit(); } public class StateBase : Object, IState { // state 只持有 agent 对象不持有状态机对象 protected string _StateName = \"\"; public string StateName =\u003e _StateName; public Object agent; public IStateMachine machine; private Dictionary\u003cstring, object\u003e blackboard; public virtual void Init(Object _agent, Dictionary\u003cstring, object\u003e _blackboard, IStateMachine _machine) { agent = _agent; blackboard = _blackboard; machine = _machine; } public virtual void OnEnter() { } public virtual void Update(float delta) { } public virtual void PhysicsUpdate(float delta) { } public virtual void OnExit() { } public virtual void Exit() { machine.Transition(StateName); } } } 状态类内部不能调用StateMachine的ChangeTo()方法，只能实现状态自身的更新逻辑 ","date":"2023-01-03","objectID":"/zhuang-tai-ji-de-ji-chong-xie-fa/:4:1","tags":null,"title":"状态机的几种写法","uri":"/zhuang-tai-ji-de-ji-chong-xie-fa/"},{"categories":null,"content":"工具类 IStateMachine 接口，Condition 是用于转换边的方法（返回true就转换，否则就不转换） 满足AssertTo.condition 则转换到AssertTo.nextState Transition的属性用于标志该方法是判断哪个状态转移到哪个状态的 public interface IStateMachine { void Transition(string current); void Start(string name); void Exit(); } public delegate bool Condition(); public class AssertTo : Godot.Object { public Condition condition; public string nextState; public AssertTo(Condition _condition, string _nextState) { condition = _condition; nextState = _nextState; } } [System.AttributeUsage(System.AttributeTargets.Method)] public class Transition : System.Attribute { public string from; public string to; public Transition(string _from, string _to) { from = _from; to = _to; } } ","date":"2023-01-03","objectID":"/zhuang-tai-ji-de-ji-chong-xie-fa/:4:2","tags":null,"title":"状态机的几种写法","uri":"/zhuang-tai-ji-de-ji-chong-xie-fa/"},{"categories":null,"content":"状态机类 状态机类继承自 StateBase，因此状态机是可嵌套的 public class StateMachineBase : StateBase, IStateMachine { public IState CurrentState = null; protected Dictionary\u003cstring, Array\u003cAssertTo\u003e\u003e TransitionMap = new Dictionary\u003cstring, Array\u003cAssertTo\u003e\u003e(); public Dictionary\u003cstring, Godot.Object\u003e Name2State = new Dictionary\u003cstring, Godot.Object\u003e(); // 状态机黑板 protected Dictionary\u003cstring, object\u003e blackboard; public override void Init(Godot.Object _agent, Dictionary\u003cstring, object\u003e _blackboard = null, IStateMachine _machine = null) { base.Init(_agent, _blackboard, _machine); if(blackboard == null) { blackboard = new Dictionary\u003cstring, object\u003e(); } if(_machine == null) { } // 初始化状态列表 \u0026\u0026 初始化状态名 foreach(var info in this.GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)) { if(info.ReflectedType.IsSubclassOf(typeof(StateMachine.Base.StateBase))) { if(Name2State.ContainsKey(info.Name)) { GD.Print(\"[FSM runtime] duplicate state \", info.Name); } else { IState state = info.GetValue(this) as IState; if(state == null) { // current state is null before start continue; } Name2State[info.Name] = state as Godot.Object; state.Init(agent, blackboard, this as IStateMachine); (state as Godot.Object).Set(\"_StateName\", info.Name); } } } // 初始化转换边列表 foreach(var info in this.GetType().GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)) { if(info.GetCustomAttribute\u003cTransition\u003e() is Transition transition) { if(!Name2State.ContainsKey(transition.from) || !Name2State.ContainsKey(transition.to)) { return; } if(!TransitionMap.ContainsKey(transition.from)) { TransitionMap[transition.from] = new Array\u003cAssertTo\u003e(); } TransitionMap[transition.from].Add(new AssertTo((Condition)Delegate.CreateDelegate(typeof(Condition), this, info), transition.to)); } } } #region life cycle public override void OnEnter() { Start(\"entry\"); } public override void Update(float delta) { if(CurrentState == null) return; CurrentState.Update(delta); } public override void PhysicsUpdate(float delta) { if(CurrentState == null) return; CurrentState.PhysicsUpdate(delta); } public override void Exit() { if(machine == null) { CurrentState = null; } else { base.Exit(); } } // API public void Transition(string current) { if(CurrentState == null) return; if(CurrentState is ExitState) { CurrentState.OnExit(); Exit(); return; } if(!Name2State.ContainsKey(current)) { return; } if(TransitionMap == null) { return; } if(!TransitionMap.ContainsKey(current)) { return; } foreach(AssertTo edge in TransitionMap[current]) { if(edge.condition.Invoke()) { // 添加信号 CurrentState.OnExit(); CurrentState = Name2State[edge.nextState] as IState; CurrentState.OnEnter(); return; } } } public void Start(string name) { if(Name2State.ContainsKey(name)) { CurrentState = Name2State[name] as IState; CurrentState.OnEnter(); } } } ","date":"2023-01-03","objectID":"/zhuang-tai-ji-de-ji-chong-xie-fa/:4:3","tags":null,"title":"状态机的几种写法","uri":"/zhuang-tai-ji-de-ji-chong-xie-fa/"},{"categories":null,"content":"Demo // 状态定义 public class Idle : StateBase { public override void OnEnter() { PlayAnimation(\"Idle\"); } public override void PhysicsUpdate(float delta) { if(InputCache != null) { Exit(); } } } public class Run : StateBase { public override void OnEnter() { PlayAnimation(\"Run\"); } public override void PhysicsUpdate(float delta) { Position += velocity * delta; } } public class PlayerStateMachine : StateMachineBase { // 绑定状态名和状态类型 EntryState entry = new EntryState(); Run run = new Run(); Idle idle = new Idle(); ExitState exit = new ExitState(); // 定义转换 [Transition(\"entry\", \"idle\")] public bool transition_1() { return true; } [Transition(\"idle\", \"run\")] public bool transition_2() { if(horizontalInput != 0) { return true; } return false; } [Transition(\"run\", \"idle\")] public bool transition_3() { if(agent.IsOnGround() \u0026\u0026 velocity == agent.GetGroundVelocity()) { return true; } return false; } } 这样写就把状态 和 状态转移 分离开了，另外还可以实现一些编辑器工具来生成状态机的文件，以及为指定节点绑定状态机以简化操作 Todo: 每个状态机绑定的对象类型不固定，但是状态机继承应该与 agent 对象继承具有相似的层级，所以每写一个新的状态机就强制转换agent类型过于繁琐，尝试找到优化方法！ ","date":"2023-01-03","objectID":"/zhuang-tai-ji-de-ji-chong-xie-fa/:4:4","tags":null,"title":"状态机的几种写法","uri":"/zhuang-tai-ji-de-ji-chong-xie-fa/"},{"categories":null,"content":"参考列表 Python embedding c++多线程调用python yolov7-ncnn Yolo-FastestV2 ncnn教程 ncnn 环境 opencv之Mat格式数据转换成onnxruntime的输入tensor处理的c++写法 Tracker - Norfair FPS游戏的鼠标灵敏度换算方法 phoboslab/jsmpeg-vnc 桌面复制 API - Win32 apps | Microsoft Learn桌面复制 API - Win32 apps | Microsoft Learn 最近看到有些 FPS 游戏主播被锤外挂，不禁有些感叹 人菜逼事多。所以产生了研究AI自瞄原理的想法。首先做AI自瞄不是想开挂，而是对于反外挂而言 只有了解Hacker才能Anti-Hacker。 ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:0:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"总体思路 传统的 FPS 游戏外挂需要读内存、改内存，因此很容易被检测。而 AI 自瞄只读取游戏画面(可以通过屏幕捕获、外置摄像头)，通过目标检测方法 准确的识别出游戏中的目标的类型和位置，然后通过各种移动准星的方法将准星移动到目标位置，AI 自瞄系统应该仅提供基础设施（识别系统、脚本系统、配置系统），玩家可以自定义视频输入方式，通过脚本系统定义 “如何瞄准敌人”（添加抖动等），定义识别系统的参数。 // 为了高效运行，外挂的运行时使 C/C++，脚本系统使用 Python / C# 但是，将屏幕捕获交给玩家会加重识别系统的的任务（识别敌人 + 识别屏幕），再加上坐标变换后降低了准确度，为了使识别准确度尽可能提高，将采用捕获屏幕作为输入。 github 项目地址 ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:1:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"读取游戏画面 windows 屏幕抓取技术总结 总结了windows 下各个平台的屏幕抓取性能开销对比，但是和我实测的数据有些偏差，在我实测中 DXGI 几乎不消耗 CPU/GPU 资源，GDI方案消耗大量的 CPU 资源。但是在启动了 APEX 的情况下 DXGI 仅能达到 90fps， GDI 能达到 200fps，所以我们的方案采用 GDI 方法，GDI 抓屏参考(几乎是copy)了 phoboslab/jsmpeg-vnc: A low latency, high framerate screen sharing server for Windows and client for browsers 的grabber方法，并且取得很高的效率。 #ifndef GRABBER_H #define GRABBER_H #define WIN32_LEAN_AND_MEAN #include \u003cWindows.h\u003e typedef struct { int x, y, width, height; } grabber_crop_area_t; typedef struct { HWND window; HDC windowDC; HDC memoryDC; HBITMAP bitmap; BITMAPINFOHEADER bitmapInfo; int width; int height; void *pixels; grabber_crop_area_t crop; } grabber_t; grabber_t *grabber_create(HWND window, grabber_crop_area_t crop); void grabber_destroy(grabber_t *self); void *grabber_grab(grabber_t *self); #endif 该实现需要先获取 windows 窗口句柄，然后初始化 grabber #include \u003cWindows.h\u003e ... HWND handle = FindWindow(NULL, TEXT(\"Apex Legends\")); if(!handle) return -1; grabber_crop_area_t crop { 0, 0, 0, 0 }; grabber_t * grabber = grabber_create(handle, crop); ... while(1) { void* data = grabber_grab(grabber); ... } 这里踩的坑是 void* 是一个字节数组，也就是 uchar* 数组而在 grabber.c 中设置了 bitmapInfo.biBitCount = 32; bitmapInfo.biCompression = BI_RGB; 我们不需要 A 通道数据，所以设置 bitmapInfo.biBitCount = 24 这意味着要将 grabber 捕获到的数据是 RGB 格式的用 opencv 读取需要格式 CV_8U3C: void* pixel = grabber_grab(grabber); // 8U3C -\u003e 3 通道每通道 8 位 cv::Mat frame = cv::Mat(cv::Size{ grabber-\u003ewidth, grabber-\u003eheight }, CV_8UC3); frame.data = (uchar*)pixel; 由于opencv 的格式是 BGR，神经网络输入格式是 RGB；将 cv::Mat 转为 ncnn::Mat 时需要进行格式转换： ncnn::Mat in = ncnn::Mat::from_pixels_resize(croped.data, ncnn::Mat::PIXEL_BGR2RGB, croped.cols, croped.rows, target_size, target_size); 这里可以直接从 void* 转换到 ncnn::Mat , 为了测试方便还是先转换成 cv::Mat 方便使用 cv::imshow() 显示到窗口。 ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:2:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"识别目标 识别目标 是最重要的一环，也是踩坑最多的一环。神经网络训练时框架太笨重，不适合用于软件嵌入，现有的推理框架： NCNN：腾讯的产品，号称 “0 依赖\"，运行时确实不需要 .dll 开发时需要 protobuf，vulkan。在移动平台等边缘设备优化是最好的，很适合用于 嵌入应用. MNN、MACE、TF-lite、Paddle-lite 这些都类似 NCNN 主打移动端推理 TensorRT：Nvidia 的框架，一般来说 Nvidia 下用该框架时最快的依赖 cuda,cudann TensorRT-For-YOLO-Series/main.cpp at main · Linaom1214/TensorRT-For-YOLO-Series (github.com) OpenVINO：Intel家的，缺点很明显不支持 AMD CPU 对于 AI 自瞄来说最好的选择是 NCNN 或者 TensorRT（但是开始这个项目之前没怎么了解过，先后使用了libtorch、OnnxRuntime、NCNN、TensorRT） 为了方便后续添加功能，例如移动端的实现，采用 Tensorrt 和 NCNN 两种实现。 模型使用 最新的 Yolov7， 准确率高，速度快，在不启动游戏的情况下 RTX2060 可以有120fps 的推理速度。 GitHub - WongKinYiu/yolov7: Implementation of paper - YOLOv7: Trainable bag-of-freebies sets new state-of-the-art for real-time object detectors 给出了模型训练和模型导出的方法，NCNN/TensorRT 的使用可以在 Github 找到大量的Demo，拿到Demo搞清楚输入输出即可。 这一环最麻烦的是数据格式的转换 BGR -\u003e RGB : 可以由 cv::Mat.convertTo, ncnn::Mat.resize 等方法 NHWC -\u003e NCHW: cv::dnn::blobFromImage, transposeND, 三层 for 循环硬转，tensorflow/pytorch 的轴旋转方法 ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:3:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"调用track脚本 这里使用 Python 脚本来处理神经网络的输出和鼠标移动，由于不同的用户需求不同，例如 鼠标平滑，定位精度，拉枪速度，鼠标吸附等，process 方法将在每一个推理帧的最后被调用。 def process(targets) -\u003e (float, float): for target in target: print(target) return (1.1, 2.0) 脚本需要和c++交互，process 方法需要被c++调用并捕获输出值，c++ 调用python需要include Python.h 头文件，需要添加 \u003cpython_dir\u003e/libs 库文件， 最后程序打包时需要将 python39.dll 添加到 .exe 文件目录，可以使用更小的 embed 版本来将 python 嵌入到应用（只占用10mb） #define PY_SSIZE_T_CLEAN #include \u003cPython.h\u003e int main() { Py_SetPythonHome(std::wstring(config.pythonHome.begin(), config.pythonHome.end()).c_str()); Py_Initialize();//初始化python PyObject *pModule = NULL, *pFunc = NULL, *pArg = NULL; pModule = PyImport_ImportModule(\"core\");//引入模块 pFunc = PyObject_GetAttrString(pModule, \"process\");//直接获取模块中的函数 PyObject* list = PyList_New(0); Py_INCREF(list); for (auto\u0026 obj : boxes) { PyList_Append(list, Py_BuildValue(\"(f,f,f,f,f)\", (obj.x1 + obj.x2) / 2, (obj.y1 + obj.y2) / 2, obj.x2 - obj.x1, obj.y2 - obj.y1, obj.score)); } PyDict_SetItemString(dict, \"target_list\", list); Py_DECREF(list); PyDict_SetItemString(dict, \"mouse_left_button\", Py_BuildValue(\"b\", KEY_DOWN(VK_LBUTTON))); PyDict_SetItemString(dict, \"mouse_middle_button\", Py_BuildValue(\"b\", KEY_DOWN(VK_MBUTTON))); PyDict_SetItemString(dict, \"mouse_right_button\", Py_BuildValue(\"b\", KEY_DOWN(VK_RBUTTON))); PyDict_SetItemString(dict, \"mouse_ctrl_button\", Py_BuildValue(\"b\", KEY_DOWN(VK_CONTROL))); PyObject* args = PyTuple_New(1); PyTuple_SetItem(args, 0, dict); PyObject* pRet = PyObject_CallObject(pFunc, args); if (!pRet) return; if (PyErr_Occurred()) { PyErr_Print(); } Py_Finalize(); //释放python return 0; } python 端需要获取非激活窗口的键盘或者鼠标状态需要使用pyhook， 但是在 c++ 可以很简单的获得： #define KEY_DOWN(VK_NONAME) ((GetAsyncKeyState(VK_NONAME) \u0026 0x8000) KEY_DOWN(VK_LBUTTON); KEY_DOWN(VK_MBUTTON); KEY_DOWN(VK_RBUTTON); KEY_DOWN(VK_CONTROL); 并通过 c++ 传递给 python ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:4:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"更新准星位置 参考了这位老哥的鼠标定位方法 FPS游戏（AI自瞄原理） - 哔哩哔哩 (bilibili.com) 但是这里给出的计算方式是有偏差的, 但是利用 角度替代像素 是正确的，游戏引擎中相机的角度是使用欧拉角来计算的, 一般第一人称游戏使用鼠标的 水平输出(HorizontalInput) 和 竖直输出(VerticalInput) 来控制摄像机转动，这一位置，所以对于不同的游戏 XInput 的大小和相机转动的欧拉角可能不一样，也就是说我们定义一个单位: $$ 像素角(fa) = 转动一弧度移动的像素(pixel/rad) $$ 像素角的计算和测量 $$ fa = \\frac{游戏水平转动一周需要的像素\\times 2 \\times \\pi}{360} \\times 游戏内灵敏度 \\times ADS $$ 所以只需要测量游戏内水平转动一周需要移动的像素即可(游戏内瞄准一个点不断地改变pixel 的值，直到相机画面不会抖一下)，不同倍镜下的 fa 值是不同的需要单独测量。 import win32api import win32con pixel = 10909 for i in range(pixel) { win32api.mouse_event(xxx, 1, 0, 0, 0) } 现在有了 fa 的值之后，再来计算如何将鼠标移动到频幕上的点 Point(x, y), 首先计算目标点和屏幕某点 P 的偏移向量 offset(x, y)但是，真实的移动是发生在游戏空间的 3D 世界。 也就是需要将视角方向从OB 调整到OG方向，借鉴 水平像素转角度方法可以先将视线 OB 调整到 OC，再从OC调整到OG，这个过程中 相机到视平面的距离是不变的。 为了保持距离不变，所以是先从 OB -\u003e OI -\u003e OK，所以将三维的转动过程转化为两次二维的转动 $$ dis2screen = AB = \\frac{half_screen_width}{\\tan{\\frac{fov}{2}}} \\ \\quad\\ \\quad\\ \\theta_x = \\angle{BAI} = \\arctan{\\frac{BC}{AB}} \\arctan{\\frac{offset_x}{dis2screen}} \\quad\\ \\quad\\ \\quad\\ \\quad\\ \\theta_y = \\angle{CAG} = \\arctan{\\frac{CG}{AC}} = \\arctan{\\frac{CG}{\\sqrt{AB^2+BC^2}}} = \\arctan{\\frac{offset_y}{\\sqrt{dis2screen^2 + offset_x^2}}} $$ 这样就得到了两个方向的偏转角$(\\theta_x, \\theta_y)$，所以根据之前测量得到的 fa 值，可以得到鼠标的像素偏移值： $$ pixel_i = \\theta_i \\times \\frac{fa}{游戏内灵敏度\\times FOV} $$ 所以就可以由屏幕偏移量 offset 得到鼠标偏移量 pixel， 此外需要能够移动鼠标的方法，在 python 环境下，常规的自动化库方法都是无效的，鼠标驱动层的移动应该是有效的但是麻烦，win32api 也是有效的，不过需要以管理员权限启动程序。 import win32api import win32con win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, int(pixel_x), int(pixel_y), 0, 0) ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:5:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"使用 Json 读取配置 使用简单又方便的 nlohmann/json: JSON for Modern C++ (github.com)，只有 .hpp 头文件 std::cout \u003c\u003c \"# init config ...\" \u003c\u003c std::endl; // ----------------------- config ----------------------- std::ifstream f = std::ifstream(); json json_data;; Config config; // 需要根据当前运行环境构造文件全名 try { f.open(\"./config.json\"); json_data = json::parse(f); std::cout \u003c\u003c \"[init] load config from: \" \u003c\u003c \"config.json\" \u003c\u003c std::endl; config.windowName = json_data[\"windowName\"]; config.classNamesPath = json_data[\"classNamesPath\"]; config.pythonHome = json_data[\"pythonHome\"]; config.debug = json_data[\"debug\"]; config.detectorName = json_data[\"detectorName\"]; config.paramPath = json_data[\"paramPath\"]; config.binPath = json_data[\"binPath\"]; config.boxThreshold = json_data[\"boxThreshold\"]; config.nmsThreshold = json_data[\"nmsThreshold\"]; config.useGPU = true; config.mouseMovementDelay = json_data[\"mouseMovementDelay\"]; config.receptiveField = json_data[\"receptiveField\"]; } catch (std::exception\u0026 e) { std::cout \u003c\u003c \"配置文件读取失败\" \u003c\u003c std::endl; return -1; } ","date":"2023-01-03","objectID":"/you-xi-wai-gua-ai-zi-miao/:6:0","tags":null,"title":"[游戏外挂] 辅助瞄准系统","uri":"/you-xi-wai-gua-ai-zi-miao/"},{"categories":null,"content":"在之前的文章里提到过 里世界机制 游戏机制，但是最初的版本是需要手动用右摇杆移动 “透镜” 来观察里世界的物体，这样的设计有以下几个缺陷： 需要控制左右摇杆和跳跃键来控制人物和移动 “透镜” 透镜 自由度过高，限制了关卡设计的可能性 仅仅实现了遮挡 / 显示 物体，并没有修改物体的碰撞体积 后来玩到 《塞尔达传说三角力量 2》 ，其中林克化身壁画在墙壁游走的能力给了我很大的启发：“壁画林克只能在一条水平线上移动，而作者利用地形的高低差设计了很多意想不到的关卡”, 这背后的思考是 “通过限制玩家的能力，来增加关卡设计的可能性”，回到里世界机制上，我们可以通过限制\"透镜\"的移动和玩家进入的方式来增加关卡设计的可能性： 于是，我对机制进行如下修正: 通过推箱子的形式移动透镜，而不是用右摇杆 限制透镜的进入点，而不是全开放 这样的修正可以以某种方式设计关卡，让玩家思考以何种顺序移动各个箱子能到达想要去的目标，它的本质是推箱子， 只是换上了一层 里世界 的皮 下面来构思整个机制的实现： 实现 “透镜” 内的物体不显示, 之外的物体显示 -\u003e 使用光照剔除 实现 “透镜” 内的物体与玩家碰撞，之外的物体不碰撞 -\u003e 使用 PolygenShape动态修改 实现 推箱子 机制 -\u003e 箱子内和箱子都能推动（避免死锁） ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:0","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"光照剔除 在之前的实现里，将里世界的所有物体放入一个单独的 CanvasLayer，再应用一个 CanvasModulate 将不透明度设置为 0， 然后用一一个 Light2D 来为里世界物体添加 透明度，这样实现玩家不能与里世界物体发生物理交互所以采用了很复杂的实现方式。 Godot Light2D 有一个 Mask 模式专门用于剔除物体，被剔除的物体需要确保 层号在 (layer_min, layer_max) 之间 光照层在 Item Cull Mask 之中 使用一个 Texture 与透镜大小相同的 Light2D 节点， 选择 Add / Mix 模式位被剔除的物体赋予颜色，同样需要确保光照层和画布层设置正确 此外，可以通过 WorldEnviroment 节点为里世界的物体增加荧光，或者设置边缘光 Shader 增加区分度。 ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:1","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"动态碰撞体 动态碰撞体很简单，只需要每帧取碰撞体矩形 DefaultRect 透镜碰撞体矩形 LensRect，计算两个 Rect2 的 ∩ 即可 public class LensRect : Area2D { public Dictionary\u003cstring, Godot.Object\u003e NearbyLens = new Dictionary\u003cstring, Godot.Object\u003e(); Vector2 extent; CollisionShape2D shape; public override void _Ready() { shape = GetNode\u003cCollisionShape2D\u003e(nameof(CollisionShape2D)); extent = (shape.Shape as RectangleShape2D).Extents; } // Called every frame. 'delta' is the elapsed time since the previous frame. public override void _PhysicsProcess(float delta) { foreach(DynamicPolygon polygon in NearbyLens.Values) { polygon.Clips(ToGlobal(shape.Position - extent), ToGlobal(shape.Position + extent)); } } void _on_LensRect_area_entered(Area2D body) { Node parent = body.GetParent(); if(parent is DynamicPolygon) { NearbyLens[parent.Name] = parent; } } void _on_LensRect_area_exited(Area2D body) { Node parent = body.GetParent(); if(parent is DynamicPolygon) { NearbyLens.Remove(parent.Name); } } } Lens 需要使用一个 Area2D 记录附近可能相交的里世界物体，在每一个物理帧调用 polygon.Clips() 更新附近里世界物体的多边形点集 对于每一个里世界物体， 只需实现 Clips 方法， 并保证碰撞体附近没有 Lens 时，碰撞体保持休眠状态 public class DynamicPolygon : KinematicBody2D { private CollisionPolygon2D shape; private Rect2 rect; public override void _Ready() { Sprite sprite = GetNode\u003cSprite\u003e(nameof(Sprite)); shape = GetNode\u003cCollisionPolygon2D\u003e(nameof(CollisionPolygon2D)); rect = sprite.GetRect(); ; } // Called every frame. 'delta' is the elapsed time since the previous frame. public void Clips(Vector2 p1, Vector2 p2) { Rect2 _rect = new Rect2(ToLocal(p1), ToLocal(p2) - ToLocal(p1)); Rect2 inter = rect.Clip(_rect); Vector2 [] array = new Vector2[4]; Vector2 local = inter.Position; array[0] = local; array[1] = local + Vector2.Right * inter.Size.x; array[2] = local + inter.Size; array[3] = local + Vector2.Down * inter.Size.y; shape.Polygon = array; } void _on_Area2D_area_entered(Area2D area) { if (area is LensRect magic) { shape.SetDeferred(\"disabled\", false); } } void _on_Area2D_area_exited(Area2D area) { if (area is LensRect magic) { shape.SetDeferred(\"disabled\", true); } } } 这个地方有很多可以优化的点（下次一定），例如： 目前仅支持 矩形 Lens 和 矩形里世界物体，可以考虑支持任意多边形 可以优化同时对 多个Lens， 多个 里世界物体 更新（例如使用 ECS， 做一个 System 统一更新，效率更高，也可以做一些向量优化，maybe） 实现 其他 PhysicsBody 的里世界物体 添加 [Tool]编辑器代码，方便 Debug ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:2","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"推箱子 首先实现箱子类，他是一个可推动接口，实现 Push 和Stop方法, 受到重力影响 public interface IPushable { void Push(Vector2 direction); void Stop(); } public class TestMovableCube : KinematicBody2D, IPushable { private Vector2 _velocity = Vector2.Zero; [Export] private float _pushSpeed = 100f; public override void _PhysicsProcess(float delta) { _velocity += Vector2.Down * 100f; _velocity = MoveAndSlide(_velocity); } public void Push(Vector2 direction) { _velocity += _pushSpeed * direction; } public void Stop() { _velocity = Vector2.Zero; } } 其次是 玩家/怪物的Push状态, 这里在每一帧计算正在推动的物体列表， 然后每帧调用IPushable.Push() 方法，每帧开始时和退出状态时需要将所有正在推动的物体停下来（否则将做匀速直线运动） /* 状态有四个生命周期, 进入, 更新， 物理更新， 退出 有 Init 接口函数用于初始化，有 Exit() 方法用于退出当前状态 */ public class Push : StateBase { private Player target; private List\u003cIPushable\u003e cacheCubes = new List\u003cIPushable\u003e(); public override void OnEnter() { target = agent as Player; GD.Print(\"Enter \", StateName); } public override void Update(float delta) { } public override void PhysicsUpdate(float delta) { target.GravityHandler(target.DefaultGravity.JumpGravity, delta); target.GestureHandler(); target.HorizontalHandler(); target.SnapHandler(); foreach (var cube in cacheCubes) { cube.Stop(); } cacheCubes.Clear(); for (int i = 0; i \u003c target.GetSlideCount(); i++) { // tips: Godot.Collections.Array dont support the c# interface var collision = target.GetSlideCollision(i); if (collision.Collider is IPushable pushable) { GD.Print(collision.Normal); cacheCubes.Add(pushable); pushable.Push(-collision.Normal); } } if ((!Input.IsActionPressed(\"ui_left\") \u0026\u0026 !Input.IsActionPressed(\"ui_right\")) || target.JumpRequest() || !target.IsOnFloor() ) { Exit(); } } public override void OnExit() { foreach (var cube in cacheCubes) { cube.Stop(); } GD.Print(\"Exit \", StateName); } } Tips: 这里为什么不让物体自己动? 而是要推动者维护一个推动列表呢？如果 IPushable 自己动，即使 Player 紧贴着 IPushable推动，IPushable仍然不能在每帧检测到有 Player 正在推它，这会导致 IPushable 移动时断断续续的（不清楚这是bug还是特性) ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:3","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"美化 - 添加进出口特效 由于这本来是一个原型项目，所以只实现见简单特效即可（主要是花里胡哨的我也不会），Lens的进出口使用激光门（就是两束激光） 激光实现 - RayCast2D - Position2D - Sprite - CPUParticals2D [Tool] public class Laser : RayCast2D { Sprite sprite; Position2D anchor; float default_length = 580f; Vector2 target = Vector2.Right*10; CPUParticles2D articles; public override void _Ready() { anchor = GetNode\u003cPosition2D\u003e(nameof(Position2D)); sprite = anchor.GetNode\u003cSprite\u003e(nameof(Sprite)); Enabled = true; articles = GetNode\u003cCPUParticles2D\u003e(\"LaserPartical\"); Scale = Vector2.One; } // // Called every frame. 'delta' is the elapsed time since the previous frame. public override void _PhysicsProcess(float delta) { anchor.Rotation = anchor.Position.AngleToPoint(CastTo) + Mathf.Pi; float dis; if (!Engine.EditorHint) { if (IsColliding()) { target = GetCollisionPoint(); articles.GlobalPosition = GetCollisionPoint(); articles.Direction = GetCollisionNormal(); articles.Emitting = true; } else { articles.Emitting = false; } dis = ToLocal(target).Length(); } else { dis = CastTo.Length(); } anchor.Scale = new Vector2(dis / default_length, anchor.Scale.y); } } 激光使用了Energy Beams - Godot Shaders 的实现， 使用一个 Texture 表示一个激光，这种做法可以使用Shader 计算扰动，但是对于本题这种点到点激光，并且可能发生转动的情况下，还是很不方便，在计算起始/结束点和激光 Sprite 的Scale 的关系时不太好计算（主要是 Sprite 只能通过 Scale 调整大小而不便指定 Rect 的 Size， 好像也可以,emmm）， 激光命中的粒子就随便弄一弄就好了。 ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:4","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"一些思考核问题 在实现过程中遇到很多问题： 被推动的箱子时主动移动还是被动移动? 箱子使用 KinamicBody 还是RigidBody（能够模拟下落，抛，旋转）? 箱子应该从内部移动还是外部移动? 是否需要设计里世界物体Mask？（例如，红箱子只能显示红色物体，绿箱子只能显示绿物体，其实应该有Mask，这样可以增加关卡设计的多样性） 是否应该设置里世界物体的显示时间？（可以增加该机制） Godot.Collections.Array 不能存放 C# 接口，会报错，不知道是 Bug还是什么？ 是否应该有其他多边形状的 Lens 和 里世界物体？ （应该有的） Lens 的矩形是否应该有很多个进出口？（为了方便机制设计，应该有，所以一个Lens有很多个 PolyShape） 是否里世界物体应该高亮（应该的，为了区分里外物体，但是还没想好高亮应该怎么做？边缘发光，荧光，虚线还是整体发光？） 是否应该区分Lens 的可推动部分和不可推动部分？（应该，有利于复杂关卡设计） ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/:0:5","tags":null,"title":"[游戏机制] 里世界-优化","uri":"/you-xi-ji-zhi-li-shi-jie-ji-zhi-you-hua/"},{"categories":null,"content":"里世界机制 机制概念简述：存在两个不同的世界，里世界和表世界 他们有大致相同的场景整体形状，不同的场景风格（例如，崭新\u003c-\u003e老旧，清洁\u003c-\u003e污染） 有一个透镜能在表世界看见里世界的物体并且互动 只有玩家能在里世界和表世界间穿梭，这意味着玩家可以通过切换世界来躲避伤害 所有的外部物体（除玩家外），与透镜发生碰撞时可以 以一种特效的的方式穿过，暗示对玩家没有伤害 直接与透镜碰撞然后消失 通过对透镜的形状限制来设计关卡 实现：表示世界和里世界将在一个场景节点中表示 透镜物体是一个Light2D， 通过光照Mask显示/剔除里世界的物体的Sprite 透镜物体是一个Area2D，通过记录进入区域中的里世界物体，并且实时修改里世界物体的碰撞形状，如果是表世界（那么根据简述3来处理） public class SuperLens : Area2D { public Dictionary\u003cstring, InnerObject\u003e data = new Dictionary\u003cstring, InnerObject\u003e(); public void OnObjectExit(Node node) { if(node is InnerObject innerObject \u0026\u0026 data.ContainsKey(innerObject.Name)) { data.remove(innerObject.Name); } } public void OnObjectEnter(Node node) { if(node is InnerObject innerObject ) { data[innerObject.Name] = innerObject; } if(node is OuterObject outerObject ) { ProcessOuterObject(outerObject); } } public override void _PhysicsProcess(float delta) { foreach(var inner in data.Values) { // 更改碰撞体积 inner.Rect = inner.DefaultRect.overlap(this.Rect); } } } ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-li-shi-jie/:0:0","tags":null,"title":"[游戏机制] 里世界","uri":"/you-xi-ji-zhi-li-shi-jie/"},{"categories":null,"content":"使用 Godot 对WindowFrame 进行拙劣的模仿，观察视频中的窗体有以下性质： 窗体既是 UI 也是可以与玩家互动的 场景物体 窗口的位置可以由场景物理改变也可以由鼠标控制改变 玩家可以发射子弹，子弹碰到的边进入锁定状态，一段时间后子弹消失，并且解除锁定 考虑一下几种设计： ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-chuang-ti-hu-dong/:0:0","tags":null,"title":"[游戏机制] 窗体互动","uri":"/you-xi-ji-zhi-chuang-ti-hu-dong/"},{"categories":null,"content":"方案一 存在一个窗体对象window和场景对象rect 每一帧将rect大小和位置经过MPV变换后同步到窗口大小 每一个rect 对象有一个默认的初始大小 rect 对象持有四条边的对象 line，每个line对象有 follow/move/lock/idle状态 Follow 状态的边跟随 target(player) 运动 Move 状态的边能被鼠标拖动 Lock 状态的边在玩家移动过程中充当 墙 或 地板 Idle 状态，是场景中没有 target 时的状态 rect 对象实进入场景树的时候生成 windows 对象，并持有，rect退出场景树的时候回收 windows 对象 各个状态都有对应的 Physics Collision Layer / Mask，例如锁定状态的边会阻挡某些攻击，拖动时和锁定时与玩家的碰撞是不一样的。 using Godot; using System; public class InteractiveAnchor : RigidBody2D { public Vector2 velocity; public bool IsStop = false; public Vector2 StopPosition = Vector2.Zero; ColorRect rect; RandomNumberGenerator _random = new RandomNumberGenerator(); public delegate void InteractiveAnchorCallBack(InteractiveAnchor anchor); public InteractiveAnchorCallBack callback; // cache 一旦锁定目标，不可更改！！ InteractiveLine AnotherCache = null; public override void _Ready(); public void Init(Vector2 _velocity, InteractiveAnchorCallBack _callback); public override void _ExitTree(); // // Called every frame. 'delta' is the elapsed time since the previous frame. public override void _PhysicsProcess(float delta); // 添加抖动将要删除时 public void _on_DeleteEffect_timeout(); void _on_Area2D_body_entered(Node body); void _on_Area2D_body_exited(Node body); void CacheCurrentState(Vector2 origin_global_position); } public class InteractiveArea : Area2D { public override void _Ready(); Node Scene; public override void _EnterTree(); public override void _PhysicsProcess(float delta); void _on_Area2D_body_entered(Node body); void _on_Area2D_body_exited(Node body); } public class InteractiveBorder : Node2D { // 显示区域大小 public Rect2 window; [Export] public Rect2 DefalutRect; [Export] public float BorderWidth; public InteractiveLine left; public InteractiveLine right; public InteractiveLine top; public InteractiveLine down; public InteractiveWindow interactiveWindow; public Vector2 Start; public Vector2 End; public Rect2 UIRect; public override void _Ready(); public override void _EnterTree(); public override void _Draw(); public override void _Process(float delta); public override void _PhysicsProcess(float delta); public void Reset(); public void SetRect(Rect2 _window); public void SetCollision(bool flag); } public class InteractiveLine : KinematicBody2D { public bool IsLocked; static public string IsSlideName = \"\"; public SegmentShape2D shape; public InteractiveWindow window; public Vector2 velocity = Vector2.Zero; public int ColllisionCount = 0; [Export] public Vector2 DefaultBias; public override void _Ready(); public override void _ExitTree(); public override void _PhysicsProcess(float delta); public void SetCollision(uint layer, uint mask); public void Reset(); public float DistanceToLine(Vector2 P, Vector2 A, Vector2 B); } public class InteractiveLineFollow : StateNode\u003cInteractiveLine\u003e { public override void Enter() { target.SetCollision(target.window.FollowLayer, target.window.FollowMask); } public override void _PhysicsUpdate(float delta) { /// 如果没有目标，就转移到Lock？ if(!target.window.IsLockTarget) { _machine.Transition\u003cInteractiveLineIdle\u003e(); return; } if(target.window.Target.IsInsideTree()) { target.GlobalPosition = target.window.Target.GlobalPosition + target.DefaultBias; } if(target.ColllisionCount != 0) { _machine.Transition\u003cInteractiveLineLock\u003e(); return; } } public class InteractiveLineIdle : StateNode\u003cInteractiveLine\u003e { public override void _PhysicsUpdate(float delta) { if(target.window.IsLockTarget) { _machine.Transition\u003cInteractiveLineFollow\u003e(); return; } } } public class InteractiveLineLock : StateNode\u003cInteractiveLine\u003e { Vector2 cachePosition = Vector2.Zero; public override void Enter() { target.IsLocked = true; cachePosition = target.Position; target.SetCollision(target.window.LockLayer, target.window.LockMask); } public override void Exit() { target.IsLocked = false; } public override void _PhysicsUpdate(float delta) { // TODO:这里是否可以不移动锁定的目标不移动 if(cachePosition != null) target.Position = cachePosition; if(target.ColllisionCount == 0) { _machine.Transition\u003cInteractiveLineFollow\u003e(); return; } if(","date":"2023-01-03","objectID":"/you-xi-ji-zhi-chuang-ti-hu-dong/:1:0","tags":null,"title":"[游戏机制] 窗体互动","uri":"/you-xi-ji-zhi-chuang-ti-hu-dong/"},{"categories":null,"content":"方案二 不使用 UI 对象，将交互和物理全部集中到一个 Rect 对象中。 交互窗体包含四条边，每条边包含碰撞设置和鼠标靠近检查（锁定状态） 每条边拥有相似的几种状态，特别的在拖动时，依然使用velocity来移动每条边 当鼠标左键按下 \u0026\u0026 鼠标位置在边的拖动区域时 ==\u003e 进入拖动状态 松开鼠标左键时 ==\u003e 退出拖动状态 拖动状态下，鼠标位置，边位置，边速度的关系如下 $$ velocity_L = \\frac{(pos_M - pos_L) \\cdot normal_L}{||normal_L||} $$ 这样，窗口移动始终比鼠标位置延后一帧，但是移动过程中可以进行物理检测 窗口根据三条边的位置绘制窗口（场景中绘制），并且生成一个mask覆盖整个屏幕（不使用方案一中生成相机纹理在windows中显示） 如果某条边的移动会使得 player 与其他物体碰撞，那么该移动应该被修正: 会与player碰撞的物体有两种可能： a. 场景中的物体 -\u003e 丢弃当前的移动 b.窗体中的自由对边 -\u003e 保持当前移动 c.窗体中的锁定对边 -\u003e 丢弃当前移动 为了使移动边感知到玩家的碰撞，需要为边增加一个Push状态（不用增加，写在Move里即可），该状态下每次移动时应该对玩家进行移动测试，如果通过测试则移动否则不移动。 在边的Move状态下，应该停止相机对 Player的跟踪 2D 引擎不能如3D一样剔除视锥外的物体，不渲染/不更新窗口外的物体只能通过碰撞来实现 a. 所有进入窗体的对象将恢复更新，退出窗体的对象停止更新 b. 场景对象持有所有场景物体的引用，所以当玩家进入窗口时可以直接调用场景节点的Stop方法，这将停止所有除（player，window，obj_in_window）的对象。 ","date":"2023-01-03","objectID":"/you-xi-ji-zhi-chuang-ti-hu-dong/:2:0","tags":null,"title":"[游戏机制] 窗体互动","uri":"/you-xi-ji-zhi-chuang-ti-hu-dong/"},{"categories":null,"content":"情景引入 考虑以下情形，采集用户水平输入 float HorizontalInput 来控制 player 的水平位移 void Update(float delta) { velocity.x = HorizontalInput * WalkSpeed * delta; } 这样写有两个缺点： 当影响水平速度的因素不只是水平输入时，不同因素的叠加不方便。不应该是 = 而应该是 +=; 移动完全与输入一直，看起来很僵硬； ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:1:0","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"解决方案 所以需要有这么一个函数(缓动函数)，它对输入的响应由可控的延迟，但最终会与输入保持一致 // 添加示例函数1.1 为了使缓动曲线更好的模拟现实世界中由于力产生加速度的运动，这里使用一个二阶系统来描述： $$ y + k_1\\cdot y^{’} + k_2\\cdot y^{’’} = x + k_3 \\cdot x^{’} $$ 等价的写法： $$ y + k_1\\cdot \\frac{\\mathrm{d} y}{\\mathrm{d} t} + k_2\\cdot \\frac{\\mathrm{d} ^2 y}{\\mathrm{d}^2 t} = x + k_3 \\cdot \\frac{\\mathrm{d} x}{\\mathrm{d} t} $$ 通过调整 $k_1, k_2,k_3$ 可以改变图像的形状， // 插入示例图像1.2 现在添加三个变量： $$ f = \\frac{1}{2\\pi \\sqrt{k_2}}, \\quad \\theta = \\frac{k_1}{2\\sqrt{k_2}}, \\quad r = \\frac{2k_3}{k_1} $$ 解方程组可得： $$ k_1 = \\frac{\\theta}{\\pi f}, \\quad k_2 = \\frac{1}{(2\\pi f)^2}, \\quad k_3 = \\frac{r \\theta}{2\\pi f} $$ 原二阶系统的微分方程变为： $$ y +\\frac{\\theta}{\\pi f} \\cdot y^{’} + \\frac{1}{(2\\pi f)^2} \\cdot y^{’’} = x + \\frac{r \\theta}{2\\pi f} \\cdot x^{’} $$ 这里 $f, \\theta, r$ 都具有现实意义了 $f$ 以 $hz$ 为单位，代表系统固有频率，它描述系统对输入变化的响应速度 $\\theta$ 代表系统的阻尼系数，描述了系统如何最终趋于稳定 $r$ 控制系统的初始响应 当 $r = 0$ 时系统需要花费一点时间才能从禁止开始加速 当 $r \u003e 0$ 时系统立刻对变化做出反应 当 $r \u003e 1$ 时系统变化将冲过目标 当 $r \u003c 0$ 时系统会有抬手运动（先反向运动） 一般为机械链接设置 $r = 2$ 现在只剩下最后一个问题了，如何解二阶系统？ ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:2:0","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"二阶微分方程数值解 ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:3:0","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"1. 半隐式欧拉法 该方法在该问题下与复杂的 Verlet 积分法 有着相同的精度， 首先计算 x 变化率 $$ x^{’}{n+1} = \\frac{x{n+1} - x_n}{T} \\ $$ 然后计算 y 的变化 $$ \\begin{cases} y_{n + 1} = y_{n} + Ty^{’}{n} \\ \\quad\\ y^{’}{n+1} = y^{’}{n} + Ty^{’’} \\ \\end{cases} $$ 由于: $$ y^{’’} = \\frac{x + k_3 x^{’} - y - k_1y^{’}}{k_2} $$ 所以： $$ y^{’}{n+1} = y^{’}{n} + T\\cdot \\frac{x{n+1} + k_3 x^{’}{n+1} - y{n+1} - k_1y^{’}_{n}}{k_2} $$ 这存在一个问题，如果频率 $f$ 远大于帧率，系统将变得不稳定，会产生无穷大的值： 可以简单地设置 f 的取值范围 通过数学方法确保不发生极端情况 为了提供更多的鲁棒性，采用方案二 分析 不稳定产生的原因，该系统的本质是反馈系统，他的迭代输出将被反馈到后续的迭代用于计算，当帧间时间步长和参数相比太大时，随着时间增加，误差将逐渐累积，当超过某个临界值时，误差会开始滚雪球，迅速导致灾难性后果，为了计算该临界值，引入线性代数方法： $$ \\begin{cases} y_{n + 1} = y_{n} + Ty^{’}{n} \\ \\quad \\ y^{’}{n+1} = y^{’}{n} + T\\cdot \\frac{x{n+1} + k_3 x^{’}{n+1} -(y{n} + Ty^{’}{n}) - k_1y^{’}{n}}{k_2} \\end{cases} $$ 展开合并同类项： $$ \\begin{cases} y_{n + 1} = y_{n} + Ty^{’}{n} \\ \\quad \\ y^{’}{n+1} = \\frac{-T}{k_2} y_n + \\frac{k_2 - T^2 - Tk_1}{k_2}y^{’}{n} + \\frac{T}{k_2}x{n+1} + \\frac{Tk_3}{k_2}x^{’}_{n+1}\\ \\end{cases} $$ 矩阵表示如下： $$ \\begin{bmatrix} y\\ y^{’} \\end{bmatrix}_{n+1} = \\begin{bmatrix} 1 \u0026 T\\ -\\frac{T}{k_2} \u0026 \\frac{k_2 - T^2 - Tk_1}{k_2} \\end{bmatrix} \\cdot \\begin{bmatrix} y\\ y^{’} \\end{bmatrix}_{n} \\begin{bmatrix} 0 \u0026 0\\ \\frac{T}{k_2} \u0026 \\frac{Tk_3}{k_2} \\end{bmatrix} \\cdot \\begin{bmatrix} x\\ x^{’} \\end{bmatrix}{n+1} $$ 简写如下 $$ Y{n+1} = A\\cdot Y_n + B\\cdot X_{n+1} $$ 分析： $A$ 称为状态转移矩阵，他表示迭代是如何影响状态变量的，直观来说如果 $A$ 矩阵不导致状态变量 $Y$ 的增长，那该反馈是稳定的；考虑$A$ 作为值而非变量，利用特征值理论，记 $A$ 的特征值$\\lambda$ 如果 $\\lambda_i \u003c 1$, Y 将逐渐减小趋于稳定 如果 $\\lambda_i \u003e 1$, Y 迅速增大，很快变得无法控制 计算特征值如下： $$ det(A - \\lambda I) = 0 $$ 展开后 $$ k_2 \\lambda^2 + (T^2 + Tk_1 - 2k_2)\\lambda (k_2-Tk_1) = 0 $$ 解关于 $\\lambda$ 的二次方程 $$ \\lambda = \\frac{ -b \\pm \\sqrt{b^2-4ac}}{2a} $$ 令 $|\\lambda| \u003c 1$: 得: $$ T \u003c \\sqrt{4k_2 + k_1^2} - k_1 $$ 这里 如果时间步长大于临界值, 将拆分为多个了迭代来计算 public classs SecondOrderDynamics { private float T_crit; // critical stable time step public SecondOrderDynamics(float f, floatz, float r, Vector x0) { // update compute constants k1 = z / (PI * f); k2 = 1 / ((2 * PI * f) * (2 * PI * f)); k3 = r * z / (2 * PI * f); T_crit = 0.8f * (sqtr(4 * k2 + k1 * k1)); xp = x0; y = x0; yd = 0; } public Vector Update(float delta, Vector x, Vector xd = null) { if(xd == null) { xd = (x - xp) / delta; xp = x; } int interations = (int)Ceil(delta / T_crit); // take extra iterations if delta \u003e T_crit delta = delta / iterations; for(int i = 0; i \u003c iterations; i++) { y = y + delta * yd; yd = yd + delta * (x + k3 * xd - y - k1*yd) / k2; } return y; } } 此外，如果想避免迭代次数过多，可以限制 $k_2$ 的值（减缓运动） $$ k_2 \u003e \\frac{T^2}{4} + \\frac{Tk_1}{2} $$ float k2_stable = Max(k2, 1.1f * (T*T/4 + T*k1/2)); ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:3:1","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"2.零极点匹配法（高精度）没懂 public classs SecondOrderDynamics { private Vector xp; private Vector y, yd; private float _w, _z, _d, k1, k2, k3; public SecondOrderDynamics(float f, float z, float r, Vetor x0) { _w = 2 * PI * f; _z = z; _d = _w * sqrt(Abs(z*2-1)); k1 = z / (PI * f); k2 = 1 / (_w * _w); k3 = r * z / _w; xp = x0; y = x0; yd = 0; } public Vector Update(float delta, Vector x, Vector xd = null) { if(xd == null) { float k1_stable, k2_stable; if(_w * T \u003c _z) { k1_stable = k1; k2_stable = Max(k2, T * T / 2+ T * k1 / 2, T*k1); } else { float t1 = Exp(-_z * _w * T); float alpha = 2 * t1 * (_z \u003c= 1 ? cos(T * _d) : cosh(T * _d)); float beta = t1 * t1; float t2 = T / (1 + beta -alpha); k1_stable = (1 - beta) * t2; k2_stable = T * t2; } y = y + T * yd; yd = yd + T * (x + k3*xd -y - k1*yd) / k2_stable; return y; } } } ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:3:2","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"3. 其他数值解方法（略） 参考: t3ssel8r:Giving Personality to Procedural Animations using Math ","date":"2023-01-03","objectID":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/:3:3","tags":null,"title":"游戏动画中的缓动函数","uri":"/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"categories":null,"content":"线性模型.html import numpy as np import matplotlib.pyplot as plt import copy from IPython import display np.random.seed(0) data = [[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]] def load_data(): X = np.array(data).T label = copy.deepcopy(X[2,:].reshape(1,17)) X[2,:] = 1 assert X.shape == (3,17) assert label.shape == (1,17) return X, label $$ l(\\beta) = \\sum_{i=1}^{m}(-y_i \\beta^Tx_i+ln(1+e^{\\beta^T x_i})) $$ $$ = \\sum_{i=1}^{m}-y_i \\beta^Tx_i+\\sum_{i=1}^{m}ln(1+e^{\\beta^T x_i}) $$ $$ = (\\beta^TX)Y + np.sum(ln(1+e^{Y_i})) $$ 使用numpy实现如下： part_1 = np.dot(Y, label.T) part_2 = np.sum(np.ln(1+np.exp(Y))) def loss(label, Y): part_1 = -np.dot(Y, label.T) part_2 = np.sum(np.log(1+np.exp(Y))) return part_1 + part_2 ","date":"2023-01-03","objectID":"/xian-xing-mo-xing/:0:0","tags":null,"title":"线性模型","uri":"/xian-xing-mo-xing/"},{"categories":null,"content":"前向传播 $input = W,X$ $output = W^{‘T} X^{’} = W^T X+b$ def forward_propagation(W,X): Z = np.dot(W,X) A = 1/(1+np.exp(-Z)) return A ","date":"2023-01-03","objectID":"/xian-xing-mo-xing/:0:1","tags":null,"title":"线性模型","uri":"/xian-xing-mo-xing/"},{"categories":null,"content":"初始化参数: 使用随机初始化 n —— 特征值数量为 m —— 样本数量 $w^{’} = (w,b)$ $w.shape == （1,n+1）$ def initialization(n): return np.random.randn(1,n+1) # return np.zeros((1,n+1)) ","date":"2023-01-03","objectID":"/xian-xing-mo-xing/:0:2","tags":null,"title":"线性模型","uri":"/xian-xing-mo-xing/"},{"categories":null,"content":"反向传播 $$ dw = -\\sum_{i=1}^{m}x_i(y_i-p_1(x_i;\\beta)) $$ $$ dw = -(label-Y)X^T $$ def back_propagation(X,Y,label): return -np.dot((label-Y),X.T) ","date":"2023-01-03","objectID":"/xian-xing-mo-xing/:0:3","tags":null,"title":"线性模型","uri":"/xian-xing-mo-xing/"},{"categories":null,"content":"训练循环 使用梯度下降法 学习率 = 0.5 迭代次数 10000 def train(epoch=100,n = 2, learning_rate = 0.5, detial = True): X, label = load_data() W = initialization(n) losses = [] W_list = [] for i in range(0,epoch): Y = forward_propagation(W,X) l = loss(label, Y) dw = back_propagation(X,Y,label) losses.append(float(l)) W += learning_rate * dw if i % 100 == 0: W_list.append(copy.deepcopy(W)) if i % 1000 == 0 and detial ==True: print(\"This is {}th epoch , loss = {}\".format(i, l)) return W_list, losses def draw(W): W = W[0] x = np.linspace(0.2,0.8,100) y = -(W[0] * x + W[2])/W[1] plt.plot(x,y) for plot in data: if plot[2] == 0: c = 'red' else: c = 'green' plt.scatter(plot[0],plot[1],c=c) def show(W_list): for W in W_list: plt.clf() display.clear_output(wait=True) draw(W) plt.pause(0.001) W_list,losses = train(epoch=10000,n=2,learning_rate=.01,detial=False) show(W_list[:100]) plt.plot(losses) [\u003cmatplotlib.lines.Line2D at 0x7f1b3a14aa50\u003e] ","date":"2023-01-03","objectID":"/xian-xing-mo-xing/:0:4","tags":null,"title":"线性模型","uri":"/xian-xing-mo-xing/"},{"categories":null,"content":"c++ 反射实现起来好像很麻烦，所以就干脆学习和借鉴已有的方案CPP-Reflection-code ","date":"2023-01-03","objectID":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/:0:0","tags":null,"title":"[挖坑] 反射和脚本系统","uri":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/"},{"categories":null,"content":"环境搭建 安装 LLVM windows 下直接下载 .exe 版本安装即可 LLVM 安装 Boost 下载 \u0026\u0026 解压 压缩包 Boost 打开 x64 Native Tools Command Prompt for VS2022 切换到解压目录 \u0026\u0026 运行 bootstrap.bat 按输出提示 操作 将 LLVM-ROOT 和 BOOST-ROOT 添加到环境变量 \u0026\u0026 重启生效 按照 README 编译创建 vs 项目(vs2022 生成器参数\"Visual Studio 17 2022\") 并且编译 打开 Examples 项目，选择一个测试项目作为启动项，并且运行测试！ tips 1:更换CPP-REFLECTION 项目的中 json11.cpp 和 json11.hpp json11， 不明白有代码有bug为什么能跑起来？ tips2:使用 Runtime 需要将 Source\\Runtime\\Common 和 Source\\Common\\Lib 目录添加到附加包含目录, 需要添加到 Runtime 的引用 ","date":"2023-01-03","objectID":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/:1:0","tags":null,"title":"[挖坑] 反射和脚本系统","uri":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/"},{"categories":null,"content":"CPP-REFLECTION 目录结构 ","date":"2023-01-03","objectID":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/:2:0","tags":null,"title":"[挖坑] 反射和脚本系统","uri":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/"},{"categories":null,"content":"Parser 各种语言元素类型（类，构造函数，枚举，External？，字段Field，函数，Global，Invokeable， Method），这是用于 解释AST节点 和 构造代码渲染数据 类型。 模块 Module（是一个代码集合，其中包含 classes ， globals， globalfuncs，enums 一个词法分析器？意义不明 lang-c前端语法树模型 CursorType AST语法节点类型（例如 定义 声明 表达式 等 MetaDataConfig 配置文件 MetaDataManager 类型 用于 GetProperty GetFlag GetNativeString MetaUtils 工具类，处理字符串等C++不好处理的内特容 NameSpace 列表 用于处理嵌套名字空间 预编译 -\u003e include 列表 ReflectionOptions 反射参数 ReflectionParser 用于分析代码 提取需要反射的类，最后渲染反射代码 渲染模板路径 常量 ","date":"2023-01-03","objectID":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/:2:1","tags":null,"title":"[挖坑] 反射和脚本系统","uri":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/"},{"categories":null,"content":"Runtime Todo ","date":"2023-01-03","objectID":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/:2:2","tags":null,"title":"[挖坑] 反射和脚本系统","uri":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/"},{"categories":null,"content":"使用方法 自定义属性 enum class SliderType { Horizontal, Vertical } Meta(Enable); struct Slider : ursine::meta::MetaProperty { META_OBJECT; SliderType type; Slider(SliderType type) : type(type) { } } Meta(Enable); struct Range : ursine::meta::MetaProperty { META_OBJECT; float min, max; Range(float min, float max) : min(min) , max(max) { } } Meta(Enable); 自定义被反射类 #pragma once #include \u003cMeta.h\u003e #include \"TestProperties.h\" #include \u003cstring\u003e #include \u003cvector\u003e #include \u003cArray.h\u003e enum TestEnum { One, Two, Three, Four, Five, Eighty = 80 } Meta(Enable); struct SoundEffect { Meta(Range(0.0f, 100.0f), Slider(SliderType::Horizontal)) float volume; void Load(const std::string \u0026filename) { std::cout \u003c\u003c \"Loaded sound effect \\\"\" \u003c\u003c filename \u003c\u003c \"\\\".\" \u003c\u003c std::endl; } } Meta(Enable); struct ComplexType { std::string stringValue; int intValue; float floatValue; double doubleValue; SoundEffect soundEffect; ursine::Array\u003cint\u003e arrayValue; TestEnum enumValue; ComplexType(void) = default; } Meta(Enable); 调用方法 #include \"TestReflectionModule.h\" #include \"TestTypes.h\" #include \"TestProperties.h\" #include \"TypeCreator.h\" using namespace ursine::meta; int main(void) { MetaInitialize( UsingModule( TestModule ) ); Type soundEffectType = typeof( SoundEffect ); Field volumeField = soundEffectType.GetField( \"volume\" ); // the runtime supports overloading, but by default returns the first overload Method loadMethod = soundEffectType.GetMethod( \"Load\" ); // creates an instance of a sound effect Variant effect = TypeCreator::Create( soundEffectType ); // effect.volume is now 85 volumeField.SetValue( effect, 85.0f ); // 85 -- can also use GetValue\u003cfloat\u003e( ) float volumeValue = volumeField.GetValue( effect ).ToFloat( ); std::cout \u003c\u003c \"SoundEffect.volume: \" \u003c\u003c volumeValue \u003c\u003c std::endl; // effect.Load is called loadMethod.Invoke( effect, std::string { \"Explosion.wav\" } ); return 0; } ","date":"2023-01-03","objectID":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/:2:3","tags":null,"title":"[挖坑] 反射和脚本系统","uri":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/"},{"categories":null,"content":"Reference CPP-Reflection-code CPP-Reflection-doc ","date":"2023-01-03","objectID":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/:3:0","tags":null,"title":"[挖坑] 反射和脚本系统","uri":"/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/"},{"categories":null,"content":"svm.html 线性核SVM 和 高斯核SVM SMO 算法解析 最优化目标 $$\\max_{\\alpha} =\\sum_{i=1}^{m}\\alpha_i - \\sum_{i=1}^{m} \\sum_{j=1}^{m}\\alpha_i\\alpha_jy_iy_jx_i^Tx_j \\tag{1}$$ $$\\text{ s.t. } \\qquad \\alpha_i \\ge 0,\\quad \\sum_{i=1}^{N}\\alpha_iy_i = 1 \\tag{2}$$ 约束条件 $$ $$ 算法原理 我们可以先确定 两个$\\alpha_i,\\alpha_j$. 在例子中设$i=1 , \\quad j=2$. 此时最大化目标： $$arg\\max_{\\alpha_1, \\alpha_2}W(\\alpha_1, \\alpha_2) = \\alpha_1 + \\alpha_2 - \\frac{1}{2}K_{1,1}y_1^2\\alpha_1^2 - \\frac{1}{2}K_{2,2}y_2^2\\alpha_2^2 - K_{1,2}y_1y_2\\alpha_1\\alpha_2 - y_1\\alpha_1\\sum_{i=3}^{m}\\alpha_iy_iK_{i,1} - y_2\\alpha_2\\sum_{i=3}^{m}\\alpha_iy_iK_{i,2} + C \\tag{3}$$ 根据(2) $$\\alpha_1y_1 + \\alpha_2y_2 = -\\sum_{i=3}^{N}\\alpha_iy_i = \\eta$$ 两边同时乘以$y_1,由于y_i^2 = 1$ $$\\alpha_1 = \\eta y_1 - \\alpha_2y_1y_2 \\tag{4}$$ 令： $$v_1 = \\sum^{N}{i=3}\\alpha_iy_iK{i,1}, \\quad v_2 = \\sum^{N}{i=3}\\alpha_iy_iK{i,2} \\tag{5}$$ 将 (4), (5) 带入(3) $$ W(\\alpha_2) = - \\frac{1}{2}K_{1,1}(\\eta - \\alpha_2y_2)^2 - \\frac{1}{2}K_{2,2}\\alpha_2^2 - K_{1,2}y_2\\alpha_2(\\eta - \\alpha_2y_2) - v_1(\\eta - \\alpha_2y_2) - v_2y_2\\alpha_2 + \\alpha_1 + \\alpha_2 + C \\tag{6}$$ 由于需要更新$\\alpha_2$所以令$\\frac{dW}{d\\alpha} = 0$ $$\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -\\alpha_2(K_{1,1} + K_{2,2} - 2K_{1,2}) + K_{1,1}\\eta y_2 - K_{1,2}\\eta y_2 + v_1y_2 - v_2y_2 - y_1y_2 + y_2^2 = 0 \\tag{7}$$ 对(7)式变形，使得$\\alpha_2^new$能被$\\alpha_2^old$表示(而不是用不方便的\\eta)： SVM预测值如下(该式子不需要保留所有的x，因为很多无关的x的alpha都为0，因此alpha需要初始化为0)： $$f(x) = \\sum_{i=1}^{N}\\alpha_iy_iK(x_i,x) + b \\tag{8}$$ 则v可以表示为： $$ v_1 = \\sum^{N}{i=3}\\alpha_iy_iK{1,i} = f(x_1) - \\alpha_1y_1K_{1,1} - \\alpha_2y_2K_{1,2} - b $$ $$v_2 = \\sum^{N}{i=3}\\alpha_iy_iK{2,i} = f(x_2) - \\alpha_1y_1K_{1,2} - \\alpha_2y_2K_{2,2} - b $$ 已知： $$\\alpha_1= (\\eta - \\alpha_2y_2)y_2$$ 可得到： $$v_1 - v_2 = f(x_1) - f(x_2) - K_{1,1}\\eta + K_{1,2}\\eta + \\alpha_2y_2(K_{1,1}+K_{2,2}-2K_{1,2}) \\tag{9}$$ 将(9)带入(7): $$\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -(K_{1,1} + K_{2,2} - 2K_{1,2})\\alpha_2^{new} + (K_{1,1} + K_{2,2}- 2K_{1,2})\\alpha_2^{old} + y_2(y_2 - y_1 + f(x_1) - f(x_2))$$ 记误差项$E_i = f(x_i) - y_i$ 令$\\theta = K_{1,1,}+K_{2,2}-2K_{1,2}$ 可以得到最终表达式： $$\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -\\theta\\alpha_2^{new}+ \\theta\\alpha_2^{old}+y2(E_1-E_2) = 0$$ 得到： $$\\alpha_2^{new} = \\alpha_2^{old} + \\frac{y_2(E_1- E_2)}{\\theta} \\tag{10}$$ 到了这里，如果要更新参数，仅需计算E，和\\theta 然后计算\\alpha2 原始解的修剪 现在考虑约束条件 上面通过对一元函数求极值的方式更新了参数得到了$\\alpha_2^{new,unclipped}$ 现在通过对原始解的修正得到$\\alpha_2^{new,cilpped}$ $$\\alpha_2^{new,unclipped} = \\alpha_2^{old} + \\frac{y_2(E_1- E_2)}{\\theta} \\tag{10}$$ 约束条件（画图分析）： $if \\quad y_1 \\ne y_2 :$ $$ 上界：\\qquad L = max(0, \\quad \\alpha_2^{old} - \\alpha_1^{old})$$ $$ 下界：\\qquad H = max(C, \\quad C+\\alpha_2^{old} - \\alpha_1^{old})$$ $elif \\quad y_1 = y_2 :$ $$ 上界：\\qquad L = max(0, \\quad \\alpha_2^{old} + \\alpha_1^{old} -C)$$ $$ 下界：\\qquad H = max(C, \\quad \\alpha_2^{old} + \\alpha_1^{old})$$ 更新参数都可以计算：$\\alpha_1^{new}$ 由： $$\\alpha_1^{old}y_1 + \\alpha_2^{old}y_2 = \\alpha_1^{new}y_1 + \\alpha_2^{new}y_2 $$ 得到： $$\\alpha_1^{new} = \\alpha_1^{old} + y_1y_2(\\alpha_2^{old} - \\alpha_2^{new})$$ 最后由式(6.17)-\u003e(6.18)可得到： $$b = \\frac{1}{m}\\sum_{s=1}^{m}[1/y_s - \\sum_{m}^{i=1}\\alpha_iy_ix_i^Tx_s]$$ 3.启发式选择变量 上述分析是在从N个变量中已经选出两个变量进行优化的方法，下面分析如何高效地选择两个变量进行优化，使得目标函数下降的最快。 第一个变量的选择 第一个变量的选择称为外循环，首先遍历整个样本集，选择违反KKT条件的$\\alpha_i$作为第一个变量 接着依据相关规则选择第二个变量(见下面分析),对这两个变量采用上述方法进行优化。 当遍历完整个样本集后，遍历非边界样本$(0\u003cα_i\u003cC)$中违反KKT的$\\alpha_i$作为第一个变量，同样依据相关规则选择第二个变量，对此两个变量进行优化。当遍历完非边界样本集后，再次回到遍历整个样本集中寻找，即在整个样本集与非边界样本集上来回切换，寻找违反KKT条件的αiαi作为第一个变量。直到遍历整个样本集后，没有违反KKT条件$\\alpha_i$，然后退出。 边界上的样本对应的$\\alpha_i = 0$或者$\\alpha_i = C$，在优化过程中很难变化，然而非边界样本$0\u003cα_i\u003cC$会随着对其他变量的优化会有大的变化。 KTT条件 $$\\alpha_i = 0 \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b)\\ge1 $$ $$\\alpha_i = C \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b)\\le 1 $$ $$0 \\lt \\alpha_i \\lt C \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b) =1 $$ 第二个变量的选择 SMO称第二个变量的选择过程为内循环，假设在外循环中找个第一个变量记为$\\alpha_1$，第二个变量的选择希望能使$\\alpha_2$有较大的变化，由于$\\alpha_2$是依赖于$|E1−E2|$,当$E1$为正时，那么选择最小的$Ei$作为$E2$,如果$E1$为负，选择最大$Ei$作为$E2$，通常为每个样本的$Ei$保存在一个列表中，选择最大的$|E1−E2|$来近似最大化步长。 有时按照上述的启发式选择第","date":"2023-01-03","objectID":"/svm/:0:0","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"定义训练集 $$X_{train} \\in \\R^{n \\times m}$$ $$x_i \\in \\R^n,即每一个样本有n个特征$$ $$label \\in {-1,1},二分类问题$$ ","date":"2023-01-03","objectID":"/svm/:0:1","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"多种核函数 def LinearKernel(x_i, x_j): if x_i.shape[1] != 1: raise Exception(\"x_i is wrong shape!\") if x_j.shape[1] != 1: raise Exception(\"x_j is wrong shape!\") return np.dot(x_i.T, x_j) def GaussKernel(x_i, x_j, sigmoid): if x_i.shape[1] != 1: raise Exception(\"x_i is wrong shape!\") if x_j.shape[1] != 1: raise Exception(\"x_j is wrong shape!\") if sigmoid \u003c= 0: raise Exception(\"sigmoid must be a positive number\") return np.exp(-np.dot((x_i - x_j).T, (x_i - x_j))/(2 * sigmoid**2)) def PolyKernel(x_i, x_j, d): if x_i.shape[1] != 1: raise Exception(\"x_i is wrong shape!\") if x_j.shape[1] != 1: raise Exception(\"x_j is wrong shape!\") if d \u003c 0: raise Exception(\"d must be a Semi-positive number\") return LinearKernel(x_i, x_j)**d def LaplaceKernel(x_i, x_j, s): if x_i.shape[1] != 1: raise Exception(\"x_i is wrong shape!\") if x_j.shape[1] != 1: raise Exception(\"x_j is wrong shape!\") if s \u003c= 0: raise Exception(\"sigmoid must be a positive number\") # print(np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / sigmoid)) return np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / s)[0][0] def SigmoidKernel(x_i, x_j, beta, theta): if x_i.shape[1] != 1: raise Exception(\"x_i is wrong shape!\") if x_j.shape[1] != 1: raise Exception(\"x_j is wrong shape!\") if theta \u003e= 0: raise Exception(\"theta must be a negetive number\") if beta \u003c= 0: raise Exception(\"theta must be a positive number\") return np.tanh(beta * LinearKernel(x_i, x_j) + theta) def K(x_i, x_j, kernel = \"linear\", s = .5, beta = 1, theta = -1, d = 2): # print(x_i.shape, x_j.shape) kernel = kernel.lower() try: if kernel == 'linear': return LinearKernel(x_i, x_j) elif kernel == 'gauss': return GaussKernel(x_i, x_j, s) elif kernel == 'poly': return PolyKernel(x_i, x_j, d) elif kernel == 'laplace': return LaplaceKernel(x_i, x_j, s) elif kernel == 'sigmoid': return SigmoidKernel(x_i, x_j, beta, theta) except Exception as err: print('An exception happened: ' + str(err)) if __name__ == \"__main__\": x_i = np.ones((10,1)) x_j = np.random.randn(10,1) print(np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / 1)) print(K(x_i,x_j,kernel=\"Laplace\", s=1)) [[0.005973]] 0.005973003723489288 ","date":"2023-01-03","objectID":"/svm/:1:0","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"生成同心圆数据 import numpy as np def load(type = \"circle\"): x = np.random.uniform(-1,1,(100,1)) y = np.random.uniform(-1,1,(100,1)) x_train = np.c_[x,y].T print(x_train.shape) label_train = np.ones((100,1)) mask = (x**2 + y**2 ) \u003c .5 label_train[mask] = -1 x1 = np.random.uniform(-1,1,(100,1)) y1 = np.random.uniform(-1,1,(100,1)) x_test = np.c_[x1,y1].T print(x_test.shape) label_test = np.ones((100,1)) mask = (x1**2 + y1**2 ) \u003c .5 label_test[mask] = -1 return x_train, label_train, x_test, label_test if __name__ == \"__main__\": x_train, label_train, x_test, label_test = load() print(x_train.shape, label_train.shape, x_test.shape, label_test.shape) (2, 100) (2, 100) (2, 100) (100, 1) (2, 100) (100, 1) ","date":"2023-01-03","objectID":"/svm/:1:1","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"参照第一个SMO推导笔记需要实现以下功能： 初始化参数（主要是\\alpha） 由于采用缓存（用一个列表记录）所有的$E_i = y_i - f(x_i)$ 所以每一次更新参数$\\alpha$后都需要更新$E_i, E_j$ 因为由KKT条件约束，所以需要对最后的结果进行修剪 所以需要实现 clip() $f(index_i)用于实现对训练集的某一个特征向量计算预测值$ $predict(x_i)用于预测任意给定的特征向量x_i$ select()函数的内循环和外循环用于选择最不满足KKT条件的并且能够使得更新效果最明显的$\\alpha_i \\quad \\alpha_j$ loss()用于计算E update_a2()用于更新$\\alpha_2$ update_a1()使用$\\alpha_2$和$\\alpha_1^{old}$更新$\\alpha_1$ SMO()是smo算法的主循环 以上函数与SMO算法紧密相关，为了方便参数，数据集，的传输将他们放到一个SMO类中实现 class SMO: def __init__(self, x, y, kernel = \"Laplace\", C=10): self.x = copy.deepcopy(x) self.y = copy.deepcopy(y) self.m = x.shape[1] self.n = x.shape[0] self.kernel = kernel self.C = C def init(self): # self.w = np.random.randn(self.n, 1) self.b = np.zeros((1, 1)) self.a = np.zeros((self.m, 1)) E = [] for i in range(0, self.m): E.append(self.loss(i)) self.E = E # 每次更新参数后需要更新E def updateE(self, i, j): self.E[i] = self.loss(i) self.E[j] = self.loss(j) def clip(self, index_1, index_2, old_1, old_2): # get H, L alpha = self.a[index_2,:][0] if self.y[index_1, :] != self.y[index_2, :]: L = max(0.0, old_2[0] - old_1[0]) H = max(self.C, self.C + old_2[0] - old_1[0]) else: # print(\"----------\" , self.C, old_2[0], self.C + old_2[0],'-------------') L = max(0.0, old_2[0] + old_1[0] - self.C) H = max(self.C, old_2[0] + old_1[0]) if alpha \u003c L: return L elif alpha \u003e H: return H else: return alpha def f(self, x_index): k = np.zeros(self.y.shape) for i in range(0, self.m): k[i,:] = copy.deepcopy(K(self.x[:,i].reshape(-1,1), self.x[:,x_index].reshape(-1,1), kernel = self.kernel)) return np.sum(self.a * self.y * k)+self.b # 此处是选择第二个变量，第一个变量仅需要无脑便利就好了 # 需要传入第一个变量的index以计算E_1 # 是否可以将select写成一个生成器？ def select(self): for i in range(0, self.m): # label用于标志是否违反KKT label = False temp = self.y[i, :] * self.f(i) if self.a[i, :] == 0: if temp \u003c 1 : label = True elif 0 \u003c self.a[i, :] and self.a[i, :] \u003c self.C: if temp \u003e 1: label = True else: if temp != 1: label = True # 如果违反KKT条件，进入内循环选择第二个a if label == True and self.E[i] \u003c= 0: j = np.argmax(np.array(self.E)) yield i,j if label == True and self.E[i] \u003e0: j = np.argmin(np.array(self.E)) yield i,j # 需要得到边界变量的下标值 boolen = (self.a \u003e 0) \u0026 (self.a \u003c self.C) edgeVar = [] for i in range(0, len(boolen)): if boolen[i] == True: edgeVar.append(i) for i in edgeVar: # label用于标志是否违反KKT label = False temp = self.y[i, :] * self.f(i) if self.a[i, :] == 0: if temp \u003c 1 : label = True elif 0 \u003c self.a[i, :] and self.a[i, :] \u003c self.C: if temp \u003e 1: label = True else: if temp != 1: label = True # 如果违反KKT条件，进入内循环选择第二个a if label == True and self.E[i] \u003c= 0: j = np.argmax(np.array(self.E)) yield i,j if label == True and self.E[i] \u003e0: j = np.argmin(np.array(self.E)) yield i,j # E_i = f(x_i) - y_i def loss(self, index): return self.f(index) - self.y[index, :] def update_a2(self, alpha2_old, index_1, index_2): theta = K(self.x[:,index_1].reshape(-1,1), self.x[:,index_1].reshape(-1,1), kernel = self.kernel) + K(self.x[:,index_2].reshape(-1,1), self.x[:,index_2].reshape(-1,1), kernel = self.kernel) - 2*K(self.x[:,index_1].reshape(-1,1), self.x[:,index_2].reshape(-1,1), kernel = self.kernel) if theta \u003c 0.001 and theta \u003e= 0: theta = 0.001 if theta \u003e -0.001 and theta \u003c0: theta = 0.001 dE = self.E[index_1] - self.E[index_2] # print(\"in update_a2 theta:{}, dE:{}, y2:{}\".format(theta, dE, self.y[index_2])) return alpha2_old + (self.y[index_2] * dE) / theta def update_a1(self, alpha1_old, alpha2_old, alpha2_new, index_1, index_2): return alpha1_old + self.y[index_1] * self.y[index_2] * (alpha2_old - alpha2_new) def SMO(self, maxtimes): for i in range(0, maxtimes): if i % 10 == 0: print(\"this is {}th loop.\".format(i)) for i, j in self.select(): temp = copy.deepcopy(self.a[j]) self.a[j] = self.update_a2(self.a[j], i, j) self.a[j] = self.clip(i, j, self.a[i], temp) self.a[i] = self.update_a1(self.a[i], temp, self.a[j], i, j) self.updateE(i, j) # 更新b self.b = np.sum(1/self.y)/self.m for i in range(0, self.m): self.b -= (self.f(i)/self.m) print(self.b) def predict(self, x): k = np.zeros(self.y.shape) for i in range(0,","date":"2023-01-03","objectID":"/svm/:1:2","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"导入数据 此处生成同心圆数据，以区别线性核和非线性核之间的区别 x_train, y_train, x_test, y_test = load() # plt.scatter(x_train[0, :], x_train[1, :], c = y_train[:, 0]) (2, 100) (2, 100) ","date":"2023-01-03","objectID":"/svm/:1:3","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"使用高斯核的SVM 此处$\\sigma = 0.5$,取值为1时，准确率就很低了，不知道怎么回事（先补一下核函数更多的技术了， 狗头.jpg） smo = SMO(x_train, y_train, C = 2, kernel = \"gauss\") smo.init() smo.SMO(110) y_pred = smo.predictAll(x_test) evaluate(y_test, y_pred) draw_svm(smo) this is 0th loop. this is 10th loop. this is 20th loop. this is 30th loop. this is 40th loop. this is 50th loop. this is 60th loop. this is 70th loop. this is 80th loop. this is 90th loop. this is 100th loop. 1.0542578147143928 The roc_auc_score is 0.982048143614851 The accuracy is 0.89 precision recall f1-score support class0 0.80 1.00 0.89 43 class1 1.00 0.81 0.89 57 accuracy 0.89 100 macro avg 0.90 0.90 0.89 100 weighted avg 0.91 0.89 0.89 100 ","date":"2023-01-03","objectID":"/svm/:1:4","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"使用线性核的SVM smo = SMO(x_train, y_train, C = 2, kernel = \"linear\") smo.init() smo.SMO(110) y_pred = smo.predictAll(x_test) evaluate(y_test, y_pred) draw_svm(smo) this is 0th loop. this is 10th loop. this is 20th loop. this is 30th loop. this is 40th loop. this is 50th loop. this is 60th loop. this is 70th loop. this is 80th loop. this is 90th loop. this is 100th loop. 0.27041462716608683 The roc_auc_score is 0.4618523051815585 The accuracy is 0.48 precision recall f1-score support class0 0.41 0.49 0.45 43 class1 0.55 0.47 0.51 57 accuracy 0.48 100 macro avg 0.48 0.48 0.48 100 weighted avg 0.49 0.48 0.48 100 ","date":"2023-01-03","objectID":"/svm/:1:5","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"调用之前写过的决策树C4.5 from dt import buildTree, Node, predictAll, predict, draw_tree import pandas as pd X_train = np.r_[x_train, y_train.T] X_train = pd.DataFrame(X_train.T, columns=[\"x\",'y',\"label\"]) X_test = np.r_[x_test, y_test.T] X_test = pd.DataFrame(X_test.T, columns=[\"x\",'y',\"label\"]) Y_test = np.array(list(X_test[\"label\"])).reshape(-1,1) root = Node(Dataset=X_train, attrList = ['x','y']) root = buildTree(root) Y_pred = predictAll(root ,X_test) evaluate(Y_test, Y_pred) draw_tree(root) plt.scatter(X_train[\"x\"], X_train[\"y\"], c = 0 - X_train[\"label\"]) The roc_auc_score is 0.7105263157894737 The accuracy is 0.67 precision recall f1-score support class0 0.57 1.00 0.72 43 class1 1.00 0.42 0.59 57 accuracy 0.67 100 macro avg 0.78 0.71 0.66 100 weighted avg 0.81 0.67 0.65 100 \u003cmatplotlib.collections.PathCollection at 0x7f523e323310\u003e ","date":"2023-01-03","objectID":"/svm/:1:6","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"分析 对于同心圆这种线性不可分的数据，使用linear kernel只能得到约50/100的准确度 使用决策树，这里由于决策变量只有x，y所以，这里的决策树虽多两层，对于特征向量较小的数据集不友好 使用拉普拉斯核（测试时用的拉普拉斯核，准确率略高于高斯核） 或者 高斯核在该种线性不可分的数据集中起到了很好的升维作用 使用神经网络可以得到很好的效果（在神经网络实现的时候，测试过该数据集，随着层数的增加，能达到99/100的准确率） import tensorflow==2.0.0 Cannot run import tensorflow because of system compatibility. AI Studio prepared an entire environment based on PaddlePaddle already. Please use PaddlePaddle to build your own model or application. ","date":"2023-01-03","objectID":"/svm/:1:7","tags":null,"title":"支持向量机","uri":"/svm/"},{"categories":null,"content":"参考列表 Wialliam Fiset’s Algorithms Keon’s Algorithms Xtaci’s Algorithms Labuladong’s Fucking-Algorithms Geekxh’s Hello-Algorithms Algorithm-Visualizer Justjavac’s Free-Programming-Books Imarvinle’s Awesome-CS-Books Jeffe’s Algorithms Course 主要关注其中 操作系统、算法、图形学、设计模式、游戏引擎、C#、 C/C++ 、编译器中间语言、元编程 Jeffe’s Crouse 用于学习，Wialliam Fiset’s Algorithms, Keon’s Algorithms, Xtaci’s Algorithms 用于拓展补充，labuladong 的算法小抄, 小浩算法 用于练习 这是一个利用空闲时间学习的长期计划，或许需要几年时间，学不完没关系，学一点赚一点，加油！ ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:0:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"数据结构 Balance Trees AVL Tree (recursive) Red Black Tree (recursive) Binary Search Tree Splay Tree Dynamic Array Dynamic Array (integer only, fast) Fenwick Tree Fenwick Tree (range query, point update) (range update, point query) Fibonacci Heap Hashtable Hashtable (double hashing) Hashtable (linear probing) Hashtable (quadratic probing) Hashtable (sparate chaning) Linked List Priority Queue Min Binary Heap Min Indexed Binary Heap (sorted key-value pairs, similar to hash-table) Min D-Heap Min Indexed D-Heap (sorted key-value pairs, similar to hash table) Queue Queue (integer only, fixed size, fast) Queue (linked list, generic) Segment Tree Segement Tree (array based, compact) Segment Tree (linked list generic) Sparse Table Stack Stack (integer only, fixed size, fast) Stack (linked list, generic) Stack (array, generic) Suffix Array Suffix Array (O(n^2logn)) Suffix Array (O(nlog^2(n)) Suffix Array (O(nlogn)) Trie Union Find ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:1:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"数组 Array shuffle 2D Array ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:2:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"动态编程 Coin change problem Edit distance (iterative) Edit distance (recursive) Knapsack 0/1 Knapsack unbounded (0/inf) Maximum contiguous subarray Longest Common Subsequence (LCS) Longest Increasing Subsequence (LIS) Longest Palindrome Subsequence (LPS) Traveling Salesman Problem (dynamic programming, iterative) Traveling Salesman Problem (dynamic programming, recursive) Minimum Weight Perfect Matching (iterative, complete graph) Examples: ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:3:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"Adhoc Magic Cows Narrow Art Gallery ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:3:1","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"Tiling problems Tiling Dominoes Tiling Dominoes and Trominoes Mountain Scenes ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:3:2","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"计算几何 Angle between 2D vectors - O(1) Angle between 3D vectors - O(1) Circle-circle intersection point(s) - O(1) Circle-line intersection point(s) - O(1) Circle-line segment intersection point(s) - O(1) Circle-point tangent line(s) - O(1) Closest pair of points (line sweeping algorithm) - O(nlog(n)) Collinear points test (are three 2D points on the same line) - O(1) Convex hull (Graham Scan algorithm) - O(nlog(n)) Convex hull (Monotone chain algorithm) - O(nlog(n)) Convex polygon area - O(n) Convex polygon cut - O(n) Convex polygon contains points - O(log(n)) Coplanar points test (are four 3D points on the same plane) - O(1) Line class (handy infinite line class) - O(1) Line-circle intersection point(s) - O(1) Line segment-circle intersection point(s) - O(1) Line segment to general form (ax + by = c) - O(1) Line segment-line segment intersection - O(1) Longitude-Latitude geographic distance - O(1) Point is inside triangle check - O(1) Point rotation about point - O(1) Triangle area algorithms - O(1) [UNTESTED] Circle-circle intersection area - O(1) [UNTESTED] Circular segment area - O(1) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:4:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"图论 Tree algorithms 🎥 Rooting an undirected tree - O(V+E) 🎥 Identifying isomorphic trees - O(?) 🎥 Tree center(s) - O(V+E) Tree diameter - O(V+E) 🎥 Lowest Common Ancestor (LCA, Euler tour) - O(1) queries, O(nlogn) preprocessing Network flow Bipartite graph verification (adjacency list) - O(V+E) 🎥 Max flow \u0026 Min cut (Ford-Fulkerson with DFS, adjacency list) - O(fE) Max flow \u0026 Min cut (Ford-Fulkerson with DFS, adjacency matrix) - O(fV2) 🎥 Max flow \u0026 Min cut (Edmonds-Karp, adjacency list) - O(VE2) 🎥 Max flow \u0026 Min cut (Capacity scaling, adjacency list) - O(E2log2(U)) 🎥 Max flow \u0026 Min cut (Dinic’s, adjacency list) - O(EV2) or O(E√V) for bipartite graphs Maximum Cardinality Bipartite Matching (augmenting path algorithm, adjacency list) - O(VE) Min Cost Max Flow (Bellman-Ford, adjacency list) - O(E2V2) Min Cost Max Flow (Johnson’s algorithm, adjacency list) - O(E2Vlog(V)) Main graph theory algorithms Articulation points/cut vertices (adjacency list) - O(V+E) Bellman-Ford (edge list, negative cycles, fast \u0026 optimized) - O(VE) 🎥 Bellman-Ford (adjacency list, negative cycles) - O(VE) Bellman-Ford (adjacency matrix, negative cycles) - O(V3) 🎥 Breadth first search (adjacency list) - O(V+E) Breadth first search (adjacency list, fast queue) - O(V+E) Bridges/cut edges (adjacency list) - O(V+E) Find connected components (adjacency list, union find) - O(Elog(E)) Find connected components (adjacency list, DFS) - O(V+E) Depth first search (adjacency list, iterative) - O(V+E) Depth first search (adjacency list, iterative, fast stack) - O(V+E) 🎥 Depth first search (adjacency list, recursive) - O(V+E) 🎥 Dijkstra’s shortest path (adjacency list, lazy implementation) - O(Elog(V)) 🎥 Dijkstra’s shortest path (adjacency list, eager implementation + D-ary heap) - O(ElogE/V(V)) 🎥 Eulerian Path (directed edges) - O(E+V) 🎥 Floyd Warshall algorithm (adjacency matrix, negative cycle check) - O(V3) Graph diameter (adjacency list) - O(VE) 🎥 Kahn’s algorithm (topological sort, adjacency list) - O(E+V) Kruskal’s min spanning tree algorithm (edge list, union find) - O(Elog(E)) 🎥 Kruskal’s min spanning tree algorithm (edge list, union find, lazy sorting) - O(Elog(E)) Kosaraju’s strongly connected components algorithm (adjacency list) - O(V+E) 🎥 Prim’s min spanning tree algorithm (lazy version, adjacency list) - O(Elog(E)) Prim’s min spanning tree algorithm (lazy version, adjacency matrix) - O(V2) 🎥 Prim’s min spanning tree algorithm (eager version, adjacency list) - O(Elog(V)) Steiner tree (minimum spanning tree generalization) - O(V3 + V2 _ 2T + V _ 3T) 🎥 Tarjan’s strongly connected components algorithm (adjacency list) - O(V+E) 🎥 Topological sort (acyclic graph, adjacency list) - O(V+E) Topological sort (acyclic graph, adjacency matrix) - O(V2) Traveling Salesman Problem (brute force) - O(n!) 🎥 Traveling Salesman Problem (dynamic programming, iterative) - O(n22n) Traveling Salesman Problem (dynamic programming, recursive) - O(n22n) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:5:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"线性代数 Freivald’s algorithm (matrix multiplication verification) - O(kn2) Gaussian elimination (solve system of linear equations) - O(cr2) Gaussian elimination (modular version, prime finite field) - O(cr2) Linear recurrence solver (finds nth term in a recurrence relation) - O(m3log(n)) Matrix determinant (Laplace/cofactor expansion) - O((n+2)!) Matrix inverse - O(n3) Matrix multiplication - O(n3) Matrix power - O(n3log(p)) Square matrix rotation - O(n2) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:6:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"数学 Arbitrary Integer [UNTESTED] Chinese remainder theorem Prime number sieve (sieve of Eratosthenes) - O(nlog(log(n))) Prime number sieve (sieve of Eratosthenes, compressed) - O(nlog(log(n))) Prime test(trial division) Prime test(Miller-Rabin’s method) Totient function (phi function, relatively prime number count) - O(n1/4) Totient function using sieve (phi function, relatively prime number count) - O(nlog(log(n))) Extended euclidean algorithm - ~O(log(a + b)) Greatest Common Divisor (GCD) - ~O(log(a + b)) Fast Fourier transform (quick polynomial multiplication) - O(nlog(n)) Fast Fourier transform (quick polynomial multiplication, complex numbers) - O(nlog(n)) Primality check - O(√n) Primality check (Rabin-Miller) - O(k) Least Common Multiple (LCM) - ~O(log(a + b)) Modular inverse - ~O(log(a + b)) Prime factorization (pollard rho) - O(n1/4) Relatively prime check (coprimality check) - ~O(log(a + b)) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:7:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"搜索算法 Binary search (real numbers) - O(log(n)) Interpolation search (discrete discrete) - O(n) or O(log(log(n))) with uniform input Ternary search (real numbers) - O(log(n)) Ternary search (discrete numbers) - O(log(n)) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:8:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"排序算法 Bubble sort - O(n2) Bucket sort - Θ(n + k) Counting sort - O(n + k) Heapsort - O(nlog(n)) Insertion sort - O(n2) Mergesort - O(nlog(n)) Quicksort (in-place, Hoare partitioning) - Θ(nlog(n)) Quicksort3 (Dutch National Flag algorithm) - Θ(nlog(n)) Selection sort - O(n2) Radix sort - O(n*w) ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:9:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"字符串算法 Booth’s algorithm (finds lexicographically smallest string rotation) - O(n) Knuth-Morris-Pratt algorithm (finds pattern matches in text) - O(n+m) Longest Common Prefix (LCP) array - O(nlog(n)) bounded by SA construction, otherwise O(n) 🎥 Longest Common Substring (LCS) - O(nlog(n)) bounded by SA construction, otherwise O(n) 🎥 Longest Repeated Substring (LRS) - O(nlog(n)) Manacher’s algorithm (finds all palindromes in text) - O(n) Rabin-Karp algorithm (finds pattern match positions in text) - O(n+m) Substring verification with suffix array - O(nlog(n)) SA construction and O(mlog(n)) per query ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:10:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"其他 Bit manipulations - O(1) List permutations - O(n!) 🎥 Power set (set of all subsets) - O(2n) Set combinations - O(n choose r) Set combinations with repetition - O((n+r-1) choose r) Sliding Window Minimum/Maximum - O(1) Square Root Decomposition - O(1) point updates, O(√n) range queries Unique set combinations - O(n choose r) Lazy Range Adder - O(1) range updates, O(n) to finalize all updates Linear congruential generator Maximum subarray problem Bit-Set Double linked list Skip list Dynamic order statistics Interval tree Prefix Tree(Trie) Suffix Tree B-Tree hash Hash by multiplication Hash table Universal hash function Perfect hash Java’s string hash FNV-1a string hash SimHash Bloom Filter 密码学 SHA-1 Message Digest Algorithm MD5 Base64 Push–Relabel algorithm Huffman Coding Word segementation A* algorithm K-Means Knuth–Morris–Pratt algorithm Disjoint-Set 8-Queen Problem ","date":"2023-01-03","objectID":"/suan-fa-xue-xi-lie-biao/:11:0","tags":null,"title":"算法学习列表","uri":"/suan-fa-xue-xi-lie-biao/"},{"categories":null,"content":"2022.9.1 你要记得那些大雨中为你撑伞☔的人 帮你挡住外来之物的人🧱 黑暗中默默抱紧你🫂的人 逗你笑的人🤡 陪你彻夜聊天🌃💌的人 坐车🚉来看望你的人 陪你哭过😿的人 在医院陪你🏥的人 总是以你为重💀的人 带着你四处游荡的人 说想念你的人💕 是这些人组成你生命中一点一滴的温暖 是这些温暖使你远离阴霾 是这些温暖使你成为善良🔆的人 ","date":"2023-01-03","objectID":"/record/:1:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.9.5 第一天， 开心每一天 ","date":"2023-01-03","objectID":"/record/:2:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.9.5 反驳对《孤勇者》无病呻吟的恶评：如果平凡是病， 那么大多数人没有无病呻吟 。如果孤独是病，那么所有人都在无病呻吟。 ","date":"2023-01-03","objectID":"/record/:3:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.9.6 听歌 《那女孩对我说》，“那女孩对我说，说我保护她的梦” ","date":"2023-01-03","objectID":"/record/:4:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.9.11 996 \u0026 资本 ","date":"2023-01-03","objectID":"/record/:5:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.9.28 《化身孤岛的蓝鲸》 我是只化身孤岛的蓝鲸 有着最巨大的身影 鱼虾在身侧穿行 也有飞鸟在背上停 我路过太多太美的奇景 如同伊甸般的仙境 而大海太平太静 多少故事无人倾听 我爱地中海的天晴 爱西伯利亚的雪景 爱万丈高空的鹰 爱肚皮下的藻荇 我在尽心尽力地多情 ","date":"2023-01-03","objectID":"/record/:6:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.10.1 我是不是废物啊，又懒又拖，没恒心没毅力，三心二意，啥都想试试，啥都干不成。我是个废物 ","date":"2023-01-03","objectID":"/record/:7:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.10.7 我之于我的意义是什么？ ","date":"2023-01-03","objectID":"/record/:8:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.10.19 “在信息时代，进入编程领域的壁垒完全不存在了。即使有也是自我强加的。如果你想着手去开发一些全新的东西，你不需要数百万美元的资本。你只需要足够的比萨和健怡可乐存在你的冰箱里，有一台便宜的PC用于工作，以及让你坚持下来的奉献精神。我们睡在地板上。我们跋山涉水。” —–约翰·卡马克 卡马克在计算机图形学(2D,3D,VR) 方面做出了很多突出贡献，他是一个黑客，一个梦想家，一个信念坚定的理想主义者，也是我的偶像💕💕💕💕！！ 卡马克的话让我想起了马克思的剩余价值理论，信息时代的理想主义者们，他们不是仅仅作为无产阶级被大公司剥削，他们也可以很容易的掌握互联网世界的生产资料，只要有毅力和奉献精神就可以为世界添砖加瓦。或许共产主义会首先在开源社区中局部的实现！（PS：但是开源社区没有解决分配问题，可能和马克思的共产主义不一样，但是如果仅仅局限于软件来说：生产资料足够廉价，以至于每个人都能拥有，劳动产物可以自由使用，在这个意义上是共产的） ","date":"2023-01-03","objectID":"/record/:9:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.10.19 初玩《旷野之息》主要在欣赏音乐和小鱼小动物，到处摘静谧公主，到处抓马，它带给我的是自由和孤独。和印象中的\"勇者大人\"的待遇完全不一样。好像我是否拯救世界，这个世界都不会因为我发生什么变化，我好像可以是拯救世界的勇者，也可以是平平无奇的普通人。这样种没有人依赖(塞尔达不算)的感觉既孤独又自由。 ","date":"2023-01-03","objectID":"/record/:10:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.10.25 听歌《没有理想的人不伤心》-新裤子 你曾热爱的那个人 这一生也不会再见面 你等在这文化的废墟上 已没人觉得你狂野 那些让人敬仰的神殿 只在无知的人心中灵验 我住在属于我的猪圈 这一夜无眠 我不要在失败孤独中死去 我不要一直活在地下里 物质的骗局 匆匆的蚂蚁 没有文化的人不伤心 我不要在失败孤独中死去 歌曲似乎讲述了这样一个故事：因为某个原因原本的生活遭到背叛（因为原曲中有一个最恨的人：推测是背叛）变得支离破碎，随之破灭的是我的热情和理想。我去了自己最爱的书店，这是他曾经与我一起去过的书店。在这里你陷入回忆，回忆起曾今的理想和努力，原来都被现实的金钱绑架。陷入物质的骗局，你的人生像地下的蚂蚁，碌碌，失败 且孤独。我愤怒于世人不懂我心中的热情，愤怒于这个世界不给理想主义者留下生存空间。但是我不甘心在失败孤独中死去，伤心伤心伤心。。。 ","date":"2023-01-03","objectID":"/record/:11:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.10.25 Free Software Foundation GNU 宣言 Emacs 一个自由软件编辑器 万圣节文档(一系列来源可靠的备忘录)，终于知道为什么这么多人不喜欢微软了 Eric S. Raymond五部曲 关于开源世界的一切 通过这些能了解开源软件诞生的起因和时代背景 ","date":"2023-01-03","objectID":"/record/:12:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"202210.26 “最后一个问题。罗素勋爵，假定这段录像将被我们的后人看到，如同死海古卷一般，在一千年后被人看见，你觉得有什么该对他们那一代人说的？有关您的一生？以及一生的感悟” “I should like to say two things, one intellectual and one moral. The intellectual thing I should want to say is this: When you are studying any matter, or considering any philosophy, ask yourself only what are the facts and what is the truth that the facts bear out. Never let yourself be diverted either by what you wish to believe, or by what you think would have beneficent social effects if it were believed. But look only, and solely, at what are the facts. That is the intellectual thing that I should wish to say. The moral thing I should wish to say…I should say love is wise, hatred is foolish. In this world which is getting more closely and closely interconnected we have to learn to tolerate each other, we have to learn to put up with the fact that some people say things that we don’t like. We can only live together in that way and if we are to live together and not die together we must learn a kind of charity and a kind of tolerance which is absolutely vital to the continuation of human life on this planet.” Bertrand Russell. ","date":"2023-01-03","objectID":"/record/:13:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.10.26 读剩余价值理论，马克思指出资本主义生产的目的是获得利润。为了尽可能高的利润率和尽可能多的利润，不同生产部门之间展开激烈竞争，大量资本必然从利润率低的部门转投到利润率高的部门，从而导致利润率的平均化。 这解释了我们为什么反对 996，为什么敌视支持 996的人，资本以更高的工资拉拢无产阶级工人，让他们自愿 996，短期和局部来看这些人获得了利益，但是长期和全面的看，这种现象会使996公司占据市场，提高了平均利润率，而那些希望 955 的工作者面对整个市场的996公司将别无选择。 这解释了个体的选择如何影响其他个体，资本如何破坏无产阶级联合的力量。 ","date":"2023-01-03","objectID":"/record/:14:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.1 警惕谎言， 如果真理存在，那么真理是最具说服力的。只有虚构和骗局才需要谎言来粉饰。只有理性和可重复的实验能作为证据，一切能称为理论的东西都必须有预测能力和可检验性(“可证伪的才是科学”)。 信仰，善良，公正，自由这些\"不科学\"的概念，往往是人造的，多元的，模糊的，容易控制思想的；这些概念本应该诞生于人的心灵和过往经历，而不是传教。所以不要轻易的接受意识形态输出。 ","date":"2023-01-03","objectID":"/record/:15:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.2 商品的价值被定义为社会必要劳动时间是有理可循的，它反映了康德哲学中关于公平的起点的概念，就是说人生而平等，是说在先天条件，家庭环境，社会选择附加到婴儿身上之前人类都是绝对平等的，我们要做的是尽力去弥补/缩短这些附加的不平等因素。 Tips:为什么我们要去抹平这些不平等呢？因为在无知的面纱之后，所有人都会变成不幸或幸运的人。如果幸运的概率是 50%，那么每一个幸运后边都潜藏着一个不幸，你的幸福只是有人在负重前行罢了。 对于生活在地球表面的人类来说，只有时间是绝对公平的。人生而不平等，所以用社会福利弥补不幸的人，用时间来衡量价值，这都是在尽力的使得社会公平。 如果忽略公平的起点，我们的寿命也是不平等的，那有什么办法能解决寿命的不平等呢？如果将寿命也看作是公平的起点的一部分，有什么办法能够补偿到这个不平等因素呢？（毕竟寿命不可预测）或许应该推进医疗保障？ 科技继续发展，我们克服寿命限制，在时间流速慢的地方生产，在时间流速快的地方生活，那时间这个尺度是否也失效了呢？所以马克思在这个地方的表述并不一定是社会必要劳动时间，同样可以替换为任何一种对所有人平等的事物？ ","date":"2023-01-03","objectID":"/record/:16:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.7 《窗子》 红叶落到床头，可不知缘由。 这是冬天还是秋天？在你的树冠和枝丫。 风已来过几次，咯吱咯吱。 这窗头不远也不近，是我的别有用心。 ","date":"2023-01-03","objectID":"/record/:17:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.11 电影《爱玛》里，当哈丽特问伍德豪斯小姐：“你为何不结婚呢？你如此天生丽质。” 伍德豪斯回答，自己没有结婚的想法，在情愫未到时，不必改变现状，等到深陷爱河时，想法自然会改变。 就像那句话：智者不入爱河，愚者自甘堕落，遇你难做智者，甘愿沦为愚者。 ","date":"2023-01-03","objectID":"/record/:18:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.11 《错误》 – 郑愁予 我打江南走过 那等在季节里的容颜如莲花的开落 东风不来，三月的柳絮不飞 你的心如小小的寂寞的城 恰若青石的街道向晚 跫音不响，三月的春帷不揭 你的心是小小的窗扉紧掩 我达达的马蹄是美丽的错误 我不是归人，是个过客。 这诗真美啊！ ","date":"2023-01-03","objectID":"/record/:19:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.12 唉，做自己不喜欢的事情真烦啊，放弃考研了，不搞了。mmp，安心学图形学和做游戏吧！ ","date":"2023-01-03","objectID":"/record/:20:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.22 玩游戏啊，不要听别人说好玩不好玩，感兴趣的都去试试，反正可以退款不是？ 2022 年剩下的游戏计划： BABA IS YOU 死亡细胞 武士:零 ","date":"2023-01-03","objectID":"/record/:21:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.22 《起风了》改编自日本歌手高桥优谱曲、作词并演唱的歌曲《ヤキモチ》 原版表达了一种干净的喜欢和爱恋，歌词有一种直击心灵的真实感， 非常动情。改编讲述了一个步履蹒跚的老人回到了故乡， 没有亲切而是近乡情怯。故乡的天空像以前那么温暖， 随着风吹起， 想起了往事…… 节选\r我终将青春还给了她 连同指尖弹出的盛夏 心之所动 就随风去了\r呜呜呜， 太好哭了。 ","date":"2023-01-03","objectID":"/record/:22:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.11.23 这个世界上究竟是苦难更多还是幸福更多呢？ 幸福软绵绵，苦难恶狠狠。幸福和苦难自然不能以时间的长短来比较，还有程度，这导致无法用数值衡量幸福和苦难的量。如果苦难更多，那为什么我们出生并且生活呢？ ","date":"2023-01-03","objectID":"/record/:23:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.12.6 最近有好多反共言论，他们有以下共同点： 他们不是在制度上做出批评并建议，而是攻击具体的人 例如 批评国家领导人的行为（例如作秀，但是他们忽略自己国家的领导人也在做同样的事情） 例如 阴阳怪气的说无脑支持共产党的人是小粉红。的确无脑的相信一种意识形态是不好的，但是单纯的指责没有引导只会令人更加困惑，如果你是知识分子就用去引导人思考，去做萤火，而不是在网上说怪话。 他们不说明事情全貌就评价政策/制度 例如 说全国人大投票全票通过是存在内幕，但是不会说人大之前会有政治协商会，会广泛听取各阶级的诉求，往往都是多方充分考虑诉求后的结果。 喜欢说 ‘若批评无自由，则赞美无意义’ 但是它们没有建设性的批评，往往都是攻击谩骂和阴阳怪气，同样的如果 赞美无自由，则批评无意义 西方发达国家有着根深蒂固的民主思想，他们希望所有的国家都实行同样的代议制民主，我们应该理解全世界人民希望自由平等的朴素愿望，但是各种政治制度都有缺点弊端，就像很多批评里说的 中国的政策权力太集中风险很大，但是这是站在西方权力分立角度下的的评价，它们只看到了我们的不好而没有看到因为权力分散导致的内耗（特指4年一度的选举大秀）。中国权力集中的原因是，中国中产党之所以是中国共产党，是因为希望践行共产主义理想，要实现这个理想就只能一党专政（因为我们能看到西式民主在一个大规模国家中会导致社会各阶层的分裂）。所以我们应该看到我们国家政治的风险，也应该看到西方民主的弊端。至于选择，当有了足够的经济实力就能做出选择（可以出国）。有一句话叫温水煮青蛙，如果社会主义对资本没有威胁的话，它们为什么对我们抱有如此大的敌意，而不是任由我们在乌托邦的幻想中自生自灭呢？（不可能说美国希望解放中国人民吧？不会吧不会吧？） ","date":"2023-01-03","objectID":"/record/:24:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.12.6 在意识形态对立并且互联网主流的舆论属于对立意识形态 的情况下想要不被这些言论影响是很困难的。不过有一句话说的很好 屁股决定脑袋。这并不是说在个人意义上，谁给我吃饭我给谁说话，而是在资本主义发展几百年以来，已经形成一套关于自由民主的理论，这套理论确实表达了人民对自由公平的期望。但是同时也为资本的滋生留下的种子。他们的民众在这种意识形态下自然会为它们的自由民主辩护，而忽略资本的无序扩张。 对于这些言论我们只要相信一下事实： 中国曾被西方列强侵略 中国曾被日本侵略，并且南京大屠杀真实且有证据 资本主义剥削剩余价值 美国曾经对印第安实施暴力的种族灭绝 大多数发达国家的福祉，是因为将内部阶级矛盾转移到了第三世界罢了。 只要相信这些历史是准确的，无论那些坏人换了什么信仰，换了什么名字，我们都知道它们曾经做过恶，并且是这些恶的受益者，所以不管他们说多漂亮的话，都是值得怀疑的。 ","date":"2023-01-03","objectID":"/record/:25:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.12.6 LGBT+群体的出现并且在美国变成政治正确，可以说是美国自由民主，也可以说是资产阶级在将阶级矛盾转移到无产阶级内部，从而分化无产阶级。 为什么二战中犹太人被屠杀，现在的西方世界对于犹太人是政治正确的优待。中国人被日本屠杀，中国人为什么没有被当作政治正确的优待？如果中国走上资本主义道路，那些西方媒体/政府 也会极力宣传优待中国人的。 ","date":"2023-01-03","objectID":"/record/:26:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"2022.12.9 《白月光》 除了此刻，我竟一无所有， 今夜是睡在桥洞还是马路？ 无所谓了，只觉得月光有些刺眼。 // 黑暗里的狼狈和不安无处可逃 ","date":"2023-01-03","objectID":"/record/:27:0","tags":null,"title":"Record","uri":"/record/"},{"categories":null,"content":"L层神经网络.html Neural Network ","date":"2023-01-03","objectID":"/neural-network/:0:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"实现方式：采用BP算法，使用梯度下降来优化W，b ","date":"2023-01-03","objectID":"/neural-network/:1:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"需要实现的函数如下： initial():根据用户自定义的层layer-\u003e[ $n_1, n_2,n_3,…,n_m$ ]来初始化参数W，b sigmoid():输入$X \\in R^{m x n}$ ，返回$A = \\frac{1}{1+e^{-WX + b}}$ liner_propagation():实现一层的前向传播，返回 A，并且缓存中间量Z L_layers_propagation():实现L层的前向传播，并且缓存所有中间层的A，Z predict():使用训练好的模型Ws，bs预测某一输入特征向量对应的预测值 back_propagation():实现一层的反向传播 L_back_propagation():实现L层链式反向传播 update_parameters():每一个epoch更新参数 evaulate():评估模型 model():主循环，BP算法梯度下降的循环 load_data():加载数据 在整体的设计中并没有loss函数的出现，是因为，在反向传播过过中，dloss/dW的计算并不涉及loss的值，dloss/dW的表达式中仅有y_truth 和 y_pred 链式偏微分 推导（这里是根据西瓜书上原始公式推导，所以是累计神经网络） ","date":"2023-01-03","objectID":"/neural-network/:2:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"由于在布置编程作业之前就自己实现了一下神经网络，所以实现的是任意层数和任意数量神经元的神经网络，所以就改下参数交作业了 由于神经网络层数可能会非常多，所以在反向传播时loss对每一层的W，b求导会重复很多中间步骤 $$设：\\beta^i \\in R^{m \\cdot n}$$ $$ A^{i-1} \\in R^{n \\cdot s}$$ $$ Z^{i} \\in R^{m \\cdot s}$$ $$Z^i = W^i A^{i-1} + b^i = \\beta^i A^{i-1}, $$ $$A^i = sigmoid(Z^i);$$ $$\\frac{\\partial E}{\\partial \\beta^i} = \\frac{\\partial Z^i}{\\partial \\beta^i} \\cdot \\underbrace{ \\frac{\\partial A^i}{\\partial Z^i} \\cdot \\overbrace {\\frac{\\partial E}{\\partial A^i}}^{\\partial A^i} }_{\\partial Z^i} ， \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad （1.1）$$ $$ \\frac{\\partial E}{\\partial A^{i-1}} = \\frac{\\partial Z^i}{\\partial A^{i-1}} \\cdot \\underbrace {\\frac{\\partial A^i}{\\partial Z^i} \\cdot \\overbrace{ \\frac{\\partial E}{\\partial A^i} }^{\\partial A^i} }_{\\partial Z^i}, \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad （1.2）$$ 其中： $$\\partial A^i由上一层反向传播提供,$$ 现在考虑每一层反向传播的计算 已知: $$\\frac{\\partial E}{\\partial A^k}, \\frac{\\partial A^k}{\\partial Z^k}, \\qquad其中：k是层数$$ 求解: $$\\frac{\\partial E}{\\partial {Z^k}_{i,j}} \\qquad其中： i,j \\in { i,j | i \\in (1,Z^k.shape[0]， j \\in (1,Z^k.shape[1])}$$ 分析： 由于 （暂时忽略掉上标，仅在需要的时候添加） $$Z = \\beta A$$ $$Z_{i,j} = \\sum_{k=1}^{n}\\beta_{i,k}A_{k,j}$$ 该式子表明 $$Z_{i,j}的值与同行\\beta{i,k}$$ $$即每一个\\beta与Z的第a行相关$$ $$那么要计算\\frac{\\partial E}{\\partial \\beta_{a,b}}$$ $$即需要\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s}\\frac{\\partial E}{\\partial Z_{a,k}} \\frac{\\partial Z_{a,k}}{\\partial \\beta_{a,b}}$$ $$而：\\frac{\\partial Z_{a,k}}{\\partial \\beta_{a,b}} = A_{b,k}$$ $$那么：\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s}\\frac{\\partial E}{\\partial Z_{a,k}} \\cdot A_{b,k}$$ $$\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s} {(\\frac{\\partial E}{\\partial Z})}{a,k} \\cdot A{b,k}$$ $$ = \\sum_{k=1}^{s}(\\frac{\\partial E}{\\partial Z}){a,k}(A^T){k,b}$$ $$所以有：\\frac{\\partial E}{\\beta} = dZ A^T$$ 由于推导的迭代式子中包含A, Z, 等前向传播产生的中间结果， 所以在前向传播时需要将它们缓存下来 import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation import sys import copy from IPython import display import time from sklearn.metrics import roc_curve, auc, accuracy_score, confusion_matrix, classification_report, roc_auc_score # 设置随机种子，避免每次的结果不一样 np.random.seed(1) %matplotlib inline ","date":"2023-01-03","objectID":"/neural-network/:3:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"初始化函数initial(layers) input: layers -\u003e [layer_1, layer_2, layer_3, ..., layer_m] output: paramters -\u003e dict() parameters[\"w\"] = temp_w -\u003e list() parameters['layers'] = layers -\u003e list() def initial(layers): parameters = dict() temp_w = list() for i in range(1, len(layers)): temp_w.append(np.random.randn(layers[i], layers[i-1])) parameters[\"w\"] = temp_w parameters['layers'] = layers return parameters ","date":"2023-01-03","objectID":"/neural-network/:4:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"激活函数 Sigmoid() 激活函数种类： sigmoid():“S\"形函数$f(x) = \\frac{1}{1+e^{-WX + b}}$$ ReLU():线性修正单元$f(x) = max(0,x)$ tanh():双曲正切函数$f(x) = \\frac{e^x-e^{-x}}{e^x+e^{-x}}$ ELU: PReLU: LReLU:x负半轴斜率比较小的PReLU def sigmoid(A): return 1/(1+np.exp(-A)) ","date":"2023-01-03","objectID":"/neural-network/:5:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"前向线性传播 $Z = WX + b$ $A = \\frac{1}{1+e^-Z}$ def liner_propagation(w, A): Z = np.dot(w, A) A = sigmoid(Z) return Z, A ","date":"2023-01-03","objectID":"/neural-network/:6:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"L层的前向传播 是L次linear_propagation的叠加 由于反向传播的需要，这里的L层前向传播需要缓存每一层的A，Z到A_cache and Z_chache def L_layers_propagation(parameters, x): A_cache = list() Z_cache = list() cache = dict() A_cache.append(x) Z_cache.append(x) w = parameters[\"w\"] layers = parameters['layers'] for i in range(0, len(layers) - 1): Z, A = liner_propagation(w[i], A_cache[i]) assert Z.shape == A.shape Z_cache.append(Z) A_cache.append(A) cache[\"A\"] = A_cache cache[\"Z\"] = Z_cache return cache ","date":"2023-01-03","objectID":"/neural-network/:7:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"Loss函数（均方误差） 如果要实现任意loss函数，只会影响链式传播哦的最后一项，而不会影响链式传播的中间过程 由于最近DDL多，所以任意loss函数的实现，在寒假实现 def lossFunc(Y_pre, Y_true, method = \"MSE\"): temp = Y_pre - Y_true return .5 * np.dot(temp, temp.T) ","date":"2023-01-03","objectID":"/neural-network/:7:1","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"预测函数 input = x output = y $y = f(x)$ $y\u003e.5$ =\u003e $y=1$ $y\\le .5$ =\u003e $y= 0$ def predict(parameters, x, draw = False): Y = L_layers_propagation(parameters, x)['A'][-1] if draw == False: Y[Y \u003e .5] = 1 Y[Y \u003c= .5] = 0 return Y ","date":"2023-01-03","objectID":"/neural-network/:8:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"反向传播函数 back_propagation 实现反向传播的难点在于求梯度 求梯度的方法如下： $dx = \\frac{f(x) - f(x-\\Delta x)}{\\Delta x}$ 老师上课提到的这种方法会导致精确度问题 如当在梯度下降算法中设定$\\Delta x= \\eta$时该算法退化为 W := W - loss(x-learning_rate) 2.利用求偏导法则，一层一层的求偏导 使用类似 tensorflow 的 Autograd 的计算图，将每一个参数变量加入计算图中，然后可以找到变量之间的关联然后求导(实现过于复杂，对于简单的全链接网络没必要这样做) 使用高等数学中的多变量求导，结合线性代数的矩阵变换进行 实数 对 矩阵 的 链式求导 参考 矩阵求导术（下） 矩阵求导术（上） 引入克罗内克积实现矩阵的链式求导，在注释代码中是没经过花间的Kron积，运算量极大，经过化简得到简单的矩阵表达式 def back_propagation(W, A_prev, dZ): # dZA_prev = np.diag( (A_prev * (1 - A_prev)).T.flatten() ) # I = np.eye(A_prev.shape[1]) # dZ_prev = np.dot(np.dot(dZA_prev,np.kron(I, W.T)), dZ) # I = np.eye(W.shape[0]) # dW = np.dot(np.kron(A_prev, I),dZ) # print(A_prev.shape, W.shape, dZ.shape) dZ_prev = np.multiply( A_prev * (1 - A_prev), np.dot(W.T,dZ)) dW = np.dot(dZ,A_prev.T) return dZ_prev, dW def L_back_propagation(cache, parameters, y): w = parameters[\"w\"] layers = parameters[\"layers\"] L = len(layers) - 1 A = cache[\"A\"] dW_list = list() dZ_prev = A[L] * (1 - A[L]) * (A[L] - y) for i in reversed(range(0, L)): dZ_prev, dW = back_propagation(w[i], A[i], dZ_prev) dW_list.append(dW) cache[\"dW\"] = dW_list return cache ","date":"2023-01-03","objectID":"/neural-network/:9:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"更新参数 pass def update_parameters(cache, parameters, learning_rate): w = parameters[\"w\"] layers = parameters[\"layers\"] L = len(layers) - 1 dW = cache[\"dW\"] for i in range(L): w[i] -= dW[L-i-1] * learning_rate # b[i] = b[i] - db[len(b)-i-1] * learning_rate parameters[\"w\"] = w return parameters ","date":"2023-01-03","objectID":"/neural-network/:10:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"evaulate 使用准确度作为评估标准 def evaluate(Z, Y): bools = Z == Y accuracy = np.sum(np.reshape(bools,bools.size))/Y.shape[1] return accuracy def evaluate_detial(y_t, y_p): y_test = copy.deepcopy(y_t) y_pred = copy.deepcopy(y_p) print(\"The roc_auc_score is {}\".format(roc_auc_score(y_test, y_pred))) tpr,fpr,thresholds = roc_curve(y_test,y_pred) plt.subplot(1,2,1) plt.plot(fpr, tpr) plt.xlim([0.0, 1.0]) plt.ylim([0.0, 1.0]) plt.title('ROC curve for diabetes classifier') plt.xlabel('False Positive Rate (1 - Specificity)') plt.ylabel('True Positive Rate (Sensitivity)') plt.grid(True) # mean = np.sum(y_pred)/y_pred.shape[0] y_pred[(y_pred \u003c 0.5)] = 0 y_pred[(y_pred \u003e= 0.5)] = 1 # plt.scatter(x_test[0, :], x_test[1, :], c = y_pred[:, 0]) print(\"The accuracy is {}\".format(accuracy_score(y_test[:,0], y_pred[:,0]))) # 计算召回， 查全率， 查准率 。。。。 target_names = ['class0','class1'] print(classification_report(y_test,y_pred,target_names = target_names)) ## 绘图 def Plot(X, label, parameters): x_min, x_max = X[0,:].min() - .5, X[0,:].max() + .5 y_min, y_max = X[1,:].min() - .5, X[1,:].max() + .5 h = 0.01 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) Z = predict(parameters, np.c_[xx.ravel(), yy.ravel(), np.ones((yy.ravel().shape))].T) Z = Z.reshape(xx.shape) plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral) plt.scatter(X[0,:],X[1,:],c=label[0,:]) ","date":"2023-01-03","objectID":"/neural-network/:11:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"load_data 加载数据的管道 def load_data(shape = \"circle\"): X = np.random.rand(2,200) one = np.ones((1,200)) X = np.vstack((X,one)) C = [] for x in X.T: if shape == \"circle\": # 同心圆 if (x[0]-.5)**2 + (x[1]-.5)**2 \u003c .03: C.append(1) elif (x[0]-.5)**2 + (x[1]-.5)**2 \u003c .13: C.append(0) else: C.append(1) elif shape == \"xor\": # 四分 if (x[0] - .5)*(x[1] - .5) \u003e=0: C.append(1) else: C.append(0) x_min, x_max = X[0,:].min() - .05, X[0,:].max() + .05 y_min, y_max = X[1,:].min() - .05, X[1,:].max() + .05 h = 0.01 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) test = np.c_[xx.ravel(), yy.ravel(), np.ones((yy.ravel().shape))].T return X, np.array(C).reshape(1,-1), test, (xx,yy) ","date":"2023-01-03","objectID":"/neural-network/:12:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"Back Propagation(BP算法的整体框架) 使用梯度下降的优化方法 其他可用的优化方法 SGD 随机梯度下降 MBGD （Mini Batch Gradient Descent）用于样本容量大，内存/现存不够的情况 Momentum 动量梯度下降 Nesterov NAG Adagrad Adaelta Adam def model(X, Y, test,canvs, layers, learning_rate = 0.01, epoch = 1000, detial = True, draw = False): parameters = initial(layers) draw_param = [] for i in range(epoch): cache = L_layers_propagation(parameters, X) cache = L_back_propagation(cache, parameters, Y) parameters = update_parameters(cache, parameters, learning_rate) if i % 500 == 0 and draw == True: # draw_param.append(copy.deepcopy(parameters)) yield predict(parameters, test, draw = True).reshape(canvs[0].shape) if i % 1000 == 0 and detial == True: print(\"this is {}th epoch.\".format(i)) Y_predict = predict(parameters, X, draw=False) accuracy = evaluate(Y, Y_predict) print(\"accuracy is {}\".format(accuracy)) if draw == False: return parameters ","date":"2023-01-03","objectID":"/neural-network/:13:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"实现累计BP算法 def model_caculate(X, Y, X_test, Y_test, layers, learning_rate = 0.01, epoch = 1000, interval = 50): parameters = initial(layers) Loss = [] loss = None Acc = [] accuracy = None start = time.time() Y_predict = None for i in range(epoch): cache = L_layers_propagation(parameters, X) cache = L_back_propagation(cache, parameters, Y) loss = lossFunc(Y, cache[\"A\"][-1]) parameters = update_parameters(cache, parameters, learning_rate) if i % interval == 0: Loss.append(loss[0,0]) Y_predict = predict(parameters, X_test, draw=False) accuracy = evaluate(Y_test, Y_predict) Acc.append(accuracy) if i % (interval * 50) == 0: now = time.time() print(\"Calculate Dense Net:~$ {}th epoch, accuracy: {}, loss:{}, time:{}-\".format(i, accuracy, loss[0,0], now - start)) start = time.time() return Loss, Acc, Y_predict X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] epoch = 25000 Loss, accuracy, Y_pred = model_caculate(X, label, X, label, layers, learning_rate=0.01, epoch= epoch) #开始画图 x = np.linspace(0, 25000, 500) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(label.T, Y_pred.T) Calculate Dense Net:~$ 0th epoch, accuracy: 0.725, loss:21.40100100371333, time:0.0010008811950683594- Calculate Dense Net:~$ 2500th epoch, accuracy: 0.725, loss:19.748958341789084, time:0.7027204036712646- Calculate Dense Net:~$ 5000th epoch, accuracy: 0.725, loss:18.484585855571503, time:0.7009453773498535- Calculate Dense Net:~$ 7500th epoch, accuracy: 0.705, loss:16.377806924887945, time:0.6996634006500244- Calculate Dense Net:~$ 10000th epoch, accuracy: 0.87, loss:10.950215467935237, time:0.7041025161743164- Calculate Dense Net:~$ 12500th epoch, accuracy: 0.88, loss:9.160948492962692, time:0.701648473739624- Calculate Dense Net:~$ 15000th epoch, accuracy: 0.885, loss:8.84026852930535, time:0.6946816444396973- Calculate Dense Net:~$ 17500th epoch, accuracy: 0.965, loss:6.105461022050368, time:0.685279369354248- Calculate Dense Net:~$ 20000th epoch, accuracy: 0.99, loss:2.3057686501449832, time:0.7090015411376953- Calculate Dense Net:~$ 22500th epoch, accuracy: 0.99, loss:0.958385284049958, time:0.6965689659118652- The roc_auc_score is 1.0 The accuracy is 1.0 precision recall f1-score support class0 1.00 1.00 1.00 55 class1 1.00 1.00 1.00 145 micro avg 1.00 1.00 1.00 200 macro avg 1.00 1.00 1.00 200 weighted avg 1.00 1.00 1.00 200 ","date":"2023-01-03","objectID":"/neural-network/:13:1","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"实现标准BP算法（也就是Mini-batch = 1，这样的话在python下使用for循环喂数据会非常慢） def model_std(X, Y, X_test, Y_test, layers, learning_rate = 0.01, epoch = 1000, interval = 50): parameters = initial(layers) Loss = [] Acc = [] accuracy = None loss = None Y_pred = None start = time.time() for i in range(epoch): for j in range(0, X.shape[1]): cache = L_layers_propagation(parameters, X[:, j].reshape(3, -1)) cache = L_back_propagation(cache, parameters, Y[:, j].reshape(1, -1)) parameters = update_parameters(cache, parameters, learning_rate) if i % interval == 0: Y_pred = predict(parameters, X_test, draw = False) loss = lossFunc(Y_test, Y_pred)[0,0] Loss.append(loss) accuracy = evaluate(Y_test, Y_pred) Acc.append(accuracy) if i % (interval * 20) == 0: now = time.time() print(\"Stander Dense Net:~$ {}th epoch, accuracy: {}, loss:{}, time:{}\".format(i, accuracy, loss, now - start)) start = time.time() return Loss, Acc, Y_pred X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] epoch = 33300 Loss,accuracy, Y_pred = model_std(X, label, X, label, layers, learning_rate=0.01, epoch= epoch) #开始画图 x = np.linspace(0, 25000, epoch/50) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(label.T, Y_pred.T) Stander Dense Net:~$ 0th epoch, accuracy: 0.65, loss:35.0, time:0.018254756927490234 ","date":"2023-01-03","objectID":"/neural-network/:13:2","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"动态可视化训练过程 def main(epoch= 50000, detial=True, draw=False): X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] if draw == True: for im in model(X, label, test, canvs, layers, learning_rate=0.01, epoch= epoch, detial = detial, draw = True): plt.clf() display.clear_output(wait=True) plt.contourf(canvs[0] ,canvs[1], im, cmap=plt.cm.Spectral) plt.scatter(X[0,:], X[1,:],c=label[0,:]) plt.pause(0.01) else: parameters = model(X, label, test, canvs, layers, learning_rate=0.01, epoch= 30000, detial = detial, draw = draw) Plot(X, label, parameters) main(epoch= 20000, detial=False, draw=True) 西瓜数据集3.0$\\alpha$上的分类 ","date":"2023-01-03","objectID":"/neural-network/:14:0","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"导入数据 import numpy as np import copy def load(): data = np.array([[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]]) Y = copy.deepcopy(data[:, 2].reshape(-1, 1).T) data[:, 2] = 1 X = copy.deepcopy(data.T) X_test = copy.deepcopy(np.c_[X[:, 0:2],X[:, -3:-1]]) Y_test = copy.deepcopy(np.c_[Y[:, 0:2],Y[:, -3:-1]]) X_train = copy.deepcopy(X[:, 2:-2]) Y_train = copy.deepcopy(Y[:, 2:-2]) return X_train, Y_train, X_test, Y_test, X, Y X_train, Y_train, X_test, Y_test, X, Y = load() print(Y.shape) ","date":"2023-01-03","objectID":"/neural-network/:14:1","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"累计BP X_train, Y_train, X_test, Y_test, X, Y = load() X_train.shape, Y_train.shape, X_test.shape, Y_test.shape layers = [3,5,1] epoch = 5500 interval = 1 Loss, accuracy, Y_pred = model_caculate(X_train, Y_train, X_test, Y_test, layers, learning_rate=0.1, epoch= epoch, interval = interval) #开始画图 x = np.linspace(0, 25000, epoch/interval) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(Y_test.T, Y_pred.T) X, label, test, canvs = load_data() X.shape, label.shape ","date":"2023-01-03","objectID":"/neural-network/:14:2","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"标准BP算法 由于实现了累计误差的算法， 所以可以将样样本拆分得到mini-batch的神经网络就是标准BP算法 layers = [3,5,1] epoch = 5500 interval = 1 Loss,accuracy, Y_pred = model_std(X_train, Y_train, X_test, Y_test, layers, learning_rate=0.01, epoch= epoch) #开始画图 x = np.linspace(0, 25000, epoch/50) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # 显示图例 plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(Y_test.T, Y_pred.T) 模型比较 标准BP算法收敛更快 累计BP在python可以通过矩阵运算向量化加速,在迭代过程中震荡变小 累计BP 更占用内存，而标准BP可以一边读一边运算，收敛速度变慢但是梯度方向更准确 Minibatch = n，可以通过调节n的大小使其达到一个合适的值，其收敛速度和迭代的准确性都能提高！ ","date":"2023-01-03","objectID":"/neural-network/:14:3","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"神经网络的优势 相对于决策树，线性模型，神经网络可以通过增加层数/增加神经元的方式拟合任意非线性函数 在之前的同心圆数据集中，神经网络的表达能力远远优于其他模型 \\begin{split} \u0026 C(F , G) = \\frac{F \\cdot G+(1 - F\\otimes G)}{2}\\ \u0026 F\\cdot G = \\vee_U(\\mu_F(u_i)\\land\\mu_G(u_i)) \\ \u0026 F\\otimes G = \\vee_U(\\mu_F(u_i)\\vee\\mu_G(u_i)) \\end{split} ","date":"2023-01-03","objectID":"/neural-network/:14:4","tags":null,"title":"Neural Network","uri":"/neural-network/"},{"categories":null,"content":"中央处理器(Central Processing Unit，简称CPU) ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:0:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"CPU 功能和基本结构 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:1:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"CPU 功能 指令控制（取指，分析，执行） 操作控制一条指令执行，需要控制的各个门电路信号 时间控制 系统时钟 数据加工 算术逻辑运算 中断处理 异常和特殊请求的处理 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:1:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"结构 运算器 算术逻辑单元，暂存寄存器，累加寄存器，通用寄存器组，程序状态字寄存器 控制器 程序计数器，指令寄存器，指令译码器，存储器地址寄存器，存储器数据寄存器 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:1:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"指令执行过程 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:2:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"1. 指令周期 取指周期： 从内存中读取指令 间址周期：取一次和多次间址 执行周期： 中断周期：每条指令执行完成后查询中断请求，如果有中断请求则进入中断周期 为了区别不同周期，使用标志触发器 FE, IND, EX, INT 表示各个周期，取 1 为有效值 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:2:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"2. 指令周期的数据流 取指周期 PC -\u003e MAR -\u003e 地址总线 -\u003e 主存 CU读命令 -\u003e 控制总线 -\u003e 主存 主存 -\u003e 数据总线 -\u003e MDR -\u003e IR CU控制信号 -\u003e PC+1 间地周期 Ad(IR) -\u003e MAR -\u003e 地址总线 -\u003e 主存 CU 读命令 -\u003e 控制总线 -\u003e 主存 主存 -\u003e 数据总线 -\u003eMDR 中断周期 CU控制SP-1， SP-\u003eMAR-\u003e地址总线-\u003e主存 CU写命令-\u003e控制总线-\u003e主存 PC-\u003eMDR-\u003e数据总线-\u003e主存（存入断点） CU（中断服务程序入口） -\u003e PC ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:2:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"3. 指令执行方案 单周期：每条指令时钟周期数固定 多周期：每条指令使用不同周期数，但是指令只能一条执行完才能执行下一条 流水线：流水（参考MIPS 五级流水） ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:2:3","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"数据通路的功能和基本结构 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:3:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"1. 数据通路功能 描述信息从什么地方开始，中间经过了哪些寄存器和开关，传送到哪个寄存器 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:3:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"2. 数据通路结构 CPU内单总线方式：所有东西通过公共同通路传输，冲突概率较高，性能低 CPU内三总线方式：提高效率，数据总线，地址总线，控制总线 专用数据通路方式：需要传送数据的地方直接安排连线，性能高，硬件量大 寄存器间数据传送 PC -\u003e Bus Bus -\u003e MAR 主存 \u0026 CPU 信息传送 PC -\u003e Bus -\u003e MAR 1 -\u003e R MEM(MAR) -\u003e MDR MDR -\u003e Bus -\u003e IR 执行算术逻辑运算 Ad(IR) -\u003e Bus -\u003e MAR 1 -\u003e R MEM-\u003e数据线-\u003eMDR MDR -\u003e Bus -\u003eY (ACC) + (Y) -\u003e Z Z -\u003e ACC ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:3:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"控制器 计算机的五大功能部件 控制器部件 运算器部件 输入设备 / 输出设备 内存储器 他们之间通过 数据总线、地址总线、控制总线 相互通信，其中输入输出设备是通过接口电路连接的 控制器部件从数据总线接受指令 从运算器不见接受指令转移地址 送出 指令地址 到 地址总线 向系统中的部件提供运行所需的控制信号 控制器的主要功能： 取指令和指出下一条指令的地址 对指令进行译码 和 测试，以产生相应操作的控制信号 指挥并控制 CPU、主存、输入输出设备之间的数据流动方向 根据控制器产生微操作控制信号的方式不同，分为硬布线控制器 和 微程序控制器， 其中 PC 和 IR 是相同的，但是确定和表示指令执行步骤的办法和需要的控制信号是不同的 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:4:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"硬布线控制器 根据指令要求、当前时序、外部和内部状态，按时间顺序发送一系列微操作控制信号（也叫做组合逻辑控制器）。 区别于微程序控制器使用的微指令，硬布线控制器是直接采用组合逻辑电路实现机器指令，以 “使用最少零部件，去的最高速度” 作为设计目标，优点是速度快（电路延迟），缺点是不易添加新的功能 硬布线控制单元图 硬布线控制单元，从 CU 中分离出 操作码译码器， 节拍发生器，其中操作译码器将 N 位操作码翻译为 $2^N$ 位， 再输入 CU。 节拍发生器 产生的节拍(T1, T2, T3, …) 由 机器主频(CLK) 分频得到，CU 使用 操作码， 节拍信号， 状态标志 在不同的节拍输出不同的控制信号（微操作命令 $C_i$） 使用节拍的原因 首先信号发出到稳定需要一个极短的时间间隔，所以 CPU 需要有一个最短时间（类似于我们的普朗克时间），其次，一个 机器指令，需要由多个微操作来完成，微操作按照一定的顺序生效，所以需要节拍 来区分微操作顺序 例如： 操作A -\u003e 操作B -\u003e 操作C out = T1 * A + T2 * B + T3 * C 按节拍顺序执行操作，总之技巧是通过逻辑组合控制各个开关,结合节拍器控制顺序（详见4） 硬布线控制器的时序系统和微操作 时钟周期：时钟信号控制的节拍发生器，每个节拍的宽度正好是时钟周期，每个节拍内可以完成一个/几个需要同时完成的操作 机器周期：所有指令执行的基准时间（完成一个基本操作需要的时间），通常取存取周期作为基准时间，在存储字长等于指令字长时，存取周期 = 机器周期 一个机器周期内，完成若干微操作，通过时钟信号控制产生每个微操作 指令周期：取出并执行一条指令的时间 微操作命令分析：指令分为三个周期 取值周期-\u003e间址周期-\u003e执行周期 取址 PC -\u003e MAR 1 -\u003e R M(MAR) -\u003e MDR MDR -\u003e IR OP(IR) -\u003e CU (PC) + 1 -\u003e PC 间址周期 Ad(IR) -\u003e MAR 1 -\u003e R M(MAR) -\u003e MDR 执行周期 a. 非访存指令 CLA // 清ACC COM // 取反 SHR // 算术右移 CSL // 循环左移 STOP // 停机指令 b. 访存指令 ADD X // 加法指令 Ad(IR) -\u003e MAR, 1 -\u003e R M(MAR) -\u003e MDR (ACC) + (MDR) -\u003e ACC STA X // 存数指令 Ad(IR) -\u003e MAR, 1 -\u003e W ACC -\u003e MDR MDR -\u003e M(MAR) LDA X // 取数指令 Ad(IR) -\u003e MAR, 1 -\u003e R M(MAR) -\u003e MDR MDR -\u003e ACC c. 转移指令 JMP X =\u003e Ad(IR) -\u003e PC BAN X =\u003e A0 * Ad(IR) + (~A0) * (PC) -\u003e PC CPU 控制方式 控制一条指令本质是依次执行一个确定的微操作序列， 不同指令对应的微操作数量和复杂度不一样,因此每条指令执行时间不相同，使用以下三种方法控制： 同步控制 所有控制信号都来自统一系统时钟，一最长微操作和最繁琐微操作为标准，采取统一、相同时间间隔、相同节拍数 作为机器周期来运行不同指令 特点：简单，速度慢（因为短命令也需要经过长周期） 异步控制 不存在 基准信号，各个部件按照自身固有速度工作，通过异步应答方式交流 特点：快速，控制复杂 联合控制 介于同步和异步之间，对不同的指令的微操作实行大部分采用同步控制，小部分采用异步控制 硬布线控制单元设计步骤 步骤一: 列出微操作命令时间表 以下是 CLR， COM， SHR 等10条机器指令微操作命令的时间表，观察表结构，共有工作周期标记、节拍、状态条件、微操作命令信号、微操作命令表项，其中一个工作周期可能包含多个节拍， 其中一个节拍内可以完成多个独立的微操作命令（不独立的命令会造成冲突） 步骤二: 微操作信号综合 $$ 微操作控制信号 = 机器周期 \\land 节拍 \\land 脉冲 \\land 操作码 \\land 机器状态条件 $$ 根据表构造逻辑表达式，然后经过化简整理得到可用现有门电路实现的微操作命令逻辑表达式： 步骤三: 绘制微操作命令组合电路图（没什么技巧，就嗯画） ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:4:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"微程序控制器 在电路和机器指令之间添加了一层微程序，根据机器指令生成微指令序列（微程序），使用微程序来实现机器指令功能，而微程序是存储在 控制存储器（CM in CPU） 中的指令序列，优点是规整、灵活、可维护，缺点是每次都要从 CM 中取微指令，速度慢 微程序控制基本概念 就是把微操作信号 代码化， 使每条机器指令转化为一段微程序存入控制存储器中（CM），微程序包含若干微指令，每条微指令对应1/n个微操作。 微命令 \u0026 微操作 ： 机器指令 -\u003e 微操作序列，在微程序控制计算机中，将控制部件向执行部件发送的控制命令称为微命令，例如：打开或关闭某个门电位信号，微操作是微命令的执行过程。 注意微命令的 相容 和 相斥 微指令 \u0026 微周期：微指令是若干微命令的集合（命令就是一位，指令就是一行），存放为微指令的控制存储器单元地址成为微地址，微指令包含两部分信息： 操作控制字段：控制信号 顺序控制字段：下一条微指令地址 微周期是指读取并执行一条微指令花费的时间 主存储器 \u0026 控制存储器：主存是在 CPU 外部的RAM， 控制存储器是在 CPU 内部的ROM 程序 \u0026 微程序： 微程序是机器指令的实时解释器，是在CPU 制造时预先设计和存储的，对程序员透明的 相关寄存器：地址寄存器(MAR)， 微地址寄存器(CMAR)，指令寄存器(IR)，微指令寄存器(CMDR / $\\mu$IR) 微程序控制器组成和工作过程 组成 控制存储器，微指令寄存器，微地址形成部件（产生最初地址和后继地址），微地址寄存器 工作过程 取微指令公共操作 ==\u003e 机器开始时，自动将取指微程序入口地址送入 CMAR，并取址；一般时 CM 的 0号地址，该微程序完成后 主存中取出的机器指令就存储在 IR 中 IR 操作码 ==\u003e 微地址形成部件 ==\u003e 微程序入口地址 ==\u003e CMAR 从CM 中逐条取出指令并执行，执行完一段微程序后回到取址微程序入口，周而复始 微指令的编码方式 直接编码 ： 无需译码，每一位表示一个微命令，简单直观快速，并行性好，缺点是控制存储器容量变大 字段直接编码：将微指令的微命令分成若干小段，把互斥性微命令组合在同一字段，把相容性微命令组合在不同字段，每个字段独立编码，各个字段编码单独定义，互不干扰 优点：缩短字长 缺点：通过译码电路减速 分段原则 互斥命令同段，相容命令不同段 每个段信息为不能太多 每个小段留出一个状态表示无命令（000），因此状态数 = $2^N - 1$ 字段间接编码：一个字段某些命令需要由另一些字段来解释，进一步减小了字长，削弱了并行能力，通常作为辅助手段 微指令的地址形成方式 有两种基本类型 直接由微指令的下地址字段指出（断定方式） 根据机器指令的操作码形成，通过微地址形成部件形成 几种额外类型： 增量计数 (CMAR) + 1 -\u003e CMAR, 连续存放 根据标志位决定微指令分支转移地址 通过测试网络形成 由硬件直接产生微程序入口地址 加电后第一条微指令地址可以由专门的硬件电路产生 微指令的格式 水平型微指令： 指令中一位对应一个控制信号，优点：程序短，执行速度快；缺点：微指令长，编写微程序麻烦 垂直型微指令：采用类似机器指令的 操作数 | 操作码 | 操作码 的结构，优点：微指令短，简单，规整，便于编写；缺点是微程序长执行速度慢 混合型微指令：在垂直型的基础上增加一些不太复杂的并行操作，性能折中 微程序控制单元的设计步骤 写出微操作命令的节拍安排 这里与之前的微操作表的区别是： 取指阶段需要将 IR的操作码送往微地址形成部件, OP(IR) -\u003e CMAR 每条微指令执行完成后都需要形成后继微指令 , 微地址形成部件 -\u003e CMAR 确定微指令格式 微指令编码方式，后继指令形成方式，微指令字长 一般根据微操作个数决定编码方式，确定微指令操作控制字段位数， 由微指令数决定微指令顺序控制字段位数 按操作控制字段位数和顺序控制字段位数决定微指令字长 动态微程序设计和毫微程序设计 动态微程序就是可以更改的微程序，一般使用 EPROM，豪微程序试就是在微程序和电路之间再增加一层解释程序 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:4:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"异常和中断机制 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:5:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"概念 异常 是 CPU 内部产生的意外事件，被称为内中断，是内部检测，与执行的指令相关的同步事件 中断 是 CPU 发出的中断请求，被称为外中断，由外部设备触发，与当前执行指令无关 描述如下： CPU 在执行用户程序第 i 条指令是检测到异常事件 或 第 i 条指令后发现一个中断请求信号，则 CPU 打断当前用户程序，然后转到相应的异常或中断处理程序去执行。 若异常或中断处理程序能解决相应问题，则在处理程序的最后 CPU 指向异常或中断返回指令，回到被打断的用户程序第 i 条指令或 第 i + 1 条指令继续执行 若异常或中断处理程序发现是不可恢复的致命错误，则终止用户程序 一般来说，对终端和异常的具体处理由操作系统（和驱动程序）完成 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:5:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"分类 异常的分类 故障（Fault）：在故障指令启动后，指令结束前被检查到的异常事件，例如：译码时出现非法操作码；取数据时发生缺页缺段；除数为0；其中有的能通过磁盘调入主存来解决，像除数为0这样的异常不能解决并回到原断点继续执行，必须终止进程的执行 自陷（Trap）：是预先安排的一种异常，事先在程序中用一条特殊的指令或通过特殊标志的设定来人为造成陷阱，执行到被设置了陷阱的指令时，CPU 在执行完自陷指令后，自动根据不同陷阱进行相应处理，然后返回自陷指令的下一条执行。 特别的，如果当前指令是转移指令，那不会返回到下一条指令继续执行，而是返回到目标指令继续执行 例如：程序断点调试， 系统调用指令，条件自陷指令都属于陷阱指令，执行到这些指令时，无条件的或有条件的自动调出操作系统内核程序进行执行 故障异常和自陷异常属于程序性异常 终止（Abort）：指令执行过程中发生了使计算机无法继续执行的硬件故障，如控制器出错，存储器校验错误等，程序无法继续执行，只能终止，此时调出中断服务程序来重启系统，这种异常和故障不由特定指令造成，而是随机发生的，属于硬件异常 中断的分类 可屏蔽中断：通过可屏蔽中断请求线INTR 向 CPU 发送的中断请求，CPU可通过在中断控制器中设置相应的屏蔽字来屏蔽或不屏蔽它，被屏蔽的中断请求不会送到 CPU 不可屏蔽中断：通过专门的 不可屏蔽中断请求线NMI 向 CPU 发出中断请求，通常是紧急的硬件故障，如电源掉电 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:5:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"响应 过程为 ： 关中断 -\u003e 保存断点和程序状态 -\u003e 识别异常和中断并转移到相应的处理程序 **关中断 在保存断点和程序状态期间不能被新的中断打断，通过设置中断允许(IF)触发器 来实现禁止响应新的中断： IF == 1 开中断，允许响应中断 IF == 0 关中断，不允许响应中断 保存断点和程序状态 将程序断点（返回地址）送到栈或特定寄存器，通常保存在栈中（为了支持异常或中断的嵌套），状态字寄存器 PSWR 也需要保存到栈或者特定寄存器中。 识别异常和中断并转移到相应处理程序 异常大多数采用软件识别，中断由硬件识别和软件识别两种方式 软件识别是 CPU 设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常或终端查询程序，按优先级查询异常状态寄存器，以检查中断或异常的类型，先查询到的先处理，然后转到内核中相应处理程序 硬件识别也就是向量中断，异常或中断程序的首地址称为中断向量，所有中断向量存放在中断向量表中，每个异常或中断都被指定一个中断类型号，在中断向量表中类型号和中断向量一一对应，因为可以根据类型号快速找到对应的处理程序。 中断或异常的响应是不可被打断的。中断响应结束后 CPU 就从 PC 中取出中断服务程序的第一条指令开始执行，直到中断返回，整个过程是由软硬件协同完成的 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:5:3","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"*指令流水线 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:6:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"1. 基本概念 MIPS 指令流水将指令分成以下五个阶段，每一个时钟到来就会有一条指令进入流水 取指(IF) 从存储器/Cache中取指令（PC，指令寄存器，下一条指令地址计算逻辑） 译码(ID) 对指令进行译码，（操作控制器，去操作数逻辑，立即数符号扩展） 执行(EX) 执行运算/计算地址，（ALU，分支地址计算模块） 访存(MEM) 访问存储器，（数据存储器读写模块） 写回(WB) 将计算结果写回寄存器堆， （寄存器写入控制模块） 区分阶段的企图是，划分 CPU 运行过程中的阶段，分析他们的关联性方便同时多条指令在不同部件上运行 流水原则：流水阶段个数以最复杂指令所用的功能段个数为准，流水长度以最耗时操作花费时间为准 便于流水的指令集特征： 指令长度尽量一致，简化取指，译码 指令格式尽量规整，比如第几位是寄存器编号，第几位是地址，这样方便指令未知时直接通过位数取操作数 采用 Load / Store 指令，这样可以包访存指令的地址计算和运算指令的执行步骤规整在同一周期（不懂什么意思） 数据和指令对齐存放，减少访存次数 大量连续任务才能提高流水效率，流水延长单个指令执行时间，缩短整体执行时间 Tips:流水线需要多个锁存器来存储上一流水阶段的计算结果，控制信号，等来进行下一阶段计算 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:6:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"2. 流水线冒险 结构冒险 多条指令同时访问同一资源（例如：存储器，取指和访存都要访问） 解决： 访存时流水暂停 区分数据存储器 和 指令存储器（事实上 L1 cache 就是这样区分的） 数据冒险 分为 写后读、 读后写、 写后写 三种 解决： 流水暂停(stall，硬件实现), NOP空指令(编译器实现) 数据旁路技术（数据前推） 编译优化调整指令顺序 控制冒险 指令跳转、调用过程、返回等会改变 PC 寄存器值的指令，会导致控制冒险 以前采用延迟槽方法（即在跳转指令后插入无论如何都要执行的指令），现代 CPU 都使用分支预测的方法，预测成功什么都不会发生，预测失败就清空流水线 解决： 分支预测 （分为动态和静态预测） 预取转移成功和不成功两个方向的指令 加快提前形成条件码 提高转移方向的猜准率 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:6:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"3. 性能指标 流水线吞吐率(TP) $$ TP = \\frac{n}{T_k} = \\frac{n}{(k+n-1)\\Delta t}\\ TP_{max} = \\lim\\limits_{n\\rightarrow\\infty}\\frac{n}{(k+n-1)\\Delta t} = \\frac{1}{\\Delta t} $$ 流水线加速比(S) $$ S = \\frac{T_0}{T_k} = \\frac{kn\\Delta t}{(k+n-1)\\Delta t}\\ S_{max} = \\lim\\limits_{n\\rightarrow\\infty}\\frac{kn\\Delta t}{(k+n-1)\\Delta t} = k $$ 其中，n 是指令数量， k 是流水阶段数， $\\Delta t$ 是时钟周期 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:6:3","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"4. 高级流水线技术 处理机一次发射多条指令的多发射技术，增加流水线级数的超流水线技术 超标量流水线技术：不能调整指令执行顺序，并行执行指令搭配 超长指令字技术：也称静态多发射技术，编译程序挖掘程序潜在并行性，将多条能并行的指令组合成一条具有多个操作码的指令（几百位），需要多个部件处理 超流水线技术：增加级数，每级的操作量减小，纳闷呢时钟周期就可以减小，但是依然是一个周期进入一条指令，总的来讲效率提高 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:6:4","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"多处理器基本概念 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:7:0","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"SISD、SIMD、MIMD SISD 是传统的串行计算机结构，包含一个处理器一个存储器，指令按规定顺序执行，SISD 为了提高效率采用流水的方式，之前的内容大都是 SISD 结构 SIMD 是指一个指令同时对多个数据流进行处理，成为数据级并行技术，通常由一个指令控制部件、多个处理单元组成，每个单元执行同一条指令，但每个处理单元都有自己的地址寄存器，因此每个单元都有不同的数据地址，因此，不同处理单元在不同数据集上执行相同的指令。 一个应用程序被编译后可能按SISD在串行硬件上执行，也可能按SIMD 组织并运行于并行硬件上 SIMD 在使用 for 循环处理数组时最有效，例如：对16对数据进行运算的 SIMD 指令如果在16个ALU中同时运算，只需要一次运算时间就能完成。SIMD 在使用 case-switch 语句时效率最低，此时每个执行单元必须根据不同数据执行不同操作。 MISD 是同时执行多条指令，处理同一个数据，实际上不存在这样的计算机 MIMD 同时执行多条指令处理不同数据，分为多计算机系统 和 多处理器系统 多计算机系统中每个计算机节点都具有各自私有的存储器，和独立的主存空间，不能相关通过存取指令访问。需要通过消息传递进行数据传送。 多处理器系统是共享多处理器系统SMP的简称，它共享单一地址空间，通过存取指令访问多有存储器 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:7:1","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"硬件多线程 目的减小线程切换开销 细粒度多线程 多个线程之间轮流交换执行指令，线程间指令不相关，可以乱序并行执行。处理器能在每个时钟周期切换线程 粗粒度多线程 在线程出现较大开销阻塞时切换线程，如 cache 缺失。这种情况下，当发生流水阻塞时，必须清除被阻塞的流水线，新的线程指令开始执行前需要重载流水线，因此开销很大 同时多线程（SMT） 是上述两种多线程技术的变体。在实现指令级并行的同时，实现线程级并行，也就是说，在一个时钟周期内，发射多个不同线程中的多条指令执行。Intel 中的超线程技术就是同时对线程，即在一个单处理器或单个核中设置两套线程状态部件，共享高速缓存和功能部件。 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:7:2","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"多核处理器 多个处理单元集成到单个CPU，每个核可以有自己的 cache，也可以共享 cache，共享主存储器 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:7:3","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"共享内存多处理器 通过存储器中的共享变量相互通信，可以在各个处理器自己的虚拟地址空间单独运行 统一存储访问（UMA）多处理器：分为基于总线，基于交叉开关网络，基于多级交换网络 连接等几种处理器 非统一存储访问（NUMA）多处理器：处理器中不带高速缓存时被称为 NC-NUMA，带有一致性高速缓存时被称为 CC-NUMA 最初内存控制器没有整合进 CPU， 需要通过北桥的内存控制器访问内存，这种架构随着 多核 CPU 的发展而达到瓶颈（争用前端总线），所以NUMA 架构诞生，每个 CPU 分配一个内存区域，而 CPU 之间通过 QPI 总线相连，CPU 通过 QPI 访问其他CPU的远程内存。 由于内存共享， 对于共享变量需要使用同步机制，例如对变量加锁 3 ","date":"2023-01-03","objectID":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/:7:4","tags":null,"title":"计算机组成原理 中央处理器","uri":"/ji-suan-ji-zu-cheng-yuan-li-zhong-yang-chu-li-qi/"},{"categories":null,"content":"指令 计算机指令是机器码，是汇编码，是硬件软件交互界面；指令长度是CPU指令长度（例如：32 位/64位） 常规的指令形式是 OP + Address * n; 指令字长和机器字长没有固定关系，通常有半指令字长，单指令字长，双指令字长，此外指令长度可以是固定的也可以是不定的，通常来说定长指令更易于处理 零地址指令 不需要操作数的指令(空操作，停机，关中断指令)， 堆栈计算机指令 一地址指令 $OP(A_1)\\rightarrow A_1$(自增,自减,求反求补) $(ACC)OP(A-1)\\rightarrow ACC$, 隐含约定地址， 计算寻址范围 二地址指令 算术指令，逻辑运算指令 指令含义 $(A_1)OP(A_2)\\rightarrow A_1$ 三地址指令 $(A_1)OP(A_2)\\rightarrow A_3$, 如果地址均为主存地址， 完成该类指令需要四次访存(取指令 * 1， 取操作数2， 存放结果1) 四地址指令 最后一个地址 $A_4$ 是下一条将要执行的指令 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:1:0","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"指令扩展 虽然现代处理器采用大都采用定长指令，但是为了在此基础上保留指令的丰富类别，采用可变长操作码的定长指令；这意味着操作码位数长度不变，且分散在指令的不同位置，这将增加指令的译码难度，增加控制器复杂度。 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:2:0","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"指令操作类型 数据传送 寄存器之间的传送(MOV) 从内存单元读取数据到CPU寄存器(LOAD) 从CPU寄存器写数据到内存单元(STORE) 算术和逻辑 加(ADD)、 减(SUB)、 乘(MUL)、 除(DIV)、 比较(CMP)、 加1(INC)、 减1(DEC)、 与(AND)、或(OR)、 取反(NOT)、 亦或(XOR) 移位操作 算法移位、逻辑移位、循环移位 转移操作 无条件转移(JMP) 条件转移(BRANCH) 调用(CALL) 返回(RET) 陷阱(TRAP) 输入输出操作 完成 CPU 与外部设备交换数据或传送控制命令及状态信息 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:3:0","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"指令寻址方式 ’’ 寻址方式是指寻找指令或指令操作数有效地址的方式 ’' 寻址方式分为指令寻址和数据寻址两类 指令中数据字段代表的不是真实地址而是形式地址， 形式地址结合寻址方式可以计算真实地址 如果 A 表示寄存器编号或者内存地址， 那么 (A) 表示其中保存的值 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:4:0","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"指令寻址 顺序寻址: 程序计数器PC++，自动形成下一条指令地址 跳跃寻址: 跳跃寻址的地址依然是由 PC 寄存器指出的， 指令跳跃收到 状态寄存器 和 操作数的控制，跳跃地址可以是直接由标记符得到，也可以由当前指令偏移得到；即 绝对地址 和 相对地址 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:4:1","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"数据寻址 本质是如何在指令中 表示 操作数的地址，如何用这种表示计算出 操作数地址 隐含寻址 例如单地址指令中隐含的地址一样，操作数地址隐含在操作码的定义里 立即数寻址 补码表示操作数直接在指令中给出，例如 ADD 1 1 优点 是过程中不用访存 缺点 立即数长度限制了立即数范围 直接寻址 直接在指令中指出操作数地址的真实值 优点 是简单仅访问一次内存 缺点 是指令长度决定了地址的上限，操作数的地址修改不容易！ 间接寻址 指令地址给出操作数地址所在储存单元的地址， 也就是需要一次间接寻址，间接寻址也可以是多次间接寻址，通过主存中取得的字的第一位的取值判断是否是取得操作数地址： 取 0， 表示当前地址是操作数地址 取 1， 表示当前地址是操作数间址 优点 扩大寻址范围，方便子程序返回 缺点 多次访存， 一般扩大寻址地址的方法是寄存器间接寻址 寄存器寻址 直接在指令字中给出操作数所在寄存器编号 优点 不访问主存，执行速度快， 支持向量矩阵运算 缺点 寄存器价格贵，数量有限 寄存器间接寻址 在指令字中给出寄存器编号，该寄存器内存储操作数的地址 优点 速度更快，用于扩展寻址范围 缺点 只能一次间址，需要访问主存 相对寻址 相对寻址是相对于 PC 上加上指令偏移量 A 而形成的有效地址，A 可正可负，补码表示 优点 操作数地址不固定，广泛用于转移指令 缺点 A 的位数决定寻址范围 注意 PC 寄存器取下一条指令后自增，然后再加上偏移量 基址寻址 实际地址 EA = (BR) + A，即基址 + 形式地址。基址寄存器是面向操作系统的，主要解决程序逻辑空间与储存器物理空间无关 优点 扩大寻址范围，利于多道程序设计，利于编写非线性程序（浮动程序），用于各种页表，段表实现 缺点 形式地址位数较短 变址寻址 变址寄存器寻址是 形式地址 A + 变址寄存器 IX，这里的变址寄存器区别于基址寄存器，是面向用户的，其中 IX 的位数足以表示整个存储空间 优点 扩大寻址范围，便于编制循环程序，用于实现数组，因为指令中的 A 是固定的， 而IX是可以由用户设定的 缺点 A 不可变？硬找借口？ 堆栈寻址 堆栈是存储器(或专用寄存器)中一块特定的，后进先出的(LIFO) 原则管理的存储区，该存储区中 读/写单元的地址使用一个特定寄存器SP给出的，硬堆栈/软堆栈。 硬堆栈 是寄存器堆栈，速度快，成本高，不适合做大容量堆栈 软堆栈 是主存中划分的一段区域，速度稍慢，成本低，适合大容量 寻址方式 有效地址 访存次数 隐含寻址 程序指定 0 立即寻址 A是操作数 0 直接寻址 EA=A 1 一次间接寻址 EA=(A) 2 寄存器寻址 EA=R_i 0 寄存器一次间接寻址 EA=(R_i) 1 相对寻址 EA=(PC)+A 1 基址寻址 EA=(BR)+A 1 变址寻址 EA=(IX)+A 1 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:4:2","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"程序的机器码表示 - 汇编 x86 处理器中包含8个32位通用寄存器 寄存器名称 位数 说明 EAX 32 累加器(Accumulator) EBX 32 基址寄存器(Base Register) ECX 32 计数寄存器(Count Register) EDX 32 数据寄存器(Data Register) ESI 32 变址寄存器(Index Register) EDI 32 变址寄存器(Index Register) EBP 32 堆栈基指针(Base Pointer) ESP 32 堆栈顶指针(Stack Pointer) 说明 前四个寄存器 EAX, EBX, ECX, EDX 都是32位寄存器，但是可以仅仅访问其中的半字例如：($EAX = AH + AL$), 除EBP和ESP外，其余寄存器的使用是比较任意的。 x64 汇编增加了几个寄存器和引入新的指令格式，在此仅学习 x86汇编。 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:0","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"环境配置 vscode + MASM/TASM 插件 测试代码如下： DATA SEGMENT MESG DB \"This is an Assembly Language Programe.\", 0DH, 0AH, \"$\" SPACE DB \" \", \"$\" DATA ENDS CODE SEGMENT ASSUME CS:CODE, DS:DATA START: MOV AX, DATA MOV DS, AX ; 将 DATA 段的段首址存入 DS MOV BX, 01H ; BX 初始值设为 1 AGAIN: MOV DX, OFFSET MESG ; 取欲显示的字符偏移量赋给 DX MOV AH, 09H ; 调用 9号(显示)DOS功能子程序 INT 21H MOV CX, BX ; 将 BX 的值赋给 CX INC BX NEXT: MOV DX, OFFSET SPACE ; 取空格字符偏移量赋给 DX MOV AH, 09H INT 21H LOOP NEXT ; 继续显示空格字符，直到 CX 为 0 CMP BX, 10 ; BX 与 10 比较 JBE AGAIN ; 没显示 10 次，转移到 AGAIN 继续执行程序 MOV AH, 4CH INT 21H ; 返回 DOS CODE ENDS END START 右键 运行/调试 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:1","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"汇编指令格式 AT\u0026T格式和Intel格式区别如下 项目/区别 AT\u0026T Intel 大小写 小写 大小写不敏感 操作数 第一个为源操作数,第二个为目的操作数 第一个位目的操作数，第一个为源操作数 前缀 寄存器前缀%，立即数前缀$ 不需要前缀 寻址 使用\"(“和”)\" 使用\"[\" 和 “]” 复杂寻址 disp(base, index, scale), 表示偏移量，基址寄存器， 变址寄存器，比例因子;如 8(%edx, %eax, 2) [edx+eax*2+8] 数据长度 在操作码后边一个字符表示操作数大小 b-\u003ebyte, w-\u003eword, l-\u003elong 显式的注明byte ptr, word ptr, dword ptr 注意 由于32位或64位体系结构都是由16位扩展而来，因此用 word(字) 表示16位 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:2","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"常用机器指令 汇编指令通常可以分为 数据传送指令， 逻辑计算指令， 控制流指令 以下以** Intel 格式**为例介绍重要指令: 约定 \u003creg32\u003e 表示eax,ebx,edx,…. \u003creg16\u003e 表示ax, bx, dx \u003creg8\u003e 表示ah, al, bh,bl,… \u003cmem\u003e 表示内存地址，如[eax]、[var+4]、dword ptr [eax+ebx] \u003ccon\u003e 表示8位、16位或32位常数 mov 指令 将 第二个操作数(寄存器，内存，常数内容) 复制到 第一个操作数(寄存器或内存)，不能用于内存到内存的复制 mov \u003creg\u003e,\u003creg\u003e mov \u003creg\u003e,\u003cmem\u003e mov \u003cmem\u003e,\u003creg\u003e mov \u003creg\u003e,\u003ccon\u003e mov \u003cmem\u003e,\u003ccon\u003e push 指令 将操作数压入内存的栈，常用于函数调用。ESP 是栈顶指针，压栈前 ESP-=4，栈增长方向与内存地址增长方向相反，然后将操作数压入 ESP 指示的地址 push \u003creg32\u003e push \u003cmem\u003e push \u003ccon32\u003e // 栈元素固定 32 位 eg: push eax push [var] pop 指令 将栈顶元素送出，pop指令将 ESP 地址内容出栈，再将 ESP 值加 4 pop edi pop [ebx] add/sub 指令 将两个操作数相加/减，结果保存到第一个操作数中 add \u003creg\u003e,\u003creg\u003e / sub \u003creg\u003e,\u003creg\u003e add \u003creg\u003e,\u003cmem\u003e / sub \u003creg\u003e,\u003cmem\u003e add \u003cmem\u003e,\u003creg\u003e / sub \u003cmem\u003e,\u003creg\u003e add \u003creg\u003e,\u003ccon\u003e / sub \u003creg\u003e,\u003ccon\u003e add \u003cmem\u003e,\u003ccon\u003e / sub \u003cmem\u003e,\u003ccon\u003e inc/dec 指令 操作数自增自减指令 inc \u003creg\u003e / dec \u003creg\u003e inc \u003cmem\u003e / dec \u003cmem\u003e // eg: dec eax inc dword ptr [var] imul 指令 带符号整数乘法指令，有两种形式 1. 两个操作数相加结果保存到第一个操作数 2. 三个操作数后两个数相加结果保存到第一个操作数 imul \u003creg32\u003e,\u003creg32\u003e imul \u003creg32\u003e,\u003cmem\u003e imul \u003creg32\u003e,\u003creg32\u003e,\u003ccon\u003e imul \u003creg32\u003e,\u003cmem\u003e,\u003ccon\u003e // tag: 这里显然不能存储到 \u003cmem\u003e 所以该过程最多只有一次非读指令访存 // 如果乘法操作可能溢出，则编译器溢出标志 OF = 1，是CPU调溢出处理程序 idiv 指令 带符号整数除法指令，他只有一个操作数，而被除数为 edx:eax中的内容（是拼接的64位整数），操作结果有两部分：商和余数，商-\u003eeax, 余数-\u003eedx // (edx:eax) / op_1 = edx:eax idiv \u003creg32\u003e idiv \u003cmem\u003e // eg: idiv ebx idiv dword ptr [var] and/or/xor 指令 结果放在第一个操作数里 and \u003creg\u003e,\u003creg\u003e / or \u003creg\u003e,\u003creg\u003e / xor \u003creg\u003e,\u003creg\u003e and \u003creg\u003e,\u003cmem\u003e / or \u003creg\u003e,\u003cmem\u003e / xor \u003creg\u003e,\u003cmem\u003e and \u003cmem\u003e,\u003creg\u003e / or \u003cmem\u003e,\u003creg\u003e / xor \u003cmem\u003e,\u003creg\u003e and \u003creg\u003e,\u003ccon\u003e / or \u003creg\u003e,\u003ccon\u003e / xor \u003creg\u003e,\u003ccon\u003e and \u003cmem\u003e,\u003ccon\u003e / or \u003cmem\u003e,\u003ccon\u003e / xor \u003cmem\u003e,\u003ccon\u003e // eg: and eax, 0fH xor edx, edx not 指令 位反转指令，将操作数每一位反转 not \u003creg\u003e not \u003cmem\u003e // example: not byte ptr [var] neg 指令 取负指令 neg \u003creg\u003e neg \u003cmem\u003e // eg: neg eax shl/shr 指令 逻辑移位指令， l 为左， r 为右，第一个操作数是被移位，第二个操作数是移位位数 shl \u003creg\u003e,\u003ccon8\u003e / shr \u003creg\u003e,\u003ccon8\u003e shl \u003cmem\u003e,\u003ccon8\u003e / shr \u003cmem\u003e,\u003ccon8\u003e shl \u003creg\u003e,\u003ccl\u003e / shr \u003creg\u003e,\u003ccl\u003e shl \u003cmem\u003e,\u003ccl\u003e / shr \u003cmem\u003e,\u003ccl\u003e // cl 是 8 位寄存器 // eg： shl eax, 1 shr ebx cl 标签 IP 寄存器是 CPU 硬件结构，其值是不能直接指定的，只能通过控制流指令来更改，在 x86 汇编中使用标签来标记代码地址 movesi, [ebp+8] begin: xor ecx, ecx mov eax, [esi] jump 指令 直接跳转类似 goto 语句 jmp \u003clabel\u003e // eg: jmp begin j\u003ccondition\u003e 指令 条件转移指令 je \u003clabel\u003e (jump when equal) jne \u003clabel\u003e (jump when not equal) jz \u003clabel\u003e (jump when last result was zero) jg \u003clabel\u003e (jump when greater than) jge \u003clabel\u003e (jump when greater than or equal to) jl \u003clabel\u003e (jump when less than) jle \u003clabel\u003e (jump when less than or equal to) // eg: cmp eax, ebx jle done // tips:这里的跳转指令并不依赖某个寄存器的值，而是依赖 由cmp和test指令确定的 CPU 的状态值 cmp/test 指令 cmp 用于比较两个操作数的值，test 对两个数进行逐位与运算，他们不保存操作结果，仅根据运算结果设置 CPU 状态字中的条件码 cmp \u003creg\u003e,\u003creg\u003e / test \u003creg\u003e,\u003creg\u003e cmp \u003cmem\u003e,\u003creg\u003e / test \u003cmem\u003e,\u003creg\u003e cmp \u003creg\u003e,\u003cmem\u003e / test \u003creg\u003e,\u003cmem\u003e cmp \u003creg\u003e,\u003ccon\u003e / test \u003creg\u003e,\u003ccon\u003e // tips:cmp,test和jcondotion指令搭配使用，举例： cmp dword ptr [var], 10 // 比较 4 字节 jne loop // 相等继续执行，否则跳转到loop test eax, eax // 测试eax 是否为0 jz xxxx // 为0则设置标志位 ZF 位1，跳转到 xxxx 处执行 call/ret 指令 用于实现子程序（过程，函数等）的调用和返回， call 指令将当前执行的指令地址入栈，然后无条件转移到有标签指示的指令。call指令还会保存调用之前的信息。 ret 实现了子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址。 call \u003clabel\u003e ret ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:3","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"过程调用机器表示 使用 call/ret 指令实现过程调用，假定过程P(调用者) 和 过程Q(被调用者)，过程调用步骤如下： P 将入口参数放在 Q 能访问到的地方 P 将返回地址存到特定的地方，然后将控制权转移到 Q (IP寄存器指向) Q 保存 P 的现场(通用寄存器的内容)，并为自己的非静态局部变量分配空间 执行过程 Q Q 回复 P 的现场，将结果放到 P 能访问到的地方，并释放局部变量所占空间 Q 取出返回地址，将控制转移到 P 注意 ： 上述步骤中需要为入口参数，返回地址，过程P现场，过程Q局部变量，返回结果 找到存放空间，而用户可见的寄存器数量是有限的，因此需要在内存中用一个栈来存放数据，EAX、ECX、EDX是调用者保存寄存器，其保存和恢复过程由P负责。EBX、ESI、EDI 是被调用则保存寄存器，每一个过程都有其自己的栈区，成为栈帧(Stack Frame)。寄存器 EBP指示栈底，ESP 指向栈顶，栈从高地址向低地址增长。 例如 // 被调用函数/过程 int add(int x, int y){ return x + y; } // 调用者过程 int caller(){ int temp1 = 125; int temp2 = 80; int sum = add(temp1, temp2); return sum; } 经过 GCC 编译后 caller 过程的汇编码如下 ： caller: # stage 1 pushl %ebp movl %esp, %ebp # 系统栈 \u0026\u0026 用户栈 # ebp 和 esp 是 用户栈 指针 # 而 push 指令是对系统栈的操作 # 1. 将当前用户栈基址压入系统栈 # 2. 新用户栈基址设为栈顶指针 subl $24, %esp # 为当前过程开辟 24B 内存空间(栈帧) # 此时 esp = ebp - 24，所以栈顶指针更小 # 这里 只用了 28B，是因为 GCC 规定栈帧必须是16B的整数倍 # stage 2 定义变量 movl $125, -12(%ebp) # 这里的变量是由 esp 向 ebp 方向依次放置 movl $80, -8(%ebp) # stage 3 传入函数参数 movl -8(%ebp), %eax mov %eax, 4(%esp) # temp2 先入栈 movl -12(%ebp), %eax movl %eax, (%esp) # temp1 后入栈 # stage 4 调用函数 call add # stage 5 取出函数返回值 movl %eax, -4(%ebp) # 将返回值取出到变量 sum movl -4(%ebp), %eax # 将 sum 作为返回值 # 返回值是通过 eax 寄存器返回的，所以E(A|C|D)X寄存器是由调用者返回的 # stage 6 离开 add 函数 leave # 等价于： # movl %ebp, %esp # popl %ebp # stage 7 退出当前 caller 过程 ret add 过程对应过程的汇编码如下 push %ebp mov %esp, %ebp mov 0xc(%ebp), %eax # 将参数2放入寄存器 # 这里的栈帧是有高位向低位 # 函数参数是从右往左入栈 mov 0x8(%ebp), %edx # 将参数1放入寄存器 lea (%edx, %eax, 1), %eax # 将add_1传入add_2 # 这里是直接通过地址计算 # 使用 lea 指令是因为不占用 ALU，比较快 # 使用单指令代替了多条指令 pop %ebp ret Question：传入参数时是将参数的临时变量拷贝到了 4(%esp) 和 (%esp)，但是为什么在 add 过程中取参数时是取的 0xc(%ebp) 和 0x8(%ebp)？？ Answer： 因为 call 指令会改变 esp 寄存器的值，会将函数返回地址入栈，然后 esp += 4 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:4","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"选择语句机器表示 以 c 语言为例，选择语句主要是 if-then, if-then-else, switch, 编译器条件码(标志位)设置指令各类转移指令来实现选择结构语句 条件码（标志位） 条件码是CPU维护的状态寄存器，他们描述算术逻辑操作的属性，可以检测这些寄存器来执行分支指令： CF 进(借)位标志，适用于最近的无符号整数加减运算，有进(借)位 CF = 1 ZF 零标志，标志最近操作结果是否为0 SF 符号标志，标志最近的带符号数运算结果，负 :SF = 1 OF 溢出标志，标志最近带符号数运算结果是否溢出 由于OF，SF对无符号数无意义， CF对带符号数无意义，常见的算术逻辑运算指令都会设置条件码 IF 语句 通用形式如下 if(test_expr) then_statement else else_statement 翻译为 goto 语句形式 t = test_expr; if(!t) goto false; then_statement goto done; false: else_statement done: 对于下面的 c 语言函数 int get_count(int *p1, int *p2) { if(p1 \u003e p2) return *p2; else return *p1; } 将得到以下汇编码 movl 8(%ebp), %eax movl 12(%ebp), %edx cmpl %edx %eax jbe .L1 movl (%edx), %eax jmp .L2 .L1: movl (%eax), %eax .L2: SWITCH 语句 对于 小范围 和 小量 的选择语句，使用 跳转表，对于大范围或者大量的选择语句编译器还是会和 if-then-else 一样的方式来处理 跳转表即： .L12: .long .L3 .long .L4 .long .L5 .long .L6 .long .L7 .long .L8 这样就可以通过 相对于 .L12 的偏移量来计算真实的跳转目的地了，这样的跳转只需一个指令来找到跳转目的，而不是多层的 if-else 嵌套，有点字典内味了。这也解释了为什么switch-case语句需要break来退出case，因为所有的case在地址上是连续的。 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:5","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"循环语句机器表示 常规的循环语句 有while,for, do-while 大多数编译器都将上述三种形式的循环语句转化为do-while 语句 DO-WHILE 循环 do body_statement while(text_expr) goto 语句形式 loop: body_statement t = test_expr; if(t) goto loop; WHILE循环 while(test_expr) body_statement 在第一次执行循环体之前先执行一次 t = test_expr; if(!t) goto done; do body_statement while(text_expr); done: t = test_expr if(!t) goto done; loop: body_statement t = test_expr; if(t) goto loop; done: FOR 循环 一般形式 for(init_expr; test_expr; update_expr) body_statement 转化为 while 循环 init_expr; while(test_expr){ body_statement update_expr; } 转化为 goto 语句 init_expr; t = test_expr; if(!t) goto done; loop: body_statement update_expr; t = test_expr; if(t) goto loop; done: int nsum_for(int n){ int i; int result = 0; for(i = 1; i\u003c=n; i++) result += i; return result; } ==== 编译 ====\u003e movl 8(%ebp), %ecx movl $0, %eax movl $1, %edx cmp %edx, %ecx jg .L2 .L1: addl %edx, %eax addl $1, %edx cmpl %ecx, %edx jle .L1 .L2: 直接按照模板即可 ","date":"2023-01-03","objectID":"/ji-suan-ji-zhi-ling-xi-tong/:5:6","tags":null,"title":"计算机指令系统","uri":"/ji-suan-ji-zhi-ling-xi-tong/"},{"categories":null,"content":"最近 Nreal Air 眼睛发售，看到有玩家自制的 游戏王AR 游戏，能将怪物真的召唤到场地，非常震撼，于是思考能不能将传统的游戏类型用AR来表达呢？ 很自然的想到了 马里奥赛车：实况，借鉴这样的思路可以想到一种全新的游戏类型，以马里奥：奥德赛为例，AR眼睛首先识别出所在场景中所有的物体，这里主要包括以下类别： 平台 常见可交互物体（例如放在茶几上的书📕📖） 游戏通过识别出的几何体来构建场景🌃，按照模板关卡程序生成关卡，在各个物体的背后埋藏小惊喜（可以在现实中移动物体，可以操作马里奥与物体交互），这些物体都是程序预设的可交互物体模型，玩家通过发现各个现实场景中的潜在的关卡模板，然后进行闯关，通过关卡即可收集该关卡模板，并能够与朋友分享🧑‍🤝‍🧑 这个想法需要解决以下技术难点： 稳定的识别出预设物体 通过一个只包含3D几何体的场景，生成关卡 要决定哪些物体将变为平台，哪些能将玩家吹起来，哪些是移动平台，等 要决定在什么放置金币🪙，放置怪物，放置惊喜 需要程序来决定如何通过金币，惊喜，来引导玩家走向终点 如果现有的场景无法构建出关卡，还要决定在什么位置添加平台，辅助完成关卡 玩家如何操作角色（手柄🕹🎮？手势？APP？） 其中最复杂的应该是生成场景的规则？这是一个复杂的工程，想到这里就不往下想了🧠，想也想不明白，等着任天堂做吧？交给你了任天堂💕！ ","date":"2023-01-03","objectID":"/idea-xr-you-xi-ling-gan/:0:0","tags":null,"title":"XR 游戏灵感","uri":"/idea-xr-you-xi-ling-gan/"},{"categories":null,"content":"动机 Tween 节点可以用于创建补间动画，但是由于只能指定固定缓动函数，并且不能使用 value = f(time) 的形式计算值，所以需要设计一个新的缓动函数类，并实现对应的Inspector插件 通常的缓动曲线都是选用 三角函数，或者使用贝塞尔曲线绘制的自定义曲线，为了逼近现实的运动感，这里实现一种自动控制系统里常用的二阶曲线 ","date":"2023-01-03","objectID":"/godot-huan-dong-qu-xian-jie-dian-she-ji/:0:1","tags":null,"title":"[Godot] 缓动曲线节点设计","uri":"/godot-huan-dong-qu-xian-jie-dian-she-ji/"},{"categories":null,"content":"SecondOrderCurves 设计 首先时二阶系统需要的三个参数，在 Godot 中使用 Vector3 表示， 以及运算过程的中间变量 // 使用插件修复 Godot 不识别自定义类型的 Bug [RegisteredTypeAttribute(nameof(SecondOrderCurves), \"\", nameof(Godot.Object))] public class SecondOrderCurves : Godot.Object { [Export] public Vector3 Parameters = Vector3.One; private Vector2 xp; private Vector2 y, yd; private float k1, k2, k3; private float T_crit; // 用于处理单时间片无法完成的模拟 } 二阶系统的参数只有三个变量，但是我们需要一个输入函数 X(y), 和得到一个响应函数Y(y)，其中输入函数是必须的，它决定以某一时刻系统的输入, 而响应函数可以在游戏运行时实时模拟。 // 输入函数由一些点组成，是折线函数 [Export] public Array\u003cRect2\u003e points = new Array\u003cRect2\u003e() { new Rect2(new Vector2(0, 300), new Vector2(10, 10)), new Rect2(new Vector2(200, 300), new Vector2(10, 10)), new Rect2(new Vector2(200, 150), new Vector2(10, 10)), new Rect2(new Vector2(400, 150), new Vector2(10, 10)), }; 点集是 `X(t)` 的离散表示，对于连续值得输入，需要在两个点之间进行插值，这里简单的采用线性插值 public Vector2 Interpolate(float x) { for(int i = 0; i \u003c points.Count - 1; i++) { if(points[i].GetCenter().x \u003c= x \u0026\u0026 x \u003c= points[i+1].GetCenter().x) { float y1 = points[i].GetCenter().y; float y2 = points[i+1].GetCenter().y; float x1 = points[i].GetCenter().x; float x2 = points[i+1].GetCenter().x; return new Vector2(x, (y1 - y2) / (x1 - x2) * (x - x2) + y2); } } return -1 * Vector2.One; } 对于某时刻 t 一个 X(t) 对应一个X(t); 为了计算 Y(t)，这里采用逐帧计算， // 输入 X(t), 和 delta， 得到当前t时刻的Y(t) public Vector2 Interpolate(Vector2 x, float delta) { Vector2 xd = (x - xp) / delta; xp = x; int iterations = Mathf.CeilToInt(delta / T_crit); // take extra iterations if delta \u003e T_crit delta = delta / iterations; for(int i = 0; i \u003c iterations; i++) { y = y + delta * yd; yd = yd + delta * (x + k3 * xd - y - k1*yd) / k2; } return y; } ","date":"2023-01-03","objectID":"/godot-huan-dong-qu-xian-jie-dian-she-ji/:0:2","tags":null,"title":"[Godot] 缓动曲线节点设计","uri":"/godot-huan-dong-qu-xian-jie-dian-she-ji/"},{"categories":null,"content":"编辑器插件设计 可以参考 Godot.Curve 的实现，但是没有开放 gdscript/c# 接口，只能使用c++拓展，比较繁琐，就自行实现显示和交互逻辑。 编辑器绘图 为了能在编辑器中看到效果，需要在编辑器环境中预览响应函数 Y(t) 的形状。所以使用 point_set 存储曲线值， 表现效果如下图所示： // 只有标记为 Tool 的脚本才会在编辑器环境被加载 [Tool] public class CurveCanvas : Control { Array\u003cVector2\u003e point_set = new Array\u003cVector2\u003e(); Vector2 point_size = Vector2.One * 10; } 模拟每帧的Y(t) 计算： public void ReDraw(SecondOrderCurves curve = null) { // 缓存 cached if(curve != null) { cachedCurve = curve; } else { return; } point_set.Clear(); Vector2 start = Transform(cachedCurve.StartPoint); Vector2 end = Transform(cachedCurve.EndPoint); if(start.x == -1 || end.x == -1 || cachedCurve == null) { return; } // points.Sort(new PointComp()); // Godot.Collection.Array 不支持排序，需要实现一下 cachedCurve.Init(start); int iter = 200; for(int i = 0; i \u003c iter; i++) { Vector2 x = Transform(cachedCurve.Interpolate(cachedCurve.StartPoint.x + i* (cachedCurve.EndPoint.x - cachedCurve.StartPoint.x) / iter)); Vector2 point = cachedCurve.Interpolate(new Vector2(x.y, x.y), 0.01f); point_set.Add(new Vector2(x.x * RectSize.x, (1 - point.x) * RectSize.y)); } Update(); } 由于 Godot 是以右下为正，所以需要对坐标进行转换 private Vector2 Transform(Vector2 point) { return new Vector2(point.x / RectSize.x, (RectSize.y - point.y) / RectSize.y); } 使用 Godot 的绘图函数 public override void _Draw() { // 具体就不展示了，是一些繁琐的代码 DrawMesh(); DrawPoints(); DrawCurve(); DrawInteractive(); } 编辑器交互 为了能够添加/移动/删除图像上的点， 需要实现以下功能： 单击鼠标左键添加点 长按鼠标左键移动点 单机鼠标右键删除点 public override void _Process(float delta) { cover_index = cachedCurve.FindPoint(GetLocalMousePosition()); SafeDragingArray = new Rect2(GetRect().Position, GetRect().Size - Vector2.One * 10); // 退出拖动的调节 if(Dragging \u0026\u0026 IsMouseIn \u0026\u0026 0 \u003c= DraggingIndex\u0026\u0026 DraggingIndex \u003c cachedCurve.points.Count \u0026\u0026 SafeDragingArray.HasPoint(GetLocalMousePosition())) { (cachedCurve.points[DraggingIndex]) = new Rect2(GetLocalMousePosition(), point_size); } Update(); } 监听鼠标输入，在Godot 中连接 CurveCanvas 的鼠标信号 void _on_CurveCanvas_gui_input(InputEvent @event) { if(!IsMouseIn) { return; } if(@event is InputEventMouseButton mouse) { if(mouse.ButtonIndex == (int)ButtonList.Left) { // 1. 创建节点 if(cover_index == -1 \u0026\u0026 !mouse.Pressed \u0026\u0026 !Dragging) { cachedCurve.points.Add(new Rect2(GetLocalMousePosition(), point_size)); } // 2. 开始拖动 if(cover_index != -1 \u0026\u0026 mouse.Pressed) { Dragging = true; DraggingIndex = cover_index; } // 3. 结束拖动 if(!mouse.Pressed) { if(Dragging) ReDraw(); Dragging = false; DraggingIndex = -1; } ReDraw(); } if(mouse.ButtonIndex == (int)ButtonList.Right) { // 删除当前 cover 的节点 if(cover_index != -1 \u0026\u0026 !mouse.Pressed) { cachedCurve.points.RemoveAt(cover_index); } ReDraw(); } } } 编辑器插件（踩坑） Godot 的编辑器插件功能非常多，可以添加Dock，Inspector，主屏幕，等插件。几乎可以实现编辑器阶段的的所有拓展；这里我们主要使用 Inspector 插件来编辑 SecondOrderCurves.parameters. plugin.cs 首先在 plugin.cs 中添加加载/删除 CurveEditorInspector 的代码 tips: 千万不能忘记添加[Tool]，第一次 Build 时会报错，然后再Build一次就Ok了，原因是 C# 是需要编译的而gdscript可以热更新，所以干儿子者不如亲儿子。 #if TOOLS using Godot; using System; [Tool] public class plugin : EditorPlugin { CurveEditorInspector inspector; public override void _EnterTree() { inspector = GD.Load\u003cCSharpScript\u003e(\"res://addons/curve_editor/CurveEditorInspector.cs\").New() as CurveEditorInspector; AddInspectorPlugin(inspector); } public override void _ExitTree() { RemoveInspectorPlugin(inspector); } } #endif EditorInspectorPlugin.cs EditorInspectorPlugin 是一个大坑，它有两种主要的运行模式： 修改单属性 修改多属性 起初我不明白 AddPropertyEditor 和 AddPropertyEditorForMultipleProperties 有什么区别，他们似乎具有相似的行为。后来理解了，在 AddPropertyEditorForMultipleProperties 中指定的属性名列表和在AddPropertyEditor 中指定属性名，这样Godot就会知道需要序列化哪些字段，并且在来回切换窗口或者充气Godot后，已经被编辑的属性能够不被重置。 using Godot; using System; #if TOOLS public class CurveEditorInspector : EditorInspectorPlugin { public override bool CanHandle(Godot.Object @object) { if(@object is SecondOrderCurves) { AddPropertyEditorForMultipleProperties(\"\", new string [] {\"F\", \"Z\", \"R\"}, new CurveEditorProperty()); return true; } return false; } public override bool ParseProperty(Godot.Object @object, int type, string path, int hint, string hintText, int usage)","date":"2023-01-03","objectID":"/godot-huan-dong-qu-xian-jie-dian-she-ji/:0:3","tags":null,"title":"[Godot] 缓动曲线节点设计","uri":"/godot-huan-dong-qu-xian-jie-dian-she-ji/"},{"categories":null,"content":"Show Show Way 最后展示一下运行效果 ","date":"2023-01-03","objectID":"/godot-huan-dong-qu-xian-jie-dian-she-ji/:0:4","tags":null,"title":"[Godot] 缓动曲线节点设计","uri":"/godot-huan-dong-qu-xian-jie-dian-she-ji/"},{"categories":null,"content":"Dynamic Global lllumination(GI) ","date":"2022-12-30","objectID":"/games104/:0:0","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Ray Tracing 先上祖师爷 $$ L_0(x, \\omega_0) = L_e(x,\\omega_0) + \\int_{H^2}f_r(x,\\omega_0,\\omega_i)L_i(x,\\omega_i)\\cos\\theta_id\\omega_i $$ $$ outgoing = emitted + reflected $$ 光照中最困难的部分就是积分，一个trick的方法是 蒙特卡洛积分，基于此就产生了蒙特卡洛光线追踪 原理： 从像素点打出光纤，碰到物体做一次bounce，随着bounce次数增加，计算量是指数级的 缺点： 量的地方很少，只有很少机会打中发光点 计算量大 采样次数越多，噪点越少 难点：采样 tips：所以 Lumen 重点解决的就是采样 采样 均匀采样 概率分布函数（按照PDF分布）采样 就是按照概率分布函数来采样，这样能更好的计算积分，朴素的来说，就是往更亮的地方发射更多的光线 例如：对于天空采样，那么使用 cos 函数（方向靠近正上方发射更多的射线）将会获得噪声更少的图像 例如：对于光暗差别很大的场景使用 GGX PDF 可以获得对比度更强的光照效果 但是这些都是特例，不具有普遍意义，这给我们的启示是 要往亮的地方发射更多的射线 但是上述的算法都是离线计算（用于电影动画广告？中的），但是对于游戏来说，需要一种 realtime 的方法 ","date":"2022-12-30","objectID":"/games104/:1:0","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Lumen 的起始点 Lumen 这一系列方法的基本思路就是 Photon Mapping 思路如下： 提出从光源发射光子，光子最终停留在物体表面，最终渲染就是根据物体表面光子的分布来计算最终颜色 Reflective Shadow Maps(RSM, 2005) 这个工作是这一系列方法的开山鼻祖 ","date":"2022-12-30","objectID":"/games104/:2:0","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"RSM 方法 原文链接 ：Reflective Shadow Maps 渲染物体是从相机视角去看世界的，渲染阴影的时候是从光的视角去看世界的。 Reflective Shadow Maps 的意思就是：从光的角度去看世界，记录所有被照亮的表面，这个表面就是不考虑光线追踪的情况下，光子第一次到达的场景。 空间所有中第一次被照亮的点会散射出光线照亮其他物体，那么在渲染任何一个眼睛看到的点的时候，只需要将所有散射出来的 radiance 收集起来即可。 也就是说对于每一个需要被渲染的像素点， 我们知道所有能照亮该点的亮点（在光的第一次传播被照亮的点），那么计算被渲染点和亮点之间的距离即可知道光照强度。（这个牛逼啊） 缺点：是渲染复杂度太高 优化1 使用了 Cone Tracing 来优化算法，就是发射许多圆锥去照亮点，如果 Cone 中的 RSM 越多那么就越亮，大概是这么个意思。后来还有更好的方法例如： 对 RSM 做 MIP，对于漫反射面使用较大的圆锥去采样，对于光滑的表面用角度较小的圆锥去采样。 优化2 因为间接光照是低频的，所以在屏幕空间可以不用逐像素采样，而是采用 逐 k 像素采样，在 Lumen 中也有类似的思想（原来这么早就有了，看来Lumen是个大缝合怪） 优化3 Cone Tracing 采样时，可以认为 空间位置相差太大 或者 法线朝向相差太大 的点被认为是无效点，就不采样，而是在第一次样样结束后进行一次单独采样，类似的 在 Lumen 中对于稀疏采样不work的点，会进行一次单独的加强采样采样（这个也是抄的） 总结 将光子注入到世界的方法 但是没有想到 MIP方法 在低分辨率稀疏点采集间接光照进行插值，但是在特殊区域进行加强采样 使用 Cone 进行蒙特卡洛积分 没有检测遮挡 只能解决单次传播 RSM 是非常具有启发性的算法 ","date":"2022-12-30","objectID":"/games104/:2:1","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Light Propagation Volumes(LPV) 上一个算发解决了将光子注入空间，这个算法解决光子在空间中传播，虽然是一个非常具有启发性的算法，但是在数学上有点问题 重点是 Propagation， 但是想法很淳朴： 将空间划分为很多 Voxel，对于每个 Voxel，接收到的光照是一个球面分布，球面无论采集多少个点都可以等价为加权累积到一起，可以用SH（双曲正弦函数）函数表达，这里 在GAMES 202 中会详细的讲，这个104讲得很笼统，不好理解（之后补202的时候仔细搞搞）。 这个方法老师也没看懂，我肯定看不懂了，物理学意义是数学意义都点问题。 ","date":"2022-12-30","objectID":"/games104/:2:2","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Sparse Voxel Octree for Real-time Global IIIumination(SVOGI) Nvidia 的工作，这个想法也很淳朴，解决对空间划分的粗细的问题，有以下事实： 有的 Voxel 中没有物体是空的 有的 Voxel 中是实心物体，只有表面有光 使用硬件的保守光栅化：对于很小很薄的三角形保证至少有一个 Voxel 在里边，也就是说保证再小再薄的三角形也能被体素化，那就能收集所有表面的 Voxel，那就是用八叉树来对空间划分，但是在实现中 八叉树每个节点不止存子节点和父节点，还存了三个相邻节点，这使得做 过滤，抗锯齿的时候很方便，所以这个数据结构很复杂。 这里有一个巧妙的思想： 使用 Cone 进行采样，而空间是类似 MIP 的八叉树划分，那么很近的地方，Cone 采样到的 Voxel 很少，但是很远的 地方Cone 采样到的Voxel就很多，而 MIP 的思想中，越靠近根节点的 一个 Voxel 就是很多小的 Voxel 的平均，这样就很巧妙的解决了 Cone 采样，越远点越多的情况。 很多算法细节无法考证，并且八叉树在GPU 上不好表达，而且现在已经没人用这个算法了。 ","date":"2022-12-30","objectID":"/games104/:2:3","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Voxelization Based Global IIIumination(VXGI) 对于 GI 来说，是眼睛看到的区域最重要的部分，并且对于近处进行高精度采样，对远处进行低精度采样。 那么就是近距离的Voxel 很小，远处的 Voxel 很大，就行了。这种方法实现起来清晰明确简单，并且是 GPU 友好的。 trick1 循环UV，这样不会出错，但是不太懂这个的原理 trick2 按照距离来确定 Voxel 大小会导致屏幕空间上不管近远的 Voxel 大小都是几乎一致的。相当于 “地月距离和地日距离400倍，月球大小和太阳大小400倍，所以导致太阳月球看起来一样大。” 这样就很好,很一致！！ 那么光穿过 Voxel 能穿过多少呢？往往体素不是纯黑和纯透明的，而是有一定的透光率。 所以可以将体素中的实体投影到各个方向按照面积计算各个方向的透光率（三个方向） 那么就可以按照以下步骤来渲染 光线注入，计算每一个被直接照亮的 Voxel 对于屏幕上的每一个像素进行 Cone Tracing(可以不用每一个，可以 稀疏采样 + 加强采样) 基于 BRDF 生成采样圆锥，如果表面比较粗糙生成均匀的多个圆锥，如果表面比较光滑生成角度比较集中的圆锥 圆锥越远的时候使用 ClipMap 越上层的数据（近大远小） 光线传播累计不透明度，完全不透明后就不再传播 问题： 透明度累计时，直接计算乘法不合理，可能光经过一层左半遮挡，经过一层右半遮挡就全挡完了，但是乘法就还剩0.25，会产生漏光现象 在这种注入光子的思路中，该方法时集大成者！！！下面是另一种思路的算法，屏幕空间全局光照 ","date":"2022-12-30","objectID":"/games104/:2:4","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Screen Space Global IIIumination(SSGI) 最开始 在 GDC 上讲的方法，在计算反射时，例如光滑的地面反射墙壁，我们要渲染地面上的某个点，那么知道地面的法线，知道相机的方向，计算视线投射到地面时的出射方向即可，再利用这个方向去查询第一个碰到的物体。查询碰撞的方法可以使用GPU提供的屏幕空间的碰撞。 Hierachical Tracing DX12支持，他会自动将我的Z-buffer做成 mips，mip的下层都包裹着上层，然后利用类似二分的方法来做碰撞检测。大致思路是这样的，复杂度是log的，大致的思路是这样的，但是细节不清楚。 并且计算反射的 Light 是可以 Reuse 的，就是前一次光照得到点会成为后一次计算点的一个新的灯泡。大概理解，细节不理解。。。 优点：处理很光滑的物体，效果很好，有很多BUG，但是非常有用，处理很近的contact shadow，hit点很准，场景复杂度无关(仅基于深度图)，处理动态物体 ","date":"2022-12-30","objectID":"/games104/:2:5","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Lumen（重点，简称左脚踩右脚渲染） “Ray Tracing is slow” 所以需要 Lumen “Sampling is hard” 所以需要 Lumen Low-res filtered scene space probes lit full pexels ","date":"2022-12-30","objectID":"/games104/:3:0","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Phase1：Fast Ray Trace in Any Hardware Signed Distance Field(SDF) 有向距离场，物体的 外部为+，表面为0，内部为- SDF 和 顶点在本质上是对偶的 但是SDF 有很多优良性质 均匀的 连续的（可微的） 先对 Mesh 做SDF 再对空间做SDF SDF 支持统一的线性变换 对于很细的面，难以表达，所以稍微扩张一下 光纤可以很快的找到表面，光一步步向物体推进，当靠近表面时，SDF 会告诉我们应该走多大的步长，当到达表面时是0，当进入表面后，这个值是负数，又能够退回到表面。 做 Cone Tracing 时，可以预估目标的距离（按照圆的比值）：这个不懂 Mesh SDF LoD（多细节层次） SDF 导数是表面法线 做 MIP 节省40% 空间 Global SDF：将所有物体的SDF 合成一个低精度的场景的SDF 合成算法（由Mesh合成场景） 更新算法（物体是移动的） 总的来说就是，使用 SDF 来表达每一个Mesh 和场景，这样带来了很多计算上的好处，它能提高 Ray Tracing 的效率，从而不依赖于硬件的 Ray Tracing ","date":"2022-12-30","objectID":"/games104/:3:1","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Phase2 Radiance Injection and Caching 这一部分解决：如何抓住光的？ Mesh card 就以相机为原点，对场景中所有物体进行快照，记录该物体 AABB Box 对应的各个面的光照信息（法线，光照，自发光，等），并且这个快照是LoD的（近处高分辨率，远处低分辨率） Surface Cache：分配一个 4096x4096的空间，将每一个 Instance 的Card放到空间里，随着相机的移动，可能会替换（硬件提供方法来压缩），是对直接光照信息的一个表达（将光子固化在表面），在相机移动和物体移动时采用脏更新。 Lighting Cache Pipeline： 做逐像素的直接光照（做shadow map，不会错的离谱） 知道 Mesh 的各种光线相关的图，并且通过 SDF 可以很快的判断遮挡信息，所以可以很快的计算出直接光照图 对于多个光源，累加在一起即可 在场景中建立 Voxelize 表达，并且将当前帧的光照信息传递给下一帧 建立体素，来采样，本来我们的SDF是近距离精准，远距离模糊的，远距离模糊那怎么看有没有打到物体上呢？就应该使用 Global SDF， 但是 Global SDF 只能定位到像素点，而不能定位到具体某个 Instance。 Lumen的解决方法是：对于近处的物体，可以精准的拿到光照信息，对于远处的的物体：以相机为中心做一个 Voxelize的表达，然后 采样光线只要在Global SDF中Hit到了，就直接给那个位置的 Voxelize 的光照信息。 Lumen的具体方法： 做一个 ClipMap，四层，每一层 64x64，一个Voxel 是0.78米，每个Voxel的6个面存储亮度，这样在对某个点光照信息积分的时候，发出的光纤就能永远的cast到一个值，这里的 voxel 6个面是只有一个值，而不是光场。这里有点迷惑。那怎么来照亮别人呢？ 在下一帧中融合表面直接光照和由上一帧继承而来的光照图，得到真实光照 虽然每次都只做了一次bounce但是在数学上可以推导，实际上就是做了多次bounce（GAMES202 会推导） Tips:一些限制 直接光照不超过 1024x1024 texture 间接光照不超过 512x512 texture 选择页来更新，基于 Priority = LastUsed - LastUpdated ","date":"2022-12-30","objectID":"/games104/:3:2","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Phase3：Screen Probe structure 怎么区分布Prob，对于屏幕上的每一个点如何使用 Prob去lighting 采样使用八面体球面采样（几乎是均匀的），并且插值与球面几乎一致 屏幕空间放置采样点，有一个问题，就是真实的场景中相邻屏幕空间采样点可能是相距很远的。他们并不能很好的插值。 所以应该添加真实距离作为权重，而如果两个相距超过某个阈值，那么就应该申请细分探针数量 如果将屏幕空间的采样点打印出来，会发现所有几何变化较大的地方都会进行细分探针。 采样 需要进行importance sampling，就会出现黑一块白一块。 最重要的是，需要朝“窗户”的地方多射一点。怎么知道光在哪里呢？ 可以采集上一帧的光的位置（假设光的变化不是那么大） 采样的时候需要按照重要性分布来采样，也就是往光多的地方采样，并且重要性还与法向方向有关 巴拉巴拉，没听懂我操。直接听大概意思吧。不学了。 ","date":"2022-12-30","objectID":"/games104/:3:3","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"Phase4 拿到一个屏幕像素，如何使用Prob来做shading ","date":"2022-12-30","objectID":"/games104/:3:4","tags":null,"title":"Games104 笔记","uri":"/games104/"},{"categories":null,"content":"1. Dirichlet Conditions 一个周期内, 连续或者有有限个第一类间断点 一个周期内, 有限个极值点 一个周期内可积 ","date":"2022-12-30","objectID":"/fourier/:0:1","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"2. Trangle Transform 假设 $$ f(t) = c_0+\\sum_{n=1}^{\\infty}c_n\\cos(n \\omega t + \\varphi) =c_0+\\sum_{n=1}^{\\infty}[c_n\\cos\\varphi\\cos(n\\omega t)- c_n\\sin\\varphi \\sin(n\\omega t)] $$ 令 $a_n = c_n \\cos\\varphi,\\qquad b_n = -c_n\\sin\\varphi$ $$ f(t) = c_0+\\sum_{n=1}^{\\infty}[a_n\\cos(n\\omega t) + b_n \\sin(n\\omega t)]\\ \\int_0^T f(t)\\sin(k\\omega t) dt= \\int_0^Tc_0\\sin(k\\omega t) dt + \\int_0^T\\sin(k\\omega t)\\sum_{n=1}^{\\infty}[a_n\\cos(n\\omega t) + b_n \\sin(n\\omega t)] dt\\ \\int_0^T f(t)\\sin(n\\omega t) dt= 0 + b_n \\frac{T}{2}\\ b_n = \\frac{2}{T} \\int_0^T f(t)\\sin(n\\omega t) dt $$ 与 2 相似的可以计算得到 $c_n, a_n, \\varphi, c_0$ ","date":"2022-12-30","objectID":"/fourier/:0:2","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"3. Fourier 级数 根据欧拉公式: $$ e^{jx} = \\cos x + j\\sin x\\ \\cos(n\\omega t) = \\frac{e^{jn\\omega t} + e^{-jn\\omega t}}{2}\\ \\sin(n\\omega t) = \\frac{e^{jn\\omega t} - e^{-jn\\omega t}}{2j}\\ $$ (8) (9)代入(3) $$ f(t) = c_0+\\sum_{n=1}^{\\infty}[a_n \\frac{e^{jn\\omega t} + e^{-jn\\omega t}}{2} + b_n \\frac{e^{jn\\omega t} - e^{-jn\\omega t}}{2j}]\\ $$ 由于 : $$ a_n = \\frac{2}{T} \\int_0^T f(t)\\cos(-n\\omega t)dt = a_{-n}\\ 同理:-b_n = b_{-n} $$ 整理得到: $$ f(t) = c_0 + \\sum_{n=1}^{\\infty}[\\frac{a_n-jb_n}{2}e^{jn\\omega t} + \\ \\frac{a_{-n} - jb_{-n}}{2}e^{-jn\\omega t}]\\ f(t) = c_0 + \\sum_{n=1}^{\\infty}\\frac{a_n-jb_n}{2}e^{jn\\omega t} + \\sum_{n = -\\infty}^{-1} \\frac{a_n - jb_n}{2}e^{jn\\omega t}\\ 合并得到:\\ \\qquad\\qquad f(t) = \\sum_{n=-\\infty}^{\\infty}\\frac{a_n - jb_n}{2}e^{jn\\omega t}\\ 令:\\ \\qquad\\qquad A_n = \\frac{a_n - jb_n}{2}\\ f(t) = \\sum_{n=-\\infty}^{\\infty}A_ne^{jn\\omega t}\\ $$ 在 4. 中得到 Fourier 级数, 再两边同时 乘以 $e^{-jk\\omega t}$ 并在一个周期内积分得到: $$ \\int_{0}^{T}f(t)e^{-jn\\omega t}dt = \\int_{0}^{T}\\sum^{+\\infty}_{n = -\\infty}A_ne^{j(n-k)\\omega t}dt\\ \\int_0^Tf(t)e^{-jn\\omega t}dt = A_nT\\ A_n = \\frac{1}{T}\\int_0^Tf(t)e^{-jn\\omega t}dt $$ ","date":"2022-12-30","objectID":"/fourier/:0:3","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"4. Fourier Transform 1 $$ A_n = \\frac{1}{T}\\int_0^Tf(t)e^{-jn\\omega t}dt\\ F(\\omega) = \\lim_{T\\rightarrow \\infty}A_nT = \\int_0^\\infty f(t)e^{-jn\\omega t}dt\\qquad (Fourier Transform + )\\ \\lim_{T\\rightarrow \\infty}A_n = \\lim_{T\\rightarrow \\infty}\\frac{F(\\omega)}{T} = \\lim_{T\\rightarrow \\infty}\\frac{F(\\omega)\\cdot \\omega}{2\\pi}\\ $$ 结合 (19)(25) 得到 $$ f(t) = \\lim_{T\\rightarrow \\infty}\\sum^\\infty_{n=-\\infty}A_n e^{jn\\omega t} =\\lim_{T\\rightarrow \\infty}\\sum^\\infty_{n=-\\infty}\\frac{F(\\omega)\\cdot e^{jn\\omega t}}{2\\pi} d\\omega =\\frac{1}{2\\pi}\\int^\\infty_{-\\infty}F(\\omega)\\cdot e^{jn\\omega t}d\\omega \\qquad (Fourier Transform -)\\ $$ ","date":"2022-12-30","objectID":"/fourier/:0:4","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"5. Convolution Theorem 定理描述 $$ 设:f_1(t) 的Fourier变换为F_1(\\omega), f_2(t) 的Fourier变换为F_2(\\omega), \\ 那么:\\ 时域:\\ \\qquad\\qquad F[f_1(t)\\otimes f_2(t)] = F_1(\\omega)\\cdot F_2(\\omega)\\ 频域:\\ \\qquad\\qquad F[f_1(t)\\cdot f_2(t)] = \\frac{1}{2\\pi}F_1(\\omega)\\otimes F_2(\\omega)\\ $$ ","date":"2022-12-30","objectID":"/fourier/:0:5","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"6. Fourier 时移性质 $$ F[f(t)] = F(\\omega) \\qquad则: F[f(t - \\tau)] = F(\\omega)e^{-jn\\omega \\tau} $$ 证明: $$ F[f(t - \\tau)] = \\int^{+\\infty}{-\\infty}f(t-\\tau)e^{-jn\\omega t}dt\\ $$ 令 $x= t - \\tau:$ $$ F[f(t - \\tau)] = \\int^{+\\infty}{-\\infty}f(x)e^{-jn\\omega (x+\\tau)}dx =e^{jn\\omega\\tau}\\int^{+\\infty}_{-\\infty}f(x)e^{-jn\\omega x}dx = F(\\omega)\\cdot e^{jn\\omega\\tau} $$ ","date":"2022-12-30","objectID":"/fourier/:0:6","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"7. Convolution Theorem 证明 定义卷积运算 $$ f_1(t)\\otimes f_1(t) = \\int_{-\\infty}^{+\\infty}f_1(\\tau)f_2(t - \\tau)d\\tau\\ $$ 将 (35) 带入(24) $$ F[f_1(t)\\otimes f_1(t)] = \\int_{-\\infty}^{+\\infty}[\\int_{-\\infty}^{+\\infty}f_1(\\tau)f_2(t - \\tau)d\\tau]e^{-jn\\omega t}dt\\ = \\int_{-\\infty}^{+\\infty}f_1(\\tau)[\\int_{-\\infty}^{+\\infty}f_2(t - \\tau)e^{-jn\\omega t}dt]d\\tau \\qquad(调换积分顺序)\\ = \\int_{-\\infty}^{+\\infty}f_1(\\tau)F_2(\\omega)e^{-jn\\omega \\tau}d\\tau\\ = F_2(\\omega)\\cdot F_1(\\omega)\\ $$ ","date":"2022-12-30","objectID":"/fourier/:0:7","tags":null,"title":"傅里叶变换","uri":"/fourier/"},{"categories":null,"content":"决策树.html ","date":"2022-12-30","objectID":"/cart_tree/:0:0","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"导入相关库 pandas：决策树的构建涉及到数据集的一些操作，利用pandas的DataFrame数据结构可以很好方便的完成 copy :在递归时浅拷贝会导致问题,使用copy.deepcopy()进行深拷贝 matplot.pyplot:绘制决策树的划分图像 import pandas as pd import copy import matplotlib.pyplot as plt import numpy as np from math import fabs ","date":"2022-12-30","objectID":"/cart_tree/:0:1","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"导入数据 input = [[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]] ","date":"2022-12-30","objectID":"/cart_tree/:0:2","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"定义回归树的节点类Node attrList 节点剩下的属性列表 Dataset 节点划分到的数据集 left/right 左右子树 c 叶节点的预测值 description 该节点的描述（可选） attr 该节点划分属性 s 划分属性的值 考虑到使用非二叉树，在每次寻找最优化分的时候算法复杂度太高，所以此时使用二叉树就OK class Node: def __init__(self, description=\"\", c = -1, Dataset=pd.DataFrame(), attrList=[]): self.attrList = attrList self.Dataset = Dataset self.left = None self.right = None self.c = c self.attr = \"\" self.s = -1 self.desciption = description ","date":"2022-12-30","objectID":"/cart_tree/:0:3","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"计算损失 $$\\ell = \\sum_{x_i \\in R_1(j,s)}(y_i-c_1)^2+\\sum_{x_i \\in R_2(j,s)}(y_i-c_2)^2$$ def loss(attr, s, data): D1 = data[data[attr] \u003c= s] D1_mean = D1['label'].std() * D1.size D2 = data[data[attr] \u003e s] D2_mean = D2['label'].std() * D2.size return D1_mean + D2_mean ","date":"2022-12-30","objectID":"/cart_tree/:0:4","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"最小化损失 $$ \\min_{j,s} ( \\min_{c_1} \\sum_{x_i \\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i \\in R_2(j,s)}(y_i-c_2)^2 ) $$ 此处数据集不大 且 为了实现起来简单就是用了遍历所有属性的值找到最小的损失，应该还有一些方法可以优化找到最小值的过程 def findOptDiv(root): losses = [] for attr in root.attrList: for s in root.Dataset[attr]: losses.append((loss(attr, s, root.Dataset), attr, s)) minLoss = min(losses) return minLoss ","date":"2022-12-30","objectID":"/cart_tree/:0:5","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"二叉树的构建 在以下情况返回IF len(attrList) == 0：此时所有属性已经划分完毕， 就以该集合所有样本的label的均值作预测值 Dataset.size == 1：此时该节点的样本仅有一个 就 以该样本的label值做预测值 ELSE 将样本按最优划分划分为两个集合D1，D2，并分别构建subTree def buildTree(root): # if root.Dataset.size() \u003c= 1: # description = \"leaf node\" # c_p = root.Dataset['label'].mean() # leaf = Node(description=description, c = c_p) # 如果样本集合中只有一个样本那么该节点为叶节点，该叶节点的预测值是该唯一样本的label if root.Dataset.size == 1: root.c = root.Dataset['label'] return # 如果已经将属性分完了，那么该节点为叶节点，剩下的样本集中label的期望为该叶节点的预测值 elif len(root.attrList) == 0: root.description = \"leaf node\" root.c = root.Dataset['label'].mean() return else: # 找到最优化分 (_, attr, s) = findOptDiv(root) # 将节点的划分属性设为找到的attr root.attr = copy.deepcopy(attr) # 将按属性attr划分该节点值划分值s设为最优的s root.s = copy.deepcopy(s) # 将样本集合按照找到的最优化分划分为D1， D2 D1 = copy.deepcopy(root.Dataset[root.Dataset[attr] \u003c= s]) D2 = copy.deepcopy(root.Dataset[root.Dataset[attr] \u003e s]) # 将划分该节点属性从属性集合中删除 list_notremoved = copy.deepcopy(root.attrList) root.attrList.remove(attr) list_removed = copy.deepcopy(root.attrList) root.attrList = copy.deepcopy(list_notremoved) # 构建左子树和右子树 root.left = Node(Dataset = D1, attrList=copy.deepcopy(list_removed)) root.right = Node(Dataset = D2, attrList=copy.deepcopy(list_removed)) buildTree(root.left) buildTree(root.right) return root ","date":"2022-12-30","objectID":"/cart_tree/:0:6","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"预测函数 def predict(x, root): while(len(root.attrList) != 0): if x[root.attr] \u003c root.s: root = root.left else: root = root.right return root.c ","date":"2022-12-30","objectID":"/cart_tree/:0:7","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"评估函数 def evaluate(data_test, root): accuracy = 0 for i in range(len(data_test)): res = predict(data_test.loc[i], root) # 将回归问题转为分类问题 res = .5 if res \u003e .5 else 0 accuracy += fabs(res - data_test.loc[i][\"label\"]) return 1 - accuracy / len(data_test) data = pd.DataFrame(input, columns=['密度','含糖率',\"label\"]) root = Node(Dataset=data, attrList = ['密度','含糖率']) root = buildTree(root) ","date":"2022-12-30","objectID":"/cart_tree/:0:8","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"可以大致看出决策过程 先看含糖率： 小于.13 小于.666 坏瓜 大于.666 好瓜 大于.13 小于.697 0.6的概率是好瓜 大于.697 1的概率是好瓜 print(root.attr,root.s) print(root.left.attr,root.left.s,root.left.left.c,root.left.right.c) print(root.right.attr,root.right.s,root.right.left.c,root.right.right.c) 含糖率 0.103 密度 0.666 0.0 0.0 密度 0.697 0.6363636363636364 1.0 ","date":"2022-12-30","objectID":"/cart_tree/:0:9","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"可视化和评估模型表现 s1 = root.s s21 = root.left.s s22 = root.right.s plt.plot([.2,.8],[s1,s1],'r-') plt.plot([s21,s21],[0,s1],'r-') plt.plot([s22,s22],[s1,.5],'r-') for plot in input: if plot[2] == 0: c = 'red' else: c = 'green' plt.scatter(plot[0],plot[1],c=c) print(\"THE ACCURACY OF REGRESSION TREE IS {}\".format(evaluate(data, root))) THE ACCURACY OF REGRESSION TREE IS 0.6176470588235294 ","date":"2022-12-30","objectID":"/cart_tree/:1:0","tags":null,"title":"决策树","uri":"/cart_tree/"},{"categories":null,"content":"“哪里有压迫，哪里就有反抗。” —— 马克思，恩格斯 19世纪80年代，美国和欧洲各国发展到帝国主义阶段，为榨取更多剩余价值来刺激经济的高速发展，资本家不断增加劳动时间来剥削工人。工人运动就是在这个历史背景下开始的，在工人运动的压力下，美国政府被迫制定八小时工作制，这不过是一纸空文，资本根本不予理睬。 1884年5月1日，工人阶级在水深火热中忍无可忍，为了争取生存的权利，美国2万多个企业的35万工人停工上街，举行了声势浩大的示威游行，各种肤色，各个工种的工人一齐进行总罢工。仅芝加哥一个城市，就有4．5万名工人涌上街头。美国的主要工业部门瘫痪，火车变成了僵蛇，商店鸦雀无声，所有的仓库被贴上封条。 1889年7月14日，各国马克思主义者召集的社会主义者代表大会在法国巴黎隆重开幕。这次大会上，法国代表拉文提议：把1886年5月1日美国工人争取八小时工作制的斗争日，定为国际无产阶级的共同节日。与会代表一致同意，通过了这项具有历史意义的决议。 “无产者的历史是压迫和斗争中的历史，过去如此，现在也如此。” —— 我说的 随着工业不断地发展，工厂产物价值和品质提高，一些好心的 “工厂主”， 意识到过长劳动时间制造出劣质的产品损害品牌形象和直接利益，于是越来越多的工厂实行8小时工作制，工人有了休息和生活的时间，劳动所得自然也越来越多的用于生生存之外的消费。一个完美的闭环就此产生。现代西方国家8小时工作制的普及来源于此。 随着信息革命浪潮的到来，原本手工劳动和半手工劳动逐渐被自动化取代。以自动化程度最高的互联网行业来说 掌握核心技术的美国，互联网资本将简单重复的劳动外包到印度，中国等发展中国家，本国员工只做技术力高的设计工作，这样就能在本国实行8小时工作制，拉动本国消费，有空闲时间的员工还能不断提升技术，与被外包的发展中国家拉开越来越大的差距。 不掌握核心技术的中国，由于发展技术力或者开拓蓝海需要承担更多的沉没风险，并且巨大的市场已经不能带来用户量的提升，各大公司在红海中内卷，带来的就是各个公司普遍996，地方监管又是官商勾结。虽然劳动者获得了高新待遇，但是牺牲了生活的权利。 在更深层次的理解，996的本质不是剥削，因为人的精力总是有限的，资本家不是笨蛋，他们清楚会摸鱼划水普遍存在。更长的工作时间不能带来效率的提升，靠压榨剩余价值提高生产力的神话只存在于古老的手工业，996 的现代意义已经从剥削生产力变成了控制，只要在工作时间，就没办法安心的娱乐和生活。因此你不能和志同道合的朋友聚会并谈论创业计划、也不能从项目中抽离出来去生活、不能学习新的知识和磨练新的技术等，这些取代被压榨的生产力成为了现代意义下的剩余价值。 历史告诉现代资本家，无产者联合起来的力量多么巨大，他们和无产者讲自由和个性，他们用高薪引诱工作和消费，他们从内部瓦解无产者团结的力量，这就是他们通过少数者控制多数者的手段。他们妄想把自己包装成神话；他们说资本是弱者；他们从人民那里拿走许多，回报很少，却口口声声说这是福报；他们将工人物化，贬低劳动成果，还妄想用冠冕堂皇的道德欺骗人民。他们骑在人民头上指手画脚，用爱国主义情怀绑架人民，他们爱的国可不是我们的共和国！ 作为独立的个人，自然的有权利取追求生活、兴趣、娱乐，我们为国家的建设和生育率出力的前提是平等的工作机会、合理的工作时间、合适的工作报酬。革命时期纯粹的奉献主义精神在这个时代已经是年高德劭，不必要在和平年代牺牲大好青春，这是革命先烈用生命为我们换来的。但现状又如何呢？那些少数者大约确实从人民那儿偷走了些什么吧？ 有人告诉我“将现在的工作环境赖资本家有些不公允，这实际上是国家用土地政策谋取发展，用生娃/住房压力在逼迫年轻人努力工作”，诚然我们的国家要发展，政府用土地政策鞭策上一代人努力工作，成效斐然。建设祖国，年轻人义不容辞，只是有的资本家做生意做习惯了，不管干什么都要从中抽点剩余价值，还将矛盾转移到人民与政策之间。大抵确是有些无赖的。 ","date":"2022-12-30","objectID":"/log_ziben_996/:0:0","tags":null,"title":"资本 \u0026\u0026 996","uri":"/log_ziben_996/"},{"categories":null,"content":"由于本机需要运行游戏进程，再额外运行神经网络，这样做非常卷，所以使用一台额外的计算机来推理（在网吧直接开两台电脑🤡） 现在有两种数据传输的方案： ","date":"2022-12-30","objectID":"/ai_aim_0/:0:0","tags":null,"title":"AI 自瞄 | 分离计算-采集-控制","uri":"/ai_aim_0/"},{"categories":null,"content":"使用采集卡 能采集高帧率画面的采集卡售价已经超过1000RMB了，所以很不划算 将游戏主机记为 A，推理主机记为 B，该方案，A 只需要运行一个控制鼠标移动的小程序（几乎没有消耗，可以直接纯 Python实现），主机 A 需要捕获采集卡的视频，并且进行推理，将目标列表数据通过 TCP/UDP 传输到主机A。两台主机需要通过采集卡和RJ45连接 ","date":"2022-12-30","objectID":"/ai_aim_0/:0:1","tags":null,"title":"AI 自瞄 | 分离计算-采集-控制","uri":"/ai_aim_0/"},{"categories":null,"content":"进程间通信的方式 优点是成本低，只用连接一根网线，缺点是速度可能会慢） 该方法在主机A运行屏幕捕获和鼠标更新进程，在主机B运行推理进程 A-\u003eB : 剪裁后的 cv::Mat (320 x 320) B-\u003eA : 鼠标控制数据 以 90 fps的推理速度来计算 $$ data = \\frac{90 \\times 320 \\times 320 \\times 24}{8} = 27,648,000(B/s)=27,000(KB/s) = 26.4(MB/s) $$ 所以进程间 以网线连接 使用UDP 通信，需要保证26.4 MB/s 的上传速度，不清楚这会不会导致过度占用网卡，导致游戏进程掉包 本地两台 PC 之间的传输时延低于 1ms， 对于本应用可以忽略不计 我们考虑每一帧的情况 $$ data = \\frac{1 \\times 320 \\times 320 \\times 24}{8} = 307,200(B/frame)=300(KB/frame) = 0.293(MB/frame) $$ 传输方法 // send Mat img = imread(\"img/1.jpg\"); int imgSize = img.cols*img.rows*img.channels(); char *pos = (char*)img.data; int total = 0; while (total \u003c imgSize) { int sizelen = send(sockfd, pos+total, imgSize-total, 0); total = total + sizelen; } // recieve if ((connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1) { printf(\"accept socket error: %s(errno: %d)\",strerror(errno),errno); } char buf[320 * 320 * 3]; // 图片宽高 memset(buf, 0, sizeof(buf)); int total = 0; while(total \u003c 320 * 320 * 3) { long len = recv(connfd, buf+total, 320 * 320 * 3-total, 0); // 注意偏移量 total = total + len; } cout \u003c\u003c \"接收长度为: \" \u003c\u003c total \u003c\u003c endl; Mat img(320 * 320, CV_8UC3, buf); 在开始开发之前需要测试网络和性能瓶颈 时延计算 $$ timeDelay = grabTime + cropTime + TransportTime_1 + InferenceTime + TransportTime_2 $$ 使用一个ZeroMQ 的头文件only版本就行了（非常方便） 这样就能单机运行和多机运行了（设置启动脚本即可） tips: cppzmq 只是一个 c++ 的wrapper，其本质还是 基于c 的libzmq 使用cppzmq 需要先编译 libzmq，并且将 libzmq/include/zmq.h 和 cppzmq/* 添加到包含目录 将 libzmq/\u003cbuild_dir\u003e/lib/添加到库目录 将以下文件作为链接器输入 wsock32.lib ws2_32.lib Iphlpapi.lib libzmq-v143-mt-s-4_3_5.lib libzmq-v143-mt-4_3_5.exp testutil.lib testutil-static.lib unity.lib 经过测试，使用 cppzmq 在本地计算机能完成 1ms 内的数据传输，目标数据的传输需要使用 json 进行序列化！ ","date":"2022-12-30","objectID":"/ai_aim_0/:0:2","tags":null,"title":"AI 自瞄 | 分离计算-采集-控制","uri":"/ai_aim_0/"},{"categories":null,"content":" 欢迎来到我的小站呀，这里什么都没有，就交个朋友怎么样！🤝 ","date":"2022-12-30","objectID":"/about/:0:0","tags":null,"title":"关于我是谁这件事情","uri":"/about/"},{"categories":null,"content":"🏠 关于本站 记录我的所见所想，记录我努力实现每一个想法🧠 记录我一步一步靠近理想🔆 记录我正在努力的生活💕 ","date":"2022-12-30","objectID":"/about/:1:0","tags":null,"title":"关于我是谁这件事情","uri":"/about/"},{"categories":null,"content":"👨‍💻 博主是谁 Xuaii_ 小镇做题家，CS本科， Godot玩家，没有作品的游戏开发者 ","date":"2022-12-30","objectID":"/about/:2:0","tags":null,"title":"关于我是谁这件事情","uri":"/about/"},{"categories":null,"content":"⛹ 兴趣爱好 游戏✅，乒乓球❎，轮滑❎，游戏开发✅，小黄油✅ ","date":"2022-12-30","objectID":"/about/:3:0","tags":null,"title":"关于我是谁这件事情","uri":"/about/"},{"categories":null,"content":"🛻 Game Jam组队 特别想参加 Game Jam 但是没有志同道合的小伙伴🤦‍♂️，非常想组队但是社恐，不过山水总相逢，来日皆可期，总会遇见你们的🤡！ ","date":"2022-12-30","objectID":"/about/:4:0","tags":null,"title":"关于我是谁这件事情","uri":"/about/"},{"categories":null,"content":"📬 联系我呀 QQ: 1085036164 Email: herrn.xu@outlook.com ","date":"2022-12-30","objectID":"/about/:5:0","tags":null,"title":"关于我是谁这件事情","uri":"/about/"}]