{"posts":[{"title":"[æŒ–å‘] åŸºäºc++çš„åå°„å’Œè„šæœ¬ç³»ç»Ÿ","content":"c++ åå°„å®ç°èµ·æ¥å¥½åƒå¾ˆéº»çƒ¦ï¼Œæ‰€ä»¥å°±å¹²è„†å­¦ä¹ å’Œå€Ÿé‰´å·²æœ‰çš„æ–¹æ¡ˆCPP-Reflection-code ç¯å¢ƒæ­å»º å®‰è£… LLVM windows ä¸‹ç›´æ¥ä¸‹è½½ .exe ç‰ˆæœ¬å®‰è£…å³å¯ LLVM å®‰è£… Boost ä¸‹è½½ &amp;&amp; è§£å‹ å‹ç¼©åŒ… Boost æ‰“å¼€ x64 Native Tools Command Prompt for VS2022 åˆ‡æ¢åˆ°è§£å‹ç›®å½• &amp;&amp; è¿è¡Œ bootstrap.bat æŒ‰è¾“å‡ºæç¤º æ“ä½œ å°† LLVM-ROOT å’Œ BOOST-ROOT æ·»åŠ åˆ°ç¯å¢ƒå˜é‡ &amp;&amp; é‡å¯ç”Ÿæ•ˆ æŒ‰ç…§ README ç¼–è¯‘åˆ›å»º vs é¡¹ç›®(vs2022 ç”Ÿæˆå™¨å‚æ•°&quot;Visual Studio 17 2022&quot;) å¹¶ä¸”ç¼–è¯‘ æ‰“å¼€ Examples é¡¹ç›®ï¼Œé€‰æ‹©ä¸€ä¸ªæµ‹è¯•é¡¹ç›®ä½œä¸ºå¯åŠ¨é¡¹ï¼Œå¹¶ä¸”è¿è¡Œæµ‹è¯•ï¼ tips 1:æ›´æ¢CPP-REFLECTION é¡¹ç›®çš„ä¸­ json11.cpp å’Œ json11.hpp json11ï¼Œ ä¸æ˜ç™½æœ‰ä»£ç æœ‰bugä¸ºä»€ä¹ˆèƒ½è·‘èµ·æ¥ï¼Ÿ tips2:ä½¿ç”¨ Runtime éœ€è¦å°† Source\\Runtime\\Common å’Œ Source\\Common\\Lib ç›®å½•æ·»åŠ åˆ°é™„åŠ åŒ…å«ç›®å½•, éœ€è¦æ·»åŠ åˆ° Runtime çš„å¼•ç”¨ CPP-REFLECTION ç›®å½•ç»“æ„ Parser å„ç§è¯­è¨€å…ƒç´ ç±»å‹ï¼ˆç±»ï¼Œæ„é€ å‡½æ•°ï¼Œæšä¸¾ï¼ŒExternalï¼Ÿï¼Œå­—æ®µFieldï¼Œå‡½æ•°ï¼ŒGlobalï¼ŒInvokeableï¼Œ Methodï¼‰ï¼Œè¿™æ˜¯ç”¨äº è§£é‡ŠASTèŠ‚ç‚¹ å’Œ æ„é€ ä»£ç æ¸²æŸ“æ•°æ® ç±»å‹ã€‚ æ¨¡å— Moduleï¼ˆæ˜¯ä¸€ä¸ªä»£ç é›†åˆï¼Œå…¶ä¸­åŒ…å« classes ï¼Œ globalsï¼Œ globalfuncsï¼Œenums ä¸€ä¸ªè¯æ³•åˆ†æå™¨ï¼Ÿæ„ä¹‰ä¸æ˜ lang-cå‰ç«¯è¯­æ³•æ ‘æ¨¡å‹ CursorType ASTè¯­æ³•èŠ‚ç‚¹ç±»å‹ï¼ˆä¾‹å¦‚ å®šä¹‰ å£°æ˜ è¡¨è¾¾å¼ ç­‰ MetaDataConfig é…ç½®æ–‡ä»¶ MetaDataManager ç±»å‹ ç”¨äº GetProperty GetFlag GetNativeString MetaUtils å·¥å…·ç±»ï¼Œå¤„ç†å­—ç¬¦ä¸²ç­‰C++ä¸å¥½å¤„ç†çš„å†…ç‰¹å®¹ NameSpace åˆ—è¡¨ ç”¨äºå¤„ç†åµŒå¥—åå­—ç©ºé—´ é¢„ç¼–è¯‘ -&gt; include åˆ—è¡¨ ReflectionOptions åå°„å‚æ•° ReflectionParser ç”¨äºåˆ†æä»£ç  æå–éœ€è¦åå°„çš„ç±»ï¼Œæœ€åæ¸²æŸ“åå°„ä»£ç  æ¸²æŸ“æ¨¡æ¿è·¯å¾„ å¸¸é‡ Runtime Todo ä½¿ç”¨æ–¹æ³• è‡ªå®šä¹‰å±æ€§ enum class SliderType { Horizontal, Vertical } Meta(Enable); struct Slider : ursine::meta::MetaProperty { META_OBJECT; SliderType type; Slider(SliderType type) : type(type) { } } Meta(Enable); struct Range : ursine::meta::MetaProperty { META_OBJECT; float min, max; Range(float min, float max) : min(min) , max(max) { } } Meta(Enable); è‡ªå®šä¹‰è¢«åå°„ç±» #pragma once #include &lt;Meta.h&gt; #include &quot;TestProperties.h&quot; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;Array.h&gt; enum TestEnum { One, Two, Three, Four, Five, Eighty = 80 } Meta(Enable); struct SoundEffect { Meta(Range(0.0f, 100.0f), Slider(SliderType::Horizontal)) float volume; void Load(const std::string &amp;filename) { std::cout &lt;&lt; &quot;Loaded sound effect \\&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\\&quot;.&quot; &lt;&lt; std::endl; } } Meta(Enable); struct ComplexType { std::string stringValue; int intValue; float floatValue; double doubleValue; SoundEffect soundEffect; ursine::Array&lt;int&gt; arrayValue; TestEnum enumValue; ComplexType(void) = default; } Meta(Enable); è°ƒç”¨æ–¹æ³• #include &quot;TestReflectionModule.h&quot; #include &quot;TestTypes.h&quot; #include &quot;TestProperties.h&quot; #include &quot;TypeCreator.h&quot; using namespace ursine::meta; int main(void) { MetaInitialize( UsingModule( TestModule ) ); Type soundEffectType = typeof( SoundEffect ); Field volumeField = soundEffectType.GetField( &quot;volume&quot; ); // the runtime supports overloading, but by default returns the first overload Method loadMethod = soundEffectType.GetMethod( &quot;Load&quot; ); // creates an instance of a sound effect Variant effect = TypeCreator::Create( soundEffectType ); // effect.volume is now 85 volumeField.SetValue( effect, 85.0f ); // 85 -- can also use GetValue&lt;float&gt;( ) float volumeValue = volumeField.GetValue( effect ).ToFloat( ); std::cout &lt;&lt; &quot;SoundEffect.volume: &quot; &lt;&lt; volumeValue &lt;&lt; std::endl; // effect.Load is called loadMethod.Invoke( effect, std::string { &quot;Explosion.wav&quot; } ); return 0; } Reference CPP-Reflection-code CPP-Reflection-doc ","link":"https://xuaii.github.io/post/wa-keng-ji-yu-cde-fan-she-he-jiao-ben-xi-tong/"},{"title":"[æ‘˜æŠ„] æ²¡æœ‰è‰²å½©çš„å¤šå´ä½œå’Œä»–çš„å·¡ç¤¼ä¹‹å¹´","content":"â€”â€”æ‘ä¸Šæ˜¥æ ‘ ä½ è¦è®°å¾—é‚£äº›å¤§é›¨ä¸­ä¸ºä½ æ’‘ä¼â˜”çš„äºº å¸®ä½ æŒ¡ä½å¤–æ¥ä¹‹ç‰©çš„äººğŸ§± é»‘æš—ä¸­é»˜é»˜æŠ±ç´§ä½ ğŸ«‚çš„äºº é€—ä½ ç¬‘çš„äººğŸ¤¡ é™ªä½ å½»å¤œèŠå¤©ğŸŒƒğŸ’Œçš„äºº åè½¦ğŸš‰æ¥çœ‹æœ›ä½ çš„äºº é™ªä½ å“­è¿‡ğŸ˜¿çš„äºº åœ¨åŒ»é™¢é™ªä½ ğŸ¥çš„äºº æ€»æ˜¯ä»¥ä½ ä¸ºé‡ğŸ’€çš„äºº å¸¦ç€ä½ å››å¤„æ¸¸è¡çš„äºº è¯´æƒ³å¿µä½ çš„äººğŸ’• æ˜¯è¿™äº›äººç»„æˆä½ ç”Ÿå‘½ä¸­ä¸€ç‚¹ä¸€æ»´çš„æ¸©æš– æ˜¯è¿™äº›æ¸©æš–ä½¿ä½ è¿œç¦»é˜´éœ¾ æ˜¯è¿™äº›æ¸©æš–ä½¿ä½ æˆä¸ºå–„è‰¯ğŸ”†çš„äºº ","link":"https://xuaii.github.io/post/zhai-chao-mei-you-se-cai-de-duo-qi-zuo-he-ta-de-xun-li-zhi-nian/"},{"title":"[æŒ–å‘] åœ¨Godot ä¸­ä½¿ç”¨C++","content":"Reference GDNative è‡ªå®šä¹‰æœåŠ¡å™¨ å¤šçº¿ç¨‹ Mono ç»‘å®š GDExtension in 4.0 TSCNæ–‡ä»¶æ ¼å¼ ","link":"https://xuaii.github.io/post/zai-godot-zhong-shi-yong-c/"},{"title":"[Godot] ç¼“åŠ¨æ›²çº¿èŠ‚ç‚¹è®¾è®¡","content":"åŠ¨æœº Tween èŠ‚ç‚¹å¯ä»¥ç”¨äºåˆ›å»ºè¡¥é—´åŠ¨ç”»ï¼Œä½†æ˜¯ç”±äºåªèƒ½æŒ‡å®šå›ºå®šç¼“åŠ¨å‡½æ•°ï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨ value = f(time) çš„å½¢å¼è®¡ç®—å€¼ï¼Œæ‰€ä»¥éœ€è¦è®¾è®¡ä¸€ä¸ªæ–°çš„ç¼“åŠ¨å‡½æ•°ç±»ï¼Œå¹¶å®ç°å¯¹åº”çš„Inspectoræ’ä»¶ é€šå¸¸çš„ç¼“åŠ¨æ›²çº¿éƒ½æ˜¯é€‰ç”¨ ä¸‰è§’å‡½æ•°ï¼Œæˆ–è€…ä½¿ç”¨è´å¡å°”æ›²çº¿ç»˜åˆ¶çš„è‡ªå®šä¹‰æ›²çº¿ï¼Œä¸ºäº†é€¼è¿‘ç°å®çš„è¿åŠ¨æ„Ÿï¼Œè¿™é‡Œå®ç°ä¸€ç§è‡ªåŠ¨æ§åˆ¶ç³»ç»Ÿé‡Œå¸¸ç”¨çš„äºŒé˜¶æ›²çº¿ SecondOrderCurves è®¾è®¡ é¦–å…ˆæ—¶äºŒé˜¶ç³»ç»Ÿéœ€è¦çš„ä¸‰ä¸ªå‚æ•°ï¼Œåœ¨ Godot ä¸­ä½¿ç”¨ Vector3 è¡¨ç¤ºï¼Œ ä»¥åŠè¿ç®—è¿‡ç¨‹çš„ä¸­é—´å˜é‡ // ä½¿ç”¨æ’ä»¶ä¿®å¤ Godot ä¸è¯†åˆ«è‡ªå®šä¹‰ç±»å‹çš„ Bug [RegisteredTypeAttribute(nameof(SecondOrderCurves), &quot;&quot;, nameof(Godot.Object))] public class SecondOrderCurves : Godot.Object { [Export] public Vector3 Parameters = Vector3.One; private Vector2 xp; private Vector2 y, yd; private float k1, k2, k3; private float T_crit; // ç”¨äºå¤„ç†å•æ—¶é—´ç‰‡æ— æ³•å®Œæˆçš„æ¨¡æ‹Ÿ } äºŒé˜¶ç³»ç»Ÿçš„å‚æ•°åªæœ‰ä¸‰ä¸ªå˜é‡ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦ä¸€ä¸ªè¾“å…¥å‡½æ•° X(y), å’Œå¾—åˆ°ä¸€ä¸ªå“åº”å‡½æ•°Y(y)ï¼Œå…¶ä¸­è¾“å…¥å‡½æ•°æ˜¯å¿…é¡»çš„ï¼Œå®ƒå†³å®šä»¥æŸä¸€æ—¶åˆ»ç³»ç»Ÿçš„è¾“å…¥, è€Œå“åº”å‡½æ•°å¯ä»¥åœ¨æ¸¸æˆè¿è¡Œæ—¶å®æ—¶æ¨¡æ‹Ÿã€‚ // è¾“å…¥å‡½æ•°ç”±ä¸€äº›ç‚¹ç»„æˆï¼Œæ˜¯æŠ˜çº¿å‡½æ•° [Export] public Array&lt;Rect2&gt; points = new Array&lt;Rect2&gt;() { new Rect2(new Vector2(0, 300), new Vector2(10, 10)), new Rect2(new Vector2(200, 300), new Vector2(10, 10)), new Rect2(new Vector2(200, 150), new Vector2(10, 10)), new Rect2(new Vector2(400, 150), new Vector2(10, 10)), }; ç‚¹é›†æ˜¯ `X(t)` çš„ç¦»æ•£è¡¨ç¤ºï¼Œå¯¹äºè¿ç»­å€¼å¾—è¾“å…¥ï¼Œéœ€è¦åœ¨ä¸¤ä¸ªç‚¹ä¹‹é—´è¿›è¡Œæ’å€¼ï¼Œè¿™é‡Œç®€å•çš„é‡‡ç”¨çº¿æ€§æ’å€¼ public Vector2 Interpolate(float x) { for(int i = 0; i &lt; points.Count - 1; i++) { if(points[i].GetCenter().x &lt;= x &amp;&amp; x &lt;= points[i+1].GetCenter().x) { float y1 = points[i].GetCenter().y; float y2 = points[i+1].GetCenter().y; float x1 = points[i].GetCenter().x; float x2 = points[i+1].GetCenter().x; return new Vector2(x, (y1 - y2) / (x1 - x2) * (x - x2) + y2); } } return -1 * Vector2.One; } å¯¹äºæŸæ—¶åˆ» t ä¸€ä¸ª X(t) å¯¹åº”ä¸€ä¸ªX(t); ä¸ºäº†è®¡ç®— Y(t)ï¼Œè¿™é‡Œé‡‡ç”¨é€å¸§è®¡ç®—ï¼Œ // è¾“å…¥ X(t), å’Œ deltaï¼Œ å¾—åˆ°å½“å‰tæ—¶åˆ»çš„Y(t) public Vector2 Interpolate(Vector2 x, float delta) { Vector2 xd = (x - xp) / delta; xp = x; int iterations = Mathf.CeilToInt(delta / T_crit); // take extra iterations if delta &gt; T_crit delta = delta / iterations; for(int i = 0; i &lt; iterations; i++) { y = y + delta * yd; yd = yd + delta * (x + k3 * xd - y - k1*yd) / k2; } return y; } ç¼–è¾‘å™¨æ’ä»¶è®¾è®¡ å¯ä»¥å‚è€ƒ Godot.Curve çš„å®ç°ï¼Œä½†æ˜¯æ²¡æœ‰å¼€æ”¾ gdscript/c# æ¥å£ï¼Œåªèƒ½ä½¿ç”¨c++æ‹“å±•ï¼Œæ¯”è¾ƒç¹çï¼Œå°±è‡ªè¡Œå®ç°æ˜¾ç¤ºå’Œäº¤äº’é€»è¾‘ã€‚ ç¼–è¾‘å™¨ç»˜å›¾ ä¸ºäº†èƒ½åœ¨ç¼–è¾‘å™¨ä¸­çœ‹åˆ°æ•ˆæœï¼Œéœ€è¦åœ¨ç¼–è¾‘å™¨ç¯å¢ƒä¸­é¢„è§ˆå“åº”å‡½æ•° Y(t) çš„å½¢çŠ¶ã€‚æ‰€ä»¥ä½¿ç”¨ point_set å­˜å‚¨æ›²çº¿å€¼ï¼Œ è¡¨ç°æ•ˆæœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š // åªæœ‰æ ‡è®°ä¸º Tool çš„è„šæœ¬æ‰ä¼šåœ¨ç¼–è¾‘å™¨ç¯å¢ƒè¢«åŠ è½½ [Tool] public class CurveCanvas : Control { Array&lt;Vector2&gt; point_set = new Array&lt;Vector2&gt;(); Vector2 point_size = Vector2.One * 10; } æ¨¡æ‹Ÿæ¯å¸§çš„Y(t) è®¡ç®—ï¼š public void ReDraw(SecondOrderCurves curve = null) { // ç¼“å­˜ cached if(curve != null) { cachedCurve = curve; } else { return; } point_set.Clear(); Vector2 start = Transform(cachedCurve.StartPoint); Vector2 end = Transform(cachedCurve.EndPoint); if(start.x == -1 || end.x == -1 || cachedCurve == null) { return; } // points.Sort(new PointComp()); // Godot.Collection.Array ä¸æ”¯æŒæ’åºï¼Œéœ€è¦å®ç°ä¸€ä¸‹ cachedCurve.Init(start); int iter = 200; for(int i = 0; i &lt; iter; i++) { Vector2 x = Transform(cachedCurve.Interpolate(cachedCurve.StartPoint.x + i* (cachedCurve.EndPoint.x - cachedCurve.StartPoint.x) / iter)); Vector2 point = cachedCurve.Interpolate(new Vector2(x.y, x.y), 0.01f); point_set.Add(new Vector2(x.x * RectSize.x, (1 - point.x) * RectSize.y)); } Update(); } ç”±äº Godot æ˜¯ä»¥å³ä¸‹ä¸ºæ­£ï¼Œæ‰€ä»¥éœ€è¦å¯¹åæ ‡è¿›è¡Œè½¬æ¢ private Vector2 Transform(Vector2 point) { return new Vector2(point.x / RectSize.x, (RectSize.y - point.y) / RectSize.y); } ä½¿ç”¨ Godot çš„ç»˜å›¾å‡½æ•° public override void _Draw() { // å…·ä½“å°±ä¸å±•ç¤ºäº†ï¼Œæ˜¯ä¸€äº›ç¹ççš„ä»£ç  DrawMesh(); DrawPoints(); DrawCurve(); DrawInteractive(); } ç¼–è¾‘å™¨äº¤äº’ ä¸ºäº†èƒ½å¤Ÿæ·»åŠ /ç§»åŠ¨/åˆ é™¤å›¾åƒä¸Šçš„ç‚¹ï¼Œ éœ€è¦å®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š å•å‡»é¼ æ ‡å·¦é”®æ·»åŠ ç‚¹ é•¿æŒ‰é¼ æ ‡å·¦é”®ç§»åŠ¨ç‚¹ å•æœºé¼ æ ‡å³é”®åˆ é™¤ç‚¹ public override void _Process(float delta) { cover_index = cachedCurve.FindPoint(GetLocalMousePosition()); SafeDragingArray = new Rect2(GetRect().Position, GetRect().Size - Vector2.One * 10); // é€€å‡ºæ‹–åŠ¨çš„è°ƒèŠ‚ if(Dragging &amp;&amp; IsMouseIn &amp;&amp; 0 &lt;= DraggingIndex&amp;&amp; DraggingIndex &lt; cachedCurve.points.Count &amp;&amp; SafeDragingArray.HasPoint(GetLocalMousePosition())) { (cachedCurve.points[DraggingIndex]) = new Rect2(GetLocalMousePosition(), point_size); } Update(); } ç›‘å¬é¼ æ ‡è¾“å…¥ï¼Œåœ¨Godot ä¸­è¿æ¥ CurveCanvas çš„é¼ æ ‡ä¿¡å· void _on_CurveCanvas_gui_input(InputEvent @event) { if(!IsMouseIn) { return; } if(@event is InputEventMouseButton mouse) { if(mouse.ButtonIndex == (int)ButtonList.Left) { // 1. åˆ›å»ºèŠ‚ç‚¹ if(cover_index == -1 &amp;&amp; !mouse.Pressed &amp;&amp; !Dragging) { cachedCurve.points.Add(new Rect2(GetLocalMousePosition(), point_size)); } // 2. å¼€å§‹æ‹–åŠ¨ if(cover_index != -1 &amp;&amp; mouse.Pressed) { Dragging = true; DraggingIndex = cover_index; } // 3. ç»“æŸæ‹–åŠ¨ if(!mouse.Pressed) { if(Dragging) ReDraw(); Dragging = false; DraggingIndex = -1; } ReDraw(); } if(mouse.ButtonIndex == (int)ButtonList.Right) { // åˆ é™¤å½“å‰ cover çš„èŠ‚ç‚¹ if(cover_index != -1 &amp;&amp; !mouse.Pressed) { cachedCurve.points.RemoveAt(cover_index); } ReDraw(); } } } ç¼–è¾‘å™¨æ’ä»¶ï¼ˆè¸©å‘ï¼‰ Godot çš„ç¼–è¾‘å™¨æ’ä»¶åŠŸèƒ½éå¸¸å¤šï¼Œå¯ä»¥æ·»åŠ Dockï¼ŒInspectorï¼Œä¸»å±å¹•ï¼Œç­‰æ’ä»¶ã€‚å‡ ä¹å¯ä»¥å®ç°ç¼–è¾‘å™¨é˜¶æ®µçš„çš„æ‰€æœ‰æ‹“å±•ï¼›è¿™é‡Œæˆ‘ä»¬ä¸»è¦ä½¿ç”¨ Inspector æ’ä»¶æ¥ç¼–è¾‘ SecondOrderCurves.parameters. plugin.cs é¦–å…ˆåœ¨ plugin.cs ä¸­æ·»åŠ åŠ è½½/åˆ é™¤ CurveEditorInspector çš„ä»£ç  tips: åƒä¸‡ä¸èƒ½å¿˜è®°æ·»åŠ [Tool]ï¼Œç¬¬ä¸€æ¬¡ Build æ—¶ä¼šæŠ¥é”™ï¼Œç„¶åå†Buildä¸€æ¬¡å°±Okäº†ï¼ŒåŸå› æ˜¯ C# æ˜¯éœ€è¦ç¼–è¯‘çš„è€Œgdscriptå¯ä»¥çƒ­æ›´æ–°ï¼Œæ‰€ä»¥å¹²å„¿å­è€…ä¸å¦‚äº²å„¿å­ã€‚ #if TOOLS using Godot; using System; [Tool] public class plugin : EditorPlugin { CurveEditorInspector inspector; public override void _EnterTree() { inspector = GD.Load&lt;CSharpScript&gt;(&quot;res://addons/curve_editor/CurveEditorInspector.cs&quot;).New() as CurveEditorInspector; AddInspectorPlugin(inspector); } public override void _ExitTree() { RemoveInspectorPlugin(inspector); } } #endif EditorInspectorPlugin.cs EditorInspectorPlugin æ˜¯ä¸€ä¸ªå¤§å‘ï¼Œå®ƒæœ‰ä¸¤ç§ä¸»è¦çš„è¿è¡Œæ¨¡å¼ï¼š ä¿®æ”¹å•å±æ€§ ä¿®æ”¹å¤šå±æ€§ èµ·åˆæˆ‘ä¸æ˜ç™½ AddPropertyEditor å’Œ AddPropertyEditorForMultipleProperties æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Œä»–ä»¬ä¼¼ä¹å…·æœ‰ç›¸ä¼¼çš„è¡Œä¸ºã€‚åæ¥ç†è§£äº†ï¼Œåœ¨ AddPropertyEditorForMultipleProperties ä¸­æŒ‡å®šçš„å±æ€§ååˆ—è¡¨å’Œåœ¨AddPropertyEditor ä¸­æŒ‡å®šå±æ€§åï¼Œè¿™æ ·Godotå°±ä¼šçŸ¥é“éœ€è¦åºåˆ—åŒ–å“ªäº›å­—æ®µï¼Œå¹¶ä¸”åœ¨æ¥å›åˆ‡æ¢çª—å£æˆ–è€…å……æ°”Godotåï¼Œå·²ç»è¢«ç¼–è¾‘çš„å±æ€§èƒ½å¤Ÿä¸è¢«é‡ç½®ã€‚ using Godot; using System; #if TOOLS public class CurveEditorInspector : EditorInspectorPlugin { public override bool CanHandle(Godot.Object @object) { if(@object is SecondOrderCurves) { AddPropertyEditorForMultipleProperties(&quot;&quot;, new string [] {&quot;F&quot;, &quot;Z&quot;, &quot;R&quot;}, new CurveEditorProperty()); return true; } return false; } public override bool ParseProperty(Godot.Object @object, int type, string path, int hint, string hintText, int usage) { return false; } } #endif CurveEditorProperty.cs è¿™é‡Œéœ€è¦æŒ‡å‡ºçš„æ˜¯ï¼ŒGodotè§„å®šä¿®æ”¹å±æ€§å€¼ä¸èƒ½ç›´æ¥ä¿®æ”¹ åªèƒ½é€šè¿‡ EmitChanged(property_name, property value); æ¥ä¿®æ”¹ï¼Œè¯¥ä¿¡å·ä¼šå›è°ƒUpdateProperty()æ–¹æ³•ï¼Œè¿™é‡Œå¯ä»¥è®¿é—®åˆ°è¢«ä¿®æ”¹çš„å¯¹è±¡(GetEditedObject())å’Œè¢«ä¿®æ”¹å¯¹è±¡çš„å±å(GetEditedProperty()); å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒGodot ä¼šåœ¨æ¯ä¸€æ­¤æ‰“å¼€Inspector æ—¶è°ƒç”¨UpdateProperty(),è¿™ä¹‹å‰ä¼šé‡æ–°åˆ›å»ºå¹¶ä¸”åŠ è½½Inspector æ’ä»¶å¯¹è±¡ï¼Œæ‰€ä»¥éœ€è¦é€šè¿‡è¢«ç¼–è¾‘å¯¹è±¡æ¥æ¢å¤ç¼–è¾‘å™¨é¢„è§ˆå‚æ•°ï¼Œå¹¶ä¸”ä½¿ç”¨IsInit ä¿è¯ä»…è°ƒç”¨ä¸€æ¬¡; using Godot; using System; #if TOOLS public class CurveEditorProperty : EditorProperty { Control editor; SecondOrderCurves CacheCurve = null; bool IsInit = false; // ç¼“å­˜è¢«ç¼–è¾‘å¯¹è±¡ public override void _Ready() { editor = GD.Load&lt;PackedScene&gt;(&quot;res://addons/curve_editor/CurveEditor.tscn&quot;).Instance&lt;Control&gt;(); AddChild(editor); AddFocusable(editor); SetBottomEditor(editor); editor.Connect(&quot;PorpertyChanged&quot;, this, &quot;OnPorpertyChanged&quot;); editor.Call(&quot;Load&quot;); } void OnPorpertyChanged(Vector3 _parameters) { EmitChanged(&quot;parameters&quot;, _parameters); } public override void UpdateProperty() { if(!IsInit) { editor.Call(&quot;Load&quot;, GetEditedObject().Get(&quot;parameters&quot;)); IsInit = true; } editor.Call(&quot;Refresh&quot;, GetEditedObject()); } } #endif CurveEditor.cs è¯¥è„šæœ¬ç”¨äºæ€»ç»“ä¸‰ä¸ªHSliderçš„å˜åŒ–,å¹¶ä¸”ç”ŸæˆPorpertyChanged äº‹ä»¶ using Godot; using System; // è¿™é‡Œçš„toolä¸èƒ½ç¼ºå°‘ [Tool] public class CurveEditor : VBoxContainer { [Signal] public delegate void PorpertyChanged(Vector3 _parameters); // move point Vector3 parameters; public void Load(Vector3 parameters) { (GetNode(&quot;F/FHSlider&quot;) as HSlider).Value = (double)parameters.x; (GetNode(&quot;Z/ZHSlider&quot;) as HSlider).Value = (double)parameters.y; (GetNode(&quot;R/RHSlider&quot;) as HSlider).Value = (double)parameters.z; } public void Refresh(SecondOrderCurves curve) { CurveCanvas canvas = GetNode&lt;CurveCanvas&gt;(&quot;CurveCanvas&quot;); canvas.ReDraw(curve); } public void _on_FHSlider_value_changed(float value) { parameters.x = value; EmitSignal(&quot;PorpertyChanged&quot;, parameters); } public void _on_ZHSlider_value_changed(float value) { parameters.y = value; EmitSignal(&quot;PorpertyChanged&quot;, parameters); } public void _on_RHSlider_value_changed(float value) { parameters.z = value; EmitSignal(&quot;PorpertyChanged&quot;, parameters); } } Show Show Way æœ€åå±•ç¤ºä¸€ä¸‹è¿è¡Œæ•ˆæœ ","link":"https://xuaii.github.io/post/godot-huan-dong-qu-xian-jie-dian-she-ji/"},{"title":"æ¸¸æˆåŠ¨ç”»ä¸­çš„ç¼“åŠ¨å‡½æ•°","content":"æƒ…æ™¯å¼•å…¥ è€ƒè™‘ä»¥ä¸‹æƒ…å½¢ï¼Œé‡‡é›†ç”¨æˆ·æ°´å¹³è¾“å…¥ float HorizontalInput æ¥æ§åˆ¶ player çš„æ°´å¹³ä½ç§» void Update(float delta) { velocity.x = HorizontalInput * WalkSpeed * delta; } è¿™æ ·å†™æœ‰ä¸¤ä¸ªç¼ºç‚¹ï¼š å½“å½±å“æ°´å¹³é€Ÿåº¦çš„å› ç´ ä¸åªæ˜¯æ°´å¹³è¾“å…¥æ—¶ï¼Œä¸åŒå› ç´ çš„å åŠ ä¸æ–¹ä¾¿ã€‚ä¸åº”è¯¥æ˜¯ = è€Œåº”è¯¥æ˜¯ +=; ç§»åŠ¨å®Œå…¨ä¸è¾“å…¥ä¸€ç›´ï¼Œçœ‹èµ·æ¥å¾ˆåƒµç¡¬ï¼› è§£å†³æ–¹æ¡ˆ æ‰€ä»¥éœ€è¦æœ‰è¿™ä¹ˆä¸€ä¸ªå‡½æ•°(ç¼“åŠ¨å‡½æ•°)ï¼Œå®ƒå¯¹è¾“å…¥çš„å“åº”ç”±å¯æ§çš„å»¶è¿Ÿï¼Œä½†æœ€ç»ˆä¼šä¸è¾“å…¥ä¿æŒä¸€è‡´ // æ·»åŠ ç¤ºä¾‹å‡½æ•°1.1 ä¸ºäº†ä½¿ç¼“åŠ¨æ›²çº¿æ›´å¥½çš„æ¨¡æ‹Ÿç°å®ä¸–ç•Œä¸­ç”±äºåŠ›äº§ç”ŸåŠ é€Ÿåº¦çš„è¿åŠ¨ï¼Œè¿™é‡Œä½¿ç”¨ä¸€ä¸ªäºŒé˜¶ç³»ç»Ÿæ¥æè¿°ï¼š y+k1â‹…yâ€²+k2â‹…yâ€²â€²=x+k3â‹…xâ€²y + k_1\\cdot y^{&#x27;} + k_2\\cdot y^{&#x27;&#x27;} = x + k_3 \\cdot x^{&#x27;} y+k1â€‹â‹…yâ€²+k2â€‹â‹…yâ€²â€²=x+k3â€‹â‹…xâ€² ç­‰ä»·çš„å†™æ³•ï¼š y+k1â‹…dydt+k2â‹…d2yd2t=x+k3â‹…dxdty + k_1\\cdot \\frac{\\mathrm{d} y}{\\mathrm{d} t} + k_2\\cdot \\frac{\\mathrm{d} ^2 y}{\\mathrm{d}^2 t} = x + k_3 \\cdot \\frac{\\mathrm{d} x}{\\mathrm{d} t} y+k1â€‹â‹…dtdyâ€‹+k2â€‹â‹…d2td2yâ€‹=x+k3â€‹â‹…dtdxâ€‹ é€šè¿‡è°ƒæ•´ k1,k2,k3k_1, k_2,k_3k1â€‹,k2â€‹,k3â€‹ å¯ä»¥æ”¹å˜å›¾åƒçš„å½¢çŠ¶ï¼Œ // æ’å…¥ç¤ºä¾‹å›¾åƒ1.2 ç°åœ¨æ·»åŠ ä¸‰ä¸ªå˜é‡ï¼š f=12Ï€k2,Î¸=k12k2,r=2k3k1f = \\frac{1}{2\\pi \\sqrt{k_2}}, \\quad \\theta = \\frac{k_1}{2\\sqrt{k_2}}, \\quad r = \\frac{2k_3}{k_1} f=2Ï€k2â€‹â€‹1â€‹,Î¸=2k2â€‹â€‹k1â€‹â€‹,r=k1â€‹2k3â€‹â€‹ è§£æ–¹ç¨‹ç»„å¯å¾—ï¼š k1=Î¸Ï€f,k2=1(2Ï€f)2,k3=rÎ¸2Ï€fk_1 = \\frac{\\theta}{\\pi f}, \\quad k_2 = \\frac{1}{(2\\pi f)^2}, \\quad k_3 = \\frac{r \\theta}{2\\pi f} k1â€‹=Ï€fÎ¸â€‹,k2â€‹=(2Ï€f)21â€‹,k3â€‹=2Ï€frÎ¸â€‹ åŸäºŒé˜¶ç³»ç»Ÿçš„å¾®åˆ†æ–¹ç¨‹å˜ä¸ºï¼š y+Î¸Ï€fâ‹…yâ€²+1(2Ï€f)2â‹…yâ€²â€²=x+rÎ¸2Ï€fâ‹…xâ€²y +\\frac{\\theta}{\\pi f} \\cdot y^{&#x27;} + \\frac{1}{(2\\pi f)^2} \\cdot y^{&#x27;&#x27;} = x + \\frac{r \\theta}{2\\pi f} \\cdot x^{&#x27;} y+Ï€fÎ¸â€‹â‹…yâ€²+(2Ï€f)21â€‹â‹…yâ€²â€²=x+2Ï€frÎ¸â€‹â‹…xâ€² è¿™é‡Œ f,Î¸,rf, \\theta, rf,Î¸,r éƒ½å…·æœ‰ç°å®æ„ä¹‰äº† fff ä»¥ hzhzhz ä¸ºå•ä½ï¼Œä»£è¡¨ç³»ç»Ÿå›ºæœ‰é¢‘ç‡ï¼Œå®ƒæè¿°ç³»ç»Ÿå¯¹è¾“å…¥å˜åŒ–çš„å“åº”é€Ÿåº¦ Î¸\\thetaÎ¸ ä»£è¡¨ç³»ç»Ÿçš„é˜»å°¼ç³»æ•°ï¼Œæè¿°äº†ç³»ç»Ÿå¦‚ä½•æœ€ç»ˆè¶‹äºç¨³å®š rrr æ§åˆ¶ç³»ç»Ÿçš„åˆå§‹å“åº” å½“ r=0r = 0r=0 æ—¶ç³»ç»Ÿéœ€è¦èŠ±è´¹ä¸€ç‚¹æ—¶é—´æ‰èƒ½ä»ç¦æ­¢å¼€å§‹åŠ é€Ÿ å½“ r&gt;0r &gt; 0r&gt;0 æ—¶ç³»ç»Ÿç«‹åˆ»å¯¹å˜åŒ–åšå‡ºååº” å½“ r&gt;1r &gt; 1r&gt;1 æ—¶ç³»ç»Ÿå˜åŒ–å°†å†²è¿‡ç›®æ ‡ å½“ r&lt;0r &lt; 0r&lt;0 æ—¶ç³»ç»Ÿä¼šæœ‰æŠ¬æ‰‹è¿åŠ¨ï¼ˆå…ˆåå‘è¿åŠ¨ï¼‰ ä¸€èˆ¬ä¸ºæœºæ¢°é“¾æ¥è®¾ç½® r=2r = 2r=2 ç°åœ¨åªå‰©ä¸‹æœ€åä¸€ä¸ªé—®é¢˜äº†ï¼Œå¦‚ä½•è§£äºŒé˜¶ç³»ç»Ÿï¼Ÿ äºŒé˜¶å¾®åˆ†æ–¹ç¨‹æ•°å€¼è§£ 1. åŠéšå¼æ¬§æ‹‰æ³• è¯¥æ–¹æ³•åœ¨è¯¥é—®é¢˜ä¸‹ä¸å¤æ‚çš„ Verlet ç§¯åˆ†æ³• æœ‰ç€ç›¸åŒçš„ç²¾åº¦ï¼Œ é¦–å…ˆè®¡ç®— x å˜åŒ–ç‡ xn+1â€²=xn+1âˆ’xnTx^{&#x27;}_{n+1} = \\frac{x_{n+1} - x_n}{T} \\\\ xn+1â€²â€‹=Txn+1â€‹âˆ’xnâ€‹â€‹ ç„¶åè®¡ç®— y çš„å˜åŒ– {yn+1=yn+Tynâ€²yn+1â€²=ynâ€²+Tyâ€²â€²\\begin{cases} y_{n + 1} = y_{n} + Ty^{&#x27;}_{n} \\\\ \\quad\\\\ y^{&#x27;}_{n+1} = y^{&#x27;}_{n} + Ty^{&#x27;&#x27;} \\\\ \\end{cases} â©âªâ¨âªâ§â€‹yn+1â€‹=ynâ€‹+Tynâ€²â€‹yn+1â€²â€‹=ynâ€²â€‹+Tyâ€²â€²â€‹ ç”±äº: yâ€²â€²=x+k3xâ€²âˆ’yâˆ’k1yâ€²k2y^{&#x27;&#x27;} = \\frac{x + k_3 x^{&#x27;} - y - k_1y^{&#x27;}}{k_2} yâ€²â€²=k2â€‹x+k3â€‹xâ€²âˆ’yâˆ’k1â€‹yâ€²â€‹ æ‰€ä»¥ï¼š yn+1â€²=ynâ€²+Tâ‹…xn+1+k3xn+1â€²âˆ’yn+1âˆ’k1ynâ€²k2y^{&#x27;}_{n+1} = y^{&#x27;}_{n} + T\\cdot \\frac{x_{n+1} + k_3 x^{&#x27;}_{n+1} - y_{n+1} - k_1y^{&#x27;}_{n}}{k_2} yn+1â€²â€‹=ynâ€²â€‹+Tâ‹…k2â€‹xn+1â€‹+k3â€‹xn+1â€²â€‹âˆ’yn+1â€‹âˆ’k1â€‹ynâ€²â€‹â€‹ è¿™å­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœé¢‘ç‡ fff è¿œå¤§äºå¸§ç‡ï¼Œç³»ç»Ÿå°†å˜å¾—ä¸ç¨³å®šï¼Œä¼šäº§ç”Ÿæ— ç©·å¤§çš„å€¼ï¼š å¯ä»¥ç®€å•åœ°è®¾ç½® f çš„å–å€¼èŒƒå›´ é€šè¿‡æ•°å­¦æ–¹æ³•ç¡®ä¿ä¸å‘ç”Ÿæç«¯æƒ…å†µ ä¸ºäº†æä¾›æ›´å¤šçš„é²æ£’æ€§ï¼Œé‡‡ç”¨æ–¹æ¡ˆäºŒ åˆ†æ ä¸ç¨³å®šäº§ç”Ÿçš„åŸå› ï¼Œè¯¥ç³»ç»Ÿçš„æœ¬è´¨æ˜¯åé¦ˆç³»ç»Ÿï¼Œä»–çš„è¿­ä»£è¾“å‡ºå°†è¢«åé¦ˆåˆ°åç»­çš„è¿­ä»£ç”¨äºè®¡ç®—ï¼Œå½“å¸§é—´æ—¶é—´æ­¥é•¿å’Œå‚æ•°ç›¸æ¯”å¤ªå¤§æ—¶ï¼Œéšç€æ—¶é—´å¢åŠ ï¼Œè¯¯å·®å°†é€æ¸ç´¯ç§¯ï¼Œå½“è¶…è¿‡æŸä¸ªä¸´ç•Œå€¼æ—¶ï¼Œè¯¯å·®ä¼šå¼€å§‹æ»šé›ªçƒï¼Œè¿…é€Ÿå¯¼è‡´ç¾éš¾æ€§åæœï¼Œä¸ºäº†è®¡ç®—è¯¥ä¸´ç•Œå€¼ï¼Œå¼•å…¥çº¿æ€§ä»£æ•°æ–¹æ³•ï¼š {yn+1=yn+Tynâ€²yn+1â€²=ynâ€²+Tâ‹…xn+1+k3xn+1â€²âˆ’(yn+Tynâ€²)âˆ’k1ynâ€²k2\\begin{cases} y_{n + 1} = y_{n} + Ty^{&#x27;}_{n} \\\\ \\quad \\\\ y^{&#x27;}_{n+1} = y^{&#x27;}_{n} + T\\cdot \\frac{x_{n+1} + k_3 x^{&#x27;}_{n+1} -(y_{n} + Ty^{&#x27;}_{n}) - k_1y^{&#x27;}_{n}}{k_2} \\end{cases} â©âªâ¨âªâ§â€‹yn+1â€‹=ynâ€‹+Tynâ€²â€‹yn+1â€²â€‹=ynâ€²â€‹+Tâ‹…k2â€‹xn+1â€‹+k3â€‹xn+1â€²â€‹âˆ’(ynâ€‹+Tynâ€²â€‹)âˆ’k1â€‹ynâ€²â€‹â€‹â€‹ å±•å¼€åˆå¹¶åŒç±»é¡¹ï¼š {yn+1=yn+Tynâ€²yn+1â€²=âˆ’Tk2yn+k2âˆ’T2âˆ’Tk1k2ynâ€²+Tk2xn+1+Tk3k2xn+1â€²\\begin{cases} y_{n + 1} = y_{n} + Ty^{&#x27;}_{n} \\\\ \\quad \\\\ y^{&#x27;}_{n+1} = \\frac{-T}{k_2} y_n + \\frac{k_2 - T^2 - Tk_1}{k_2}y^{&#x27;}_{n} + \\frac{T}{k_2}x_{n+1} + \\frac{Tk_3}{k_2}x^{&#x27;}_{n+1}\\\\ \\end{cases} â©âªâ¨âªâ§â€‹yn+1â€‹=ynâ€‹+Tynâ€²â€‹yn+1â€²â€‹=k2â€‹âˆ’Tâ€‹ynâ€‹+k2â€‹k2â€‹âˆ’T2âˆ’Tk1â€‹â€‹ynâ€²â€‹+k2â€‹Tâ€‹xn+1â€‹+k2â€‹Tk3â€‹â€‹xn+1â€²â€‹â€‹ çŸ©é˜µè¡¨ç¤ºå¦‚ä¸‹ï¼š [yyâ€²]n+1=[1Tâˆ’Tk2k2âˆ’T2âˆ’Tk1k2]â‹…[yyâ€²]n+[00Tk2Tk3k2]â‹…[xxâ€²]n+1\\begin{bmatrix} y\\\\ y^{&#x27;} \\end{bmatrix}_{n+1} = \\begin{bmatrix} 1 &amp; T\\\\ -\\frac{T}{k_2} &amp; \\frac{k_2 - T^2 - Tk_1}{k_2} \\end{bmatrix} \\cdot \\begin{bmatrix} y\\\\ y^{&#x27;} \\end{bmatrix}_{n} + \\begin{bmatrix} 0 &amp; 0\\\\ \\frac{T}{k_2} &amp; \\frac{Tk_3}{k_2} \\end{bmatrix} \\cdot \\begin{bmatrix} x\\\\ x^{&#x27;} \\end{bmatrix}_{n+1} [yyâ€²â€‹]n+1â€‹=[1âˆ’k2â€‹Tâ€‹â€‹Tk2â€‹k2â€‹âˆ’T2âˆ’Tk1â€‹â€‹â€‹]â‹…[yyâ€²â€‹]nâ€‹+[0k2â€‹Tâ€‹â€‹0k2â€‹Tk3â€‹â€‹â€‹]â‹…[xxâ€²â€‹]n+1â€‹ ç®€å†™å¦‚ä¸‹ Yn+1=Aâ‹…Yn+Bâ‹…Xn+1Y_{n+1} = A\\cdot Y_n + B\\cdot X_{n+1} Yn+1â€‹=Aâ‹…Ynâ€‹+Bâ‹…Xn+1â€‹ åˆ†æï¼š AAA ç§°ä¸ºçŠ¶æ€è½¬ç§»çŸ©é˜µï¼Œä»–è¡¨ç¤ºè¿­ä»£æ˜¯å¦‚ä½•å½±å“çŠ¶æ€å˜é‡çš„ï¼Œç›´è§‚æ¥è¯´å¦‚æœ AAA çŸ©é˜µä¸å¯¼è‡´çŠ¶æ€å˜é‡ YYY çš„å¢é•¿ï¼Œé‚£è¯¥åé¦ˆæ˜¯ç¨³å®šçš„ï¼›è€ƒè™‘AAA ä½œä¸ºå€¼è€Œéå˜é‡ï¼Œåˆ©ç”¨ç‰¹å¾å€¼ç†è®ºï¼Œè®° AAA çš„ç‰¹å¾å€¼Î»\\lambdaÎ» å¦‚æœ Î»i&lt;1\\lambda_i &lt; 1Î»iâ€‹&lt;1, Y å°†é€æ¸å‡å°è¶‹äºç¨³å®š å¦‚æœ Î»i&gt;1\\lambda_i &gt; 1Î»iâ€‹&gt;1, Y è¿…é€Ÿå¢å¤§ï¼Œå¾ˆå¿«å˜å¾—æ— æ³•æ§åˆ¶ è®¡ç®—ç‰¹å¾å€¼å¦‚ä¸‹ï¼š det(Aâˆ’Î»I)=0det(A - \\lambda I) = 0 det(Aâˆ’Î»I)=0 å±•å¼€å k2Î»2+(T2+Tk1âˆ’2k2)Î»(k2âˆ’Tk1)=0k_2 \\lambda^2 + (T^2 + Tk_1 - 2k_2)\\lambda (k_2-Tk_1) = 0 k2â€‹Î»2+(T2+Tk1â€‹âˆ’2k2â€‹)Î»(k2â€‹âˆ’Tk1â€‹)=0 è§£å…³äº Î»\\lambdaÎ» çš„äºŒæ¬¡æ–¹ç¨‹ Î»=âˆ’bÂ±b2âˆ’4ac2a\\lambda = \\frac{ -b \\pm \\sqrt{b^2-4ac}}{2a} Î»=2aâˆ’bÂ±b2âˆ’4acâ€‹â€‹ ä»¤ âˆ£Î»âˆ£&lt;1|\\lambda| &lt; 1âˆ£Î»âˆ£&lt;1: å¾—: T&lt;4k2+k12âˆ’k1T &lt; \\sqrt{4k_2 + k_1^2} - k_1 T&lt;4k2â€‹+k12â€‹â€‹âˆ’k1â€‹ è¿™é‡Œ å¦‚æœæ—¶é—´æ­¥é•¿å¤§äºä¸´ç•Œå€¼, å°†æ‹†åˆ†ä¸ºå¤šä¸ªäº†è¿­ä»£æ¥è®¡ç®— public classs SecondOrderDynamics { private float T_crit; // critical stable time step public SecondOrderDynamics(float f, floatz, float r, Vector x0) { // update compute constants k1 = z / (PI * f); k2 = 1 / ((2 * PI * f) * (2 * PI * f)); k3 = r * z / (2 * PI * f); T_crit = 0.8f * (sqtr(4 * k2 + k1 * k1)); xp = x0; y = x0; yd = 0; } public Vector Update(float delta, Vector x, Vector xd = null) { if(xd == null) { xd = (x - xp) / delta; xp = x; } int interations = (int)Ceil(delta / T_crit); // take extra iterations if delta &gt; T_crit delta = delta / iterations; for(int i = 0; i &lt; iterations; i++) { y = y + delta * yd; yd = yd + delta * (x + k3 * xd - y - k1*yd) / k2; } return y; } } æ­¤å¤–ï¼Œå¦‚æœæƒ³é¿å…è¿­ä»£æ¬¡æ•°è¿‡å¤šï¼Œå¯ä»¥é™åˆ¶ k2k_2k2â€‹ çš„å€¼ï¼ˆå‡ç¼“è¿åŠ¨ï¼‰ k2&gt;T24+Tk12k_2 &gt; \\frac{T^2}{4} + \\frac{Tk_1}{2} k2â€‹&gt;4T2â€‹+2Tk1â€‹â€‹ float k2_stable = Max(k2, 1.1f * (T*T/4 + T*k1/2)); 2.é›¶æç‚¹åŒ¹é…æ³•ï¼ˆé«˜ç²¾åº¦ï¼‰æ²¡æ‡‚ public classs SecondOrderDynamics { private Vector xp; private Vector y, yd; private float _w, _z, _d, k1, k2, k3; public SecondOrderDynamics(float f, float z, float r, Vetor x0) { _w = 2 * PI * f; _z = z; _d = _w * sqrt(Abs(z*2-1)); k1 = z / (PI * f); k2 = 1 / (_w * _w); k3 = r * z / _w; xp = x0; y = x0; yd = 0; } public Vector Update(float delta, Vector x, Vector xd = null) { if(xd == null) { float k1_stable, k2_stable; if(_w * T &lt; _z) { k1_stable = k1; k2_stable = Max(k2, T * T / 2+ T * k1 / 2, T*k1); } else { float t1 = Exp(-_z * _w * T); float alpha = 2 * t1 * (_z &lt;= 1 ? cos(T * _d) : cosh(T * _d)); float beta = t1 * t1; float t2 = T / (1 + beta -alpha); k1_stable = (1 - beta) * t2; k2_stable = T * t2; } y = y + T * yd; yd = yd + T * (x + k3*xd -y - k1*yd) / k2_stable; return y; } } } 3. å…¶ä»–æ•°å€¼è§£æ–¹æ³•ï¼ˆç•¥ï¼‰ å‚è€ƒ: t3ssel8r:Giving Personality to Procedural Animations using Math ","link":"https://xuaii.github.io/post/you-xi-dong-hua-zhong-de-huan-dong-han-shu/"},{"title":"å¯¹ã€Šæˆ´æ£®çƒè®¡åˆ’ã€‹çš„ä¸€äº›æ‚ä¹±çš„æƒ³æ³•","content":"é€šå®µç©äº†æˆ´æ£®çƒè®¡åˆ’ï¼Œåªç©äº†æ¯æ˜Ÿçƒéƒ¨åˆ†ï¼ˆå®åœ¨ä¸æƒ³è‚äº† ä¸ªäººçœ‹æ³•ï¼Œè¿™ç±»å‹æ¸¸æˆæ²¡ä»€ä¹ˆä¹è¶£ï¼Œä½†æ˜¯é€šå…³å¡æˆ–è€…è¾¾æˆæŸäº›é˜¶æ®µæ€§çš„ç›®æ ‡ä¼šäº§ç”Ÿå·¨å¤§çš„æˆå°±æ„Ÿï¼Œä»¥ç¨‹åºå‘˜çš„è§†è§’ï¼Œæ•´ä¸ªæ¸¸æˆè¿‡ç¨‹åƒæ˜¯åœ¨ç©ä¸€ä¸ªå·¨å¤§çš„è®¡ç®—å™¨ï¼Œä¸æ–­çš„é“ºè·¯å»ºé€ çš„è¿‡ç¨‹åˆåƒæ˜¯åœ¨å†™ä»£ç ï¼Œä½†å®ƒæ²¡æœ‰ä»£ç çµæ´»ï¼ˆå¤§æ¦‚æ˜¯æ—¢ä¸è®©ä½¿ç”¨è®¾è®¡æ¨¡å¼ï¼Œä¹Ÿä¸è®©ä½¿ç”¨å°è£…ç»§æ‰¿çš„æ„Ÿè§‰ï¼Œå°±åƒæ˜¯åœ¨æ‰‹å†™æ±‡ç¼–ç ï¼‰ï¼Œå…¶ä¸­çš„é‡å¤æ€§å¤ªé«˜ã€‚ å„ç§ç‰©èµ„çš„æ„ä¹‰ä»…ä»…æ˜¯æ•°å€¼æ„ä¹‰ï¼Œç±»ä¼¼åœ¨ç©ä¸€ä¸ªMachinations,ï¼›é€šå¸¸æ¸¸æˆä¼šå°†æ•°å€¼éšè—åœ¨æœºåˆ¶èƒŒåï¼Œä½†æ˜¯åŸºå»ºç±»æ¸¸æˆæ— å¯é¿å…çš„éœ€è¦å°†å„ç§æ•°å€¼ä½œä¸ºä¸»è¦çš„ç©æ³•ï¼Œè¿™ä¼šè®©ç©å®¶æ„Ÿåˆ°ç–²åŠ³å’Œå›°ã€‚ æˆ´æ£®çƒè®¡åˆ’å¯¹å‡ åƒä¸Šä¸‡ä¸ªåŠ¨ç”»ç›®æ ‡çš„å¤„ç†åº”è¯¥æ˜¯ç”¨äº†ä»€ä¹ˆé­”æ³•ï¼Œå¤ªæµç•…äº†ï¼Œå¤§æ¦‚æ˜¯ç”¨äº†GPUè®¡ç®—åŠ¨ç”»ä¹‹ç±»çš„æ–¹æ³•ï¼Œè¿™æ˜¯å€¼å¾—å€Ÿé‰´çš„ï¼ï¼ æ­¤å¤–ï¼Œä½œä¸ºç‹¬ç«‹æ¸¸æˆï¼Œã€Šæˆ´æ£®çƒè®¡åˆ’ã€‹æµç•…ï¼Œå†…å®¹å¤šï¼Œè€ç©ï¼Œè¿˜èƒ½æ‰“MODã€‚å°½ç®¡ä¸èƒ½é¢é¢ä¿±åˆ°ï¼Œä½†æ˜¯ä¾ç„¶æ˜¯å›½äº§ç‹¬ç«‹æ¸¸æˆçš„åŠ³æ¨¡äº†ï¼ é²è¿…è¯´è¿‡ï¼Œæ¸¸æˆå°±æ˜¯åœ¨è§„åˆ™ä¸‹ï¼Œä¸ä»¥å®¹æ˜“çš„æ–¹å¼è¾¾æˆç›®æ ‡ã€‚é¢å¯¹æŒ‘æˆ˜å’Œå…‹æœå›°éš¾æœ¬æ¥å°±æ˜¯æ¸¸æˆçš„ä¸€éƒ¨åˆ†ï¼Œé‚£æˆ´æ£®çƒè®¡åˆ’å¸¦æ¥çš„æ¯ç‡¥å’Œæˆå°±æ„Ÿæœ¬å°±æ˜¯æ¸¸æˆçš„ä¹è¶£ä¸€éƒ¨åˆ†ï¼ ","link":"https://xuaii.github.io/post/dui-lesslessdai-sen-qiu-ji-hua-greatergreater-de-yi-xie-za-luan-de-xiang-fa/"},{"title":"CARTå›å½’","content":"å†³ç­–æ ‘.html å¯¼å…¥ç›¸å…³åº“ pandasï¼šå†³ç­–æ ‘çš„æ„å»ºæ¶‰åŠåˆ°æ•°æ®é›†çš„ä¸€äº›æ“ä½œï¼Œåˆ©ç”¨pandasçš„DataFrameæ•°æ®ç»“æ„å¯ä»¥å¾ˆå¥½æ–¹ä¾¿çš„å®Œæˆ copy :åœ¨é€’å½’æ—¶æµ…æ‹·è´ä¼šå¯¼è‡´é—®é¢˜,ä½¿ç”¨copy.deepcopy()è¿›è¡Œæ·±æ‹·è´ matplot.pyplot:ç»˜åˆ¶å†³ç­–æ ‘çš„åˆ’åˆ†å›¾åƒ import pandas as pd import copy import matplotlib.pyplot as plt import numpy as np from math import fabs å¯¼å…¥æ•°æ® input = [[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]] å®šä¹‰å›å½’æ ‘çš„èŠ‚ç‚¹ç±»Node attrList èŠ‚ç‚¹å‰©ä¸‹çš„å±æ€§åˆ—è¡¨ Dataset èŠ‚ç‚¹åˆ’åˆ†åˆ°çš„æ•°æ®é›† left/right å·¦å³å­æ ‘ c å¶èŠ‚ç‚¹çš„é¢„æµ‹å€¼ description è¯¥èŠ‚ç‚¹çš„æè¿°ï¼ˆå¯é€‰ï¼‰ attr è¯¥èŠ‚ç‚¹åˆ’åˆ†å±æ€§ s åˆ’åˆ†å±æ€§çš„å€¼ è€ƒè™‘åˆ°ä½¿ç”¨éäºŒå‰æ ‘ï¼Œåœ¨æ¯æ¬¡å¯»æ‰¾æœ€ä¼˜åŒ–åˆ†çš„æ—¶å€™ç®—æ³•å¤æ‚åº¦å¤ªé«˜ï¼Œæ‰€ä»¥æ­¤æ—¶ä½¿ç”¨äºŒå‰æ ‘å°±OK class Node: def __init__(self, description=&quot;&quot;, c = -1, Dataset=pd.DataFrame(), attrList=[]): self.attrList = attrList self.Dataset = Dataset self.left = None self.right = None self.c = c self.attr = &quot;&quot; self.s = -1 self.desciption = description è®¡ç®—æŸå¤± â„“=âˆ‘xiâˆˆR1(j,s)(yiâˆ’c1)2+âˆ‘xiâˆˆR2(j,s)(yiâˆ’c2)2\\ell = \\sum_{x_i \\in R_1(j,s)}(y_i-c_1)^2+\\sum_{x_i \\in R_2(j,s)}(y_i-c_2)^2 â„“=xiâ€‹âˆˆR1â€‹(j,s)âˆ‘â€‹(yiâ€‹âˆ’c1â€‹)2+xiâ€‹âˆˆR2â€‹(j,s)âˆ‘â€‹(yiâ€‹âˆ’c2â€‹)2 def loss(attr, s, data): D1 = data[data[attr] &lt;= s] D1_mean = D1['label'].std() * D1.size D2 = data[data[attr] &gt; s] D2_mean = D2['label'].std() * D2.size return D1_mean + D2_mean æœ€å°åŒ–æŸå¤± minâ¡j,s(minâ¡c1âˆ‘xiâˆˆR1(j,s)(yiâˆ’c1)2+minâ¡c2âˆ‘xiâˆˆR2(j,s)(yiâˆ’c2)2)\\min_{j,s} ( \\min_{c_1} \\sum_{x_i \\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i \\in R_2(j,s)}(y_i-c_2)^2 ) j,sminâ€‹(c1â€‹minâ€‹xiâ€‹âˆˆR1â€‹(j,s)âˆ‘â€‹(yiâ€‹âˆ’c1â€‹)2+c2â€‹minâ€‹xiâ€‹âˆˆR2â€‹(j,s)âˆ‘â€‹(yiâ€‹âˆ’c2â€‹)2) æ­¤å¤„æ•°æ®é›†ä¸å¤§ ä¸” ä¸ºäº†å®ç°èµ·æ¥ç®€å•å°±æ˜¯ç”¨äº†éå†æ‰€æœ‰å±æ€§çš„å€¼æ‰¾åˆ°æœ€å°çš„æŸå¤±ï¼Œåº”è¯¥è¿˜æœ‰ä¸€äº›æ–¹æ³•å¯ä»¥ä¼˜åŒ–æ‰¾åˆ°æœ€å°å€¼çš„è¿‡ç¨‹ def findOptDiv(root): losses = [] for attr in root.attrList: for s in root.Dataset[attr]: losses.append((loss(attr, s, root.Dataset), attr, s)) minLoss = min(losses) return minLoss äºŒå‰æ ‘çš„æ„å»º åœ¨ä»¥ä¸‹æƒ…å†µè¿”å›IF len(attrList) == 0ï¼šæ­¤æ—¶æ‰€æœ‰å±æ€§å·²ç»åˆ’åˆ†å®Œæ¯•ï¼Œ å°±ä»¥è¯¥é›†åˆæ‰€æœ‰æ ·æœ¬çš„labelçš„å‡å€¼ä½œé¢„æµ‹å€¼ Dataset.size == 1ï¼šæ­¤æ—¶è¯¥èŠ‚ç‚¹çš„æ ·æœ¬ä»…æœ‰ä¸€ä¸ª å°± ä»¥è¯¥æ ·æœ¬çš„labelå€¼åšé¢„æµ‹å€¼ ELSE å°†æ ·æœ¬æŒ‰æœ€ä¼˜åˆ’åˆ†åˆ’åˆ†ä¸ºä¸¤ä¸ªé›†åˆD1ï¼ŒD2ï¼Œå¹¶åˆ†åˆ«æ„å»ºsubTree def buildTree(root): # if root.Dataset.size() &lt;= 1: # description = &quot;leaf node&quot; # c_p = root.Dataset['label'].mean() # leaf = Node(description=description, c = c_p) # å¦‚æœæ ·æœ¬é›†åˆä¸­åªæœ‰ä¸€ä¸ªæ ·æœ¬é‚£ä¹ˆè¯¥èŠ‚ç‚¹ä¸ºå¶èŠ‚ç‚¹ï¼Œè¯¥å¶èŠ‚ç‚¹çš„é¢„æµ‹å€¼æ˜¯è¯¥å”¯ä¸€æ ·æœ¬çš„label if root.Dataset.size == 1: root.c = root.Dataset['label'] return # å¦‚æœå·²ç»å°†å±æ€§åˆ†å®Œäº†ï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹ä¸ºå¶èŠ‚ç‚¹ï¼Œå‰©ä¸‹çš„æ ·æœ¬é›†ä¸­labelçš„æœŸæœ›ä¸ºè¯¥å¶èŠ‚ç‚¹çš„é¢„æµ‹å€¼ elif len(root.attrList) == 0: root.description = &quot;leaf node&quot; root.c = root.Dataset['label'].mean() return else: # æ‰¾åˆ°æœ€ä¼˜åŒ–åˆ† (_, attr, s) = findOptDiv(root) # å°†èŠ‚ç‚¹çš„åˆ’åˆ†å±æ€§è®¾ä¸ºæ‰¾åˆ°çš„attr root.attr = copy.deepcopy(attr) # å°†æŒ‰å±æ€§attråˆ’åˆ†è¯¥èŠ‚ç‚¹å€¼åˆ’åˆ†å€¼sè®¾ä¸ºæœ€ä¼˜çš„s root.s = copy.deepcopy(s) # å°†æ ·æœ¬é›†åˆæŒ‰ç…§æ‰¾åˆ°çš„æœ€ä¼˜åŒ–åˆ†åˆ’åˆ†ä¸ºD1ï¼Œ D2 D1 = copy.deepcopy(root.Dataset[root.Dataset[attr] &lt;= s]) D2 = copy.deepcopy(root.Dataset[root.Dataset[attr] &gt; s]) # å°†åˆ’åˆ†è¯¥èŠ‚ç‚¹å±æ€§ä»å±æ€§é›†åˆä¸­åˆ é™¤ list_notremoved = copy.deepcopy(root.attrList) root.attrList.remove(attr) list_removed = copy.deepcopy(root.attrList) root.attrList = copy.deepcopy(list_notremoved) # æ„å»ºå·¦å­æ ‘å’Œå³å­æ ‘ root.left = Node(Dataset = D1, attrList=copy.deepcopy(list_removed)) root.right = Node(Dataset = D2, attrList=copy.deepcopy(list_removed)) buildTree(root.left) buildTree(root.right) return root é¢„æµ‹å‡½æ•° def predict(x, root): while(len(root.attrList) != 0): if x[root.attr] &lt; root.s: root = root.left else: root = root.right return root.c è¯„ä¼°å‡½æ•° def evaluate(data_test, root): accuracy = 0 for i in range(len(data_test)): res = predict(data_test.loc[i], root) # å°†å›å½’é—®é¢˜è½¬ä¸ºåˆ†ç±»é—®é¢˜ res = .5 if res &gt; .5 else 0 accuracy += fabs(res - data_test.loc[i][&quot;label&quot;]) return 1 - accuracy / len(data_test) data = pd.DataFrame(input, columns=['å¯†åº¦','å«ç³–ç‡',&quot;label&quot;]) root = Node(Dataset=data, attrList = ['å¯†åº¦','å«ç³–ç‡']) root = buildTree(root) å¯ä»¥å¤§è‡´çœ‹å‡ºå†³ç­–è¿‡ç¨‹ å…ˆçœ‹å«ç³–ç‡ï¼š å°äº.13 å°äº.666 åç“œ å¤§äº.666 å¥½ç“œ å¤§äº.13 å°äº.697 0.6çš„æ¦‚ç‡æ˜¯å¥½ç“œ å¤§äº.697 1çš„æ¦‚ç‡æ˜¯å¥½ç“œ print(root.attr,root.s) print(root.left.attr,root.left.s,root.left.left.c,root.left.right.c) print(root.right.attr,root.right.s,root.right.left.c,root.right.right.c) å«ç³–ç‡ 0.103 å¯†åº¦ 0.666 0.0 0.0 å¯†åº¦ 0.697 0.6363636363636364 1.0 å¯è§†åŒ–å’Œè¯„ä¼°æ¨¡å‹è¡¨ç° s1 = root.s s21 = root.left.s s22 = root.right.s plt.plot([.2,.8],[s1,s1],'r-') plt.plot([s21,s21],[0,s1],'r-') plt.plot([s22,s22],[s1,.5],'r-') for plot in input: if plot[2] == 0: c = 'red' else: c = 'green' plt.scatter(plot[0],plot[1],c=c) print(&quot;THE ACCURACY OF REGRESSION TREE IS {}&quot;.format(evaluate(data, root))) THE ACCURACY OF REGRESSION TREE IS 0.6176470588235294 ","link":"https://xuaii.github.io/post/cart-hui-gui/"},{"title":"çº¿æ€§æ¨¡å‹","content":"çº¿æ€§æ¨¡å‹.html import numpy as np import matplotlib.pyplot as plt import copy from IPython import display np.random.seed(0) data = [[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]] def load_data(): X = np.array(data).T label = copy.deepcopy(X[2,:].reshape(1,17)) X[2,:] = 1 assert X.shape == (3,17) assert label.shape == (1,17) return X, label l(Î²)=âˆ‘i=1m(âˆ’yiÎ²Txi+ln(1+eÎ²Txi))l(\\beta) = \\sum_{i=1}^{m}(-y_i \\beta^Tx_i+ln(1+e^{\\beta^T x_i})) l(Î²)=i=1âˆ‘mâ€‹(âˆ’yiâ€‹Î²Txiâ€‹+ln(1+eÎ²Txiâ€‹)) =âˆ‘i=1mâˆ’yiÎ²Txi+âˆ‘i=1mln(1+eÎ²Txi)= \\sum_{i=1}^{m}-y_i \\beta^Tx_i+\\sum_{i=1}^{m}ln(1+e^{\\beta^T x_i}) =i=1âˆ‘mâ€‹âˆ’yiâ€‹Î²Txiâ€‹+i=1âˆ‘mâ€‹ln(1+eÎ²Txiâ€‹) =(Î²TX)Y+np.sum(ln(1+eYi))= (\\beta^TX)Y + np.sum(ln(1+e^{Y_i})) =(Î²TX)Y+np.sum(ln(1+eYiâ€‹)) ä½¿ç”¨numpyå®ç°å¦‚ä¸‹ï¼š part_1 = np.dot(Y, label.T) part_2 = np.sum(np.ln(1+np.exp(Y))) def loss(label, Y): part_1 = -np.dot(Y, label.T) part_2 = np.sum(np.log(1+np.exp(Y))) return part_1 + part_2 å‰å‘ä¼ æ’­ input=W,Xinput = W,Xinput=W,X output=Wâ€²TXâ€²=WTX+boutput = W^{&#x27;T} X^{&#x27;} = W^T X+boutput=Wâ€²TXâ€²=WTX+b def forward_propagation(W,X): Z = np.dot(W,X) A = 1/(1+np.exp(-Z)) return A åˆå§‹åŒ–å‚æ•°: ä½¿ç”¨éšæœºåˆå§‹åŒ– n ------ ç‰¹å¾å€¼æ•°é‡ä¸º m ------ æ ·æœ¬æ•°é‡ wâ€²=(w,b)w^{&#x27;} = (w,b)wâ€²=(w,b) w.shape==ï¼ˆ1,n+1ï¼‰w.shape == ï¼ˆ1,n+1ï¼‰w.shape==ï¼ˆ1,n+1ï¼‰ def initialization(n): return np.random.randn(1,n+1) # return np.zeros((1,n+1)) åå‘ä¼ æ’­ dw=âˆ’âˆ‘i=1mxi(yiâˆ’p1(xi;Î²))dw = -\\sum_{i=1}^{m}x_i(y_i-p_1(x_i;\\beta)) dw=âˆ’i=1âˆ‘mâ€‹xiâ€‹(yiâ€‹âˆ’p1â€‹(xiâ€‹;Î²)) dw=âˆ’(labelâˆ’Y)XTdw = -(label-Y)X^T dw=âˆ’(labelâˆ’Y)XT def back_propagation(X,Y,label): return -np.dot((label-Y),X.T) è®­ç»ƒå¾ªç¯ ä½¿ç”¨æ¢¯åº¦ä¸‹é™æ³• å­¦ä¹ ç‡ = 0.5 è¿­ä»£æ¬¡æ•° 10000 def train(epoch=100,n = 2, learning_rate = 0.5, detial = True): X, label = load_data() W = initialization(n) losses = [] W_list = [] for i in range(0,epoch): Y = forward_propagation(W,X) l = loss(label, Y) dw = back_propagation(X,Y,label) losses.append(float(l)) W += learning_rate * dw if i % 100 == 0: W_list.append(copy.deepcopy(W)) if i % 1000 == 0 and detial ==True: print(&quot;This is {}th epoch , loss = {}&quot;.format(i, l)) return W_list, losses def draw(W): W = W[0] x = np.linspace(0.2,0.8,100) y = -(W[0] * x + W[2])/W[1] plt.plot(x,y) for plot in data: if plot[2] == 0: c = 'red' else: c = 'green' plt.scatter(plot[0],plot[1],c=c) def show(W_list): for W in W_list: plt.clf() display.clear_output(wait=True) draw(W) plt.pause(0.001) W_list,losses = train(epoch=10000,n=2,learning_rate=.01,detial=False) show(W_list[:100]) plt.plot(losses) [&lt;matplotlib.lines.Line2D at 0x7f1b3a14aa50&gt;] ","link":"https://xuaii.github.io/post/xian-xing-mo-xing/"},{"title":"Neural Network","content":"Lå±‚ç¥ç»ç½‘ç»œ.html Neural Network å®ç°æ–¹å¼ï¼šé‡‡ç”¨BPç®—æ³•ï¼Œä½¿ç”¨æ¢¯åº¦ä¸‹é™æ¥ä¼˜åŒ–Wï¼Œb éœ€è¦å®ç°çš„å‡½æ•°å¦‚ä¸‹ï¼š initial():æ ¹æ®ç”¨æˆ·è‡ªå®šä¹‰çš„å±‚layer-&gt;[ n1,n2,n3,...,nmn_1, n_2,n_3,...,n_mn1â€‹,n2â€‹,n3â€‹,...,nmâ€‹ ]æ¥åˆå§‹åŒ–å‚æ•°Wï¼Œb sigmoid():è¾“å…¥XâˆˆRmxnX \\in R^{m x n}XâˆˆRmxn ï¼Œè¿”å›A=11+eâˆ’WX+bA = \\frac{1}{1+e^{-WX + b}}A=1+eâˆ’WX+b1â€‹ liner_propagation():å®ç°ä¸€å±‚çš„å‰å‘ä¼ æ’­ï¼Œè¿”å› Aï¼Œå¹¶ä¸”ç¼“å­˜ä¸­é—´é‡Z L_layers_propagation():å®ç°Lå±‚çš„å‰å‘ä¼ æ’­ï¼Œå¹¶ä¸”ç¼“å­˜æ‰€æœ‰ä¸­é—´å±‚çš„Aï¼ŒZ predict():ä½¿ç”¨è®­ç»ƒå¥½çš„æ¨¡å‹Wsï¼Œbsé¢„æµ‹æŸä¸€è¾“å…¥ç‰¹å¾å‘é‡å¯¹åº”çš„é¢„æµ‹å€¼ back_propagation():å®ç°ä¸€å±‚çš„åå‘ä¼ æ’­ L_back_propagation():å®ç°Lå±‚é“¾å¼åå‘ä¼ æ’­ update_parameters():æ¯ä¸€ä¸ªepochæ›´æ–°å‚æ•° evaulate():è¯„ä¼°æ¨¡å‹ model():ä¸»å¾ªç¯ï¼ŒBPç®—æ³•æ¢¯åº¦ä¸‹é™çš„å¾ªç¯ load_data():åŠ è½½æ•°æ® åœ¨æ•´ä½“çš„è®¾è®¡ä¸­å¹¶æ²¡æœ‰losså‡½æ•°çš„å‡ºç°ï¼Œæ˜¯å› ä¸ºï¼Œåœ¨åå‘ä¼ æ’­è¿‡è¿‡ä¸­ï¼Œdloss/dWçš„è®¡ç®—å¹¶ä¸æ¶‰åŠlossçš„å€¼ï¼Œdloss/dWçš„è¡¨è¾¾å¼ä¸­ä»…æœ‰y_truth å’Œ y_pred é“¾å¼åå¾®åˆ† æ¨å¯¼ï¼ˆè¿™é‡Œæ˜¯æ ¹æ®è¥¿ç“œä¹¦ä¸ŠåŸå§‹å…¬å¼æ¨å¯¼ï¼Œæ‰€ä»¥æ˜¯ç´¯è®¡ç¥ç»ç½‘ç»œï¼‰ ç”±äºåœ¨å¸ƒç½®ç¼–ç¨‹ä½œä¸šä¹‹å‰å°±è‡ªå·±å®ç°äº†ä¸€ä¸‹ç¥ç»ç½‘ç»œï¼Œæ‰€ä»¥å®ç°çš„æ˜¯ä»»æ„å±‚æ•°å’Œä»»æ„æ•°é‡ç¥ç»å…ƒçš„ç¥ç»ç½‘ç»œï¼Œæ‰€ä»¥å°±æ”¹ä¸‹å‚æ•°äº¤ä½œä¸šäº† ç”±äºç¥ç»ç½‘ç»œå±‚æ•°å¯èƒ½ä¼šéå¸¸å¤šï¼Œæ‰€ä»¥åœ¨åå‘ä¼ æ’­æ—¶losså¯¹æ¯ä¸€å±‚çš„Wï¼Œbæ±‚å¯¼ä¼šé‡å¤å¾ˆå¤šä¸­é—´æ­¥éª¤ è®¾ï¼šÎ²iâˆˆRmâ‹…nè®¾ï¼š\\beta^i \\in \\R^{m \\cdot n} è®¾ï¼šÎ²iâˆˆRmâ‹…n Aiâˆ’1âˆˆRnâ‹…sA^{i-1} \\in \\R^{n \\cdot s} Aiâˆ’1âˆˆRnâ‹…s ZiâˆˆRmâ‹…sZ^{i} \\in \\R^{m \\cdot s} ZiâˆˆRmâ‹…s Zi=WiAiâˆ’1+bi=Î²iAiâˆ’1,Z^i = W^i A^{i-1} + b^i = \\beta^i A^{i-1}, Zi=WiAiâˆ’1+bi=Î²iAiâˆ’1, Ai=sigmoid(Zi);A^i = sigmoid(Z^i); Ai=sigmoid(Zi); âˆ‚Eâˆ‚Î²i=âˆ‚Ziâˆ‚Î²iâ‹…âˆ‚Aiâˆ‚Ziâ‹…âˆ‚Eâˆ‚Aiââˆ‚Aiâµâˆ‚Ziï¼Œï¼ˆ1.1ï¼‰\\frac{\\partial E}{\\partial \\beta^i} = \\frac{\\partial Z^i}{\\partial \\beta^i} \\cdot \\underbrace{ \\frac{\\partial A^i}{\\partial Z^i} \\cdot \\overbrace {\\frac{\\partial E}{\\partial A^i}}^{\\partial A^i} }_{\\partial Z^i} ï¼Œ \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad ï¼ˆ1.1ï¼‰ âˆ‚Î²iâˆ‚Eâ€‹=âˆ‚Î²iâˆ‚Ziâ€‹â‹…âˆ‚Ziâˆ‚Ziâˆ‚Aiâ€‹â‹…âˆ‚Aiâˆ‚Eâ€‹â€‹âˆ‚Aiâ€‹â€‹â€‹ï¼Œï¼ˆ1.1ï¼‰ âˆ‚Eâˆ‚Aiâˆ’1=âˆ‚Ziâˆ‚Aiâˆ’1â‹…âˆ‚Aiâˆ‚Ziâ‹…âˆ‚Eâˆ‚Aiââˆ‚Aiâµâˆ‚Zi,ï¼ˆ1.2ï¼‰\\frac{\\partial E}{\\partial A^{i-1}} = \\frac{\\partial Z^i}{\\partial A^{i-1}} \\cdot \\underbrace {\\frac{\\partial A^i}{\\partial Z^i} \\cdot \\overbrace{ \\frac{\\partial E}{\\partial A^i} }^{\\partial A^i} }_{\\partial Z^i}, \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad ï¼ˆ1.2ï¼‰ âˆ‚Aiâˆ’1âˆ‚Eâ€‹=âˆ‚Aiâˆ’1âˆ‚Ziâ€‹â‹…âˆ‚Ziâˆ‚Ziâˆ‚Aiâ€‹â‹…âˆ‚Aiâˆ‚Eâ€‹â€‹âˆ‚Aiâ€‹â€‹â€‹,ï¼ˆ1.2ï¼‰ å…¶ä¸­ï¼š âˆ‚Aiç”±ä¸Šä¸€å±‚åå‘ä¼ æ’­æä¾›,\\partial A^iç”±ä¸Šä¸€å±‚åå‘ä¼ æ’­æä¾›, âˆ‚Aiç”±ä¸Šä¸€å±‚åå‘ä¼ æ’­æä¾›, ç°åœ¨è€ƒè™‘æ¯ä¸€å±‚åå‘ä¼ æ’­çš„è®¡ç®— å·²çŸ¥: âˆ‚Eâˆ‚Ak,âˆ‚Akâˆ‚Zk,å…¶ä¸­ï¼škæ˜¯å±‚æ•°\\frac{\\partial E}{\\partial A^k}, \\frac{\\partial A^k}{\\partial Z^k}, \\qquadå…¶ä¸­ï¼škæ˜¯å±‚æ•° âˆ‚Akâˆ‚Eâ€‹,âˆ‚Zkâˆ‚Akâ€‹,å…¶ä¸­ï¼škæ˜¯å±‚æ•° æ±‚è§£: âˆ‚Eâˆ‚Zki,jå…¶ä¸­ï¼ši,jâˆˆ{i,jâˆ£iâˆˆ(1,Zk.shape[0]ï¼Œjâˆˆ(1,Zk.shape[1])}\\frac{\\partial E}{\\partial {Z^k}_{i,j}} \\qquadå…¶ä¸­ï¼š i,j \\in \\{ i,j | i \\in (1,Z^k.shape[0]ï¼Œ j \\in (1,Z^k.shape[1])\\} âˆ‚Zki,jâ€‹âˆ‚Eâ€‹å…¶ä¸­ï¼ši,jâˆˆ{i,jâˆ£iâˆˆ(1,Zk.shape[0]ï¼Œjâˆˆ(1,Zk.shape[1])} åˆ†æï¼š ç”±äº ï¼ˆæš‚æ—¶å¿½ç•¥æ‰ä¸Šæ ‡ï¼Œä»…åœ¨éœ€è¦çš„æ—¶å€™æ·»åŠ ï¼‰ Z=Î²AZ = \\beta A Z=Î²A Zi,j=âˆ‘k=1nÎ²i,kAk,jZ_{i,j} = \\sum_{k=1}^{n}\\beta_{i,k}A_{k,j} Zi,jâ€‹=k=1âˆ‘nâ€‹Î²i,kâ€‹Ak,jâ€‹ è¯¥å¼å­è¡¨æ˜ Zi,jçš„å€¼ä¸åŒè¡ŒÎ²i,kZ_{i,j}çš„å€¼ä¸åŒè¡Œ\\beta{i,k} Zi,jâ€‹çš„å€¼ä¸åŒè¡ŒÎ²i,k å³æ¯ä¸€ä¸ªÎ²ä¸Zçš„ç¬¬aè¡Œç›¸å…³å³æ¯ä¸€ä¸ª\\betaä¸Zçš„ç¬¬aè¡Œç›¸å…³ å³æ¯ä¸€ä¸ªÎ²ä¸Zçš„ç¬¬aè¡Œç›¸å…³ é‚£ä¹ˆè¦è®¡ç®—âˆ‚Eâˆ‚Î²a,bé‚£ä¹ˆè¦è®¡ç®—\\frac{\\partial E}{\\partial \\beta_{a,b}} é‚£ä¹ˆè¦è®¡ç®—âˆ‚Î²a,bâ€‹âˆ‚Eâ€‹ å³éœ€è¦âˆ‚Eâˆ‚Î²a,b=âˆ‘k=1sâˆ‚Eâˆ‚Za,kâˆ‚Za,kâˆ‚Î²a,bå³éœ€è¦\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s}\\frac{\\partial E}{\\partial Z_{a,k}} \\frac{\\partial Z_{a,k}}{\\partial \\beta_{a,b}} å³éœ€è¦âˆ‚Î²a,bâ€‹âˆ‚Eâ€‹=k=1âˆ‘sâ€‹âˆ‚Za,kâ€‹âˆ‚Eâ€‹âˆ‚Î²a,bâ€‹âˆ‚Za,kâ€‹â€‹ è€Œï¼šâˆ‚Za,kâˆ‚Î²a,b=Ab,kè€Œï¼š\\frac{\\partial Z_{a,k}}{\\partial \\beta_{a,b}} = A_{b,k} è€Œï¼šâˆ‚Î²a,bâ€‹âˆ‚Za,kâ€‹â€‹=Ab,kâ€‹ é‚£ä¹ˆï¼šâˆ‚Eâˆ‚Î²a,b=âˆ‘k=1sâˆ‚Eâˆ‚Za,kâ‹…Ab,ké‚£ä¹ˆï¼š\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s}\\frac{\\partial E}{\\partial Z_{a,k}} \\cdot A_{b,k} é‚£ä¹ˆï¼šâˆ‚Î²a,bâ€‹âˆ‚Eâ€‹=k=1âˆ‘sâ€‹âˆ‚Za,kâ€‹âˆ‚Eâ€‹â‹…Ab,kâ€‹ âˆ‚Eâˆ‚Î²a,b=âˆ‘k=1s(âˆ‚Eâˆ‚Z)a,kâ‹…Ab,k\\frac{\\partial E}{\\partial \\beta_{a,b}} = \\sum_{k=1}^{s} {(\\frac{\\partial E}{\\partial Z})}_{a,k} \\cdot A_{b,k} âˆ‚Î²a,bâ€‹âˆ‚Eâ€‹=k=1âˆ‘sâ€‹(âˆ‚Zâˆ‚Eâ€‹)a,kâ€‹â‹…Ab,kâ€‹ =âˆ‘k=1s(âˆ‚Eâˆ‚Z)a,k(AT)k,b= \\sum_{k=1}^{s}(\\frac{\\partial E}{\\partial Z})_{a,k}(A^T)_{k,b} =k=1âˆ‘sâ€‹(âˆ‚Zâˆ‚Eâ€‹)a,kâ€‹(AT)k,bâ€‹ æ‰€ä»¥æœ‰ï¼šâˆ‚EÎ²=dZATæ‰€ä»¥æœ‰ï¼š\\frac{\\partial E}{\\beta} = dZ A^T æ‰€ä»¥æœ‰ï¼šÎ²âˆ‚Eâ€‹=dZAT ç”±äºæ¨å¯¼çš„è¿­ä»£å¼å­ä¸­åŒ…å«A, Z, ç­‰å‰å‘ä¼ æ’­äº§ç”Ÿçš„ä¸­é—´ç»“æœï¼Œ æ‰€ä»¥åœ¨å‰å‘ä¼ æ’­æ—¶éœ€è¦å°†å®ƒä»¬ç¼“å­˜ä¸‹æ¥ import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation import sys import copy from IPython import display import time from sklearn.metrics import roc_curve, auc, accuracy_score, confusion_matrix, classification_report, roc_auc_score # è®¾ç½®éšæœºç§å­ï¼Œé¿å…æ¯æ¬¡çš„ç»“æœä¸ä¸€æ · np.random.seed(1) %matplotlib inline åˆå§‹åŒ–å‡½æ•°initial(layers) input: layers -&gt; [layer_1, layer_2, layer_3, ..., layer_m] output: paramters -&gt; dict() parameters[&quot;w&quot;] = temp_w -&gt; list() parameters['layers'] = layers -&gt; list() def initial(layers): parameters = dict() temp_w = list() for i in range(1, len(layers)): temp_w.append(np.random.randn(layers[i], layers[i-1])) parameters[&quot;w&quot;] = temp_w parameters['layers'] = layers return parameters æ¿€æ´»å‡½æ•° Sigmoid() æ¿€æ´»å‡½æ•°ç§ç±»ï¼š sigmoid():&quot;S&quot;å½¢å‡½æ•°f(x)=11+eâˆ’WX+bf(x) = \\frac{1}{1+e^{-WX + b}}f(x)=1+eâˆ’WX+b1â€‹$ ReLU():çº¿æ€§ä¿®æ­£å•å…ƒf(x)=max(0,x)f(x) = max(0,x)f(x)=max(0,x) tanh():åŒæ›²æ­£åˆ‡å‡½æ•°f(x)=exâˆ’eâˆ’xex+eâˆ’xf(x) = \\frac{e^x-e^{-x}}{e^x+e^{-x}}f(x)=ex+eâˆ’xexâˆ’eâˆ’xâ€‹ ELU: PReLU: LReLU:xè´ŸåŠè½´æ–œç‡æ¯”è¾ƒå°çš„PReLU def sigmoid(A): return 1/(1+np.exp(-A)) å‰å‘çº¿æ€§ä¼ æ’­ Z=WX+bZ = WX + bZ=WX+b A=11+eâˆ’ZA = \\frac{1}{1+e^-Z}A=1+eâˆ’Z1â€‹ def liner_propagation(w, A): Z = np.dot(w, A) A = sigmoid(Z) return Z, A Lå±‚çš„å‰å‘ä¼ æ’­ æ˜¯Læ¬¡linear_propagationçš„å åŠ  ç”±äºåå‘ä¼ æ’­çš„éœ€è¦ï¼Œè¿™é‡Œçš„Lå±‚å‰å‘ä¼ æ’­éœ€è¦ç¼“å­˜æ¯ä¸€å±‚çš„Aï¼ŒZåˆ°A_cache and Z_chache def L_layers_propagation(parameters, x): A_cache = list() Z_cache = list() cache = dict() A_cache.append(x) Z_cache.append(x) w = parameters[&quot;w&quot;] layers = parameters['layers'] for i in range(0, len(layers) - 1): Z, A = liner_propagation(w[i], A_cache[i]) assert Z.shape == A.shape Z_cache.append(Z) A_cache.append(A) cache[&quot;A&quot;] = A_cache cache[&quot;Z&quot;] = Z_cache return cache Losså‡½æ•°ï¼ˆå‡æ–¹è¯¯å·®ï¼‰ å¦‚æœè¦å®ç°ä»»æ„losså‡½æ•°ï¼Œåªä¼šå½±å“é“¾å¼ä¼ æ’­å“¦çš„æœ€åä¸€é¡¹ï¼Œè€Œä¸ä¼šå½±å“é“¾å¼ä¼ æ’­çš„ä¸­é—´è¿‡ç¨‹ ç”±äºæœ€è¿‘DDLå¤šï¼Œæ‰€ä»¥ä»»æ„losså‡½æ•°çš„å®ç°ï¼Œåœ¨å¯’å‡å®ç° def lossFunc(Y_pre, Y_true, method = &quot;MSE&quot;): temp = Y_pre - Y_true return .5 * np.dot(temp, temp.T) é¢„æµ‹å‡½æ•° input = x output = y y=f(x)y = f(x)y=f(x) y&gt;.5y&gt;.5y&gt;.5 =&gt; y=1y=1y=1 yâ‰¤.5y\\le .5yâ‰¤.5 =&gt; y=0y= 0y=0 def predict(parameters, x, draw = False): Y = L_layers_propagation(parameters, x)['A'][-1] if draw == False: Y[Y &gt; .5] = 1 Y[Y &lt;= .5] = 0 return Y åå‘ä¼ æ’­å‡½æ•° back_propagation å®ç°åå‘ä¼ æ’­çš„éš¾ç‚¹åœ¨äºæ±‚æ¢¯åº¦ æ±‚æ¢¯åº¦çš„æ–¹æ³•å¦‚ä¸‹ï¼š dx=f(x)âˆ’f(xâˆ’Î”x)Î”xdx = \\frac{f(x) - f(x-\\Delta x)}{\\Delta x}dx=Î”xf(x)âˆ’f(xâˆ’Î”x)â€‹ è€å¸ˆä¸Šè¯¾æåˆ°çš„è¿™ç§æ–¹æ³•ä¼šå¯¼è‡´ç²¾ç¡®åº¦é—®é¢˜ å¦‚å½“åœ¨æ¢¯åº¦ä¸‹é™ç®—æ³•ä¸­è®¾å®šÎ”x=Î·\\Delta x= \\etaÎ”x=Î·æ—¶è¯¥ç®—æ³•é€€åŒ–ä¸º W := W - loss(x-learning_rate) 2.åˆ©ç”¨æ±‚åå¯¼æ³•åˆ™ï¼Œä¸€å±‚ä¸€å±‚çš„æ±‚åå¯¼ ä½¿ç”¨ç±»ä¼¼ tensorflow çš„ Autograd çš„è®¡ç®—å›¾ï¼Œå°†æ¯ä¸€ä¸ªå‚æ•°å˜é‡åŠ å…¥è®¡ç®—å›¾ä¸­ï¼Œç„¶åå¯ä»¥æ‰¾åˆ°å˜é‡ä¹‹é—´çš„å…³è”ç„¶åæ±‚å¯¼(å®ç°è¿‡äºå¤æ‚ï¼Œå¯¹äºç®€å•çš„å…¨é“¾æ¥ç½‘ç»œæ²¡å¿…è¦è¿™æ ·åš) ä½¿ç”¨é«˜ç­‰æ•°å­¦ä¸­çš„å¤šå˜é‡æ±‚å¯¼ï¼Œç»“åˆçº¿æ€§ä»£æ•°çš„çŸ©é˜µå˜æ¢è¿›è¡Œ å®æ•° å¯¹ çŸ©é˜µ çš„ é“¾å¼æ±‚å¯¼ å‚è€ƒ çŸ©é˜µæ±‚å¯¼æœ¯ï¼ˆä¸‹ï¼‰ çŸ©é˜µæ±‚å¯¼æœ¯ï¼ˆä¸Šï¼‰ å¼•å…¥å…‹ç½—å†…å…‹ç§¯å®ç°çŸ©é˜µçš„é“¾å¼æ±‚å¯¼ï¼Œåœ¨æ³¨é‡Šä»£ç ä¸­æ˜¯æ²¡ç»è¿‡èŠ±é—´çš„Kronç§¯ï¼Œè¿ç®—é‡æå¤§ï¼Œç»è¿‡åŒ–ç®€å¾—åˆ°ç®€å•çš„çŸ©é˜µè¡¨è¾¾å¼ def back_propagation(W, A_prev, dZ): # dZA_prev = np.diag( (A_prev * (1 - A_prev)).T.flatten() ) # I = np.eye(A_prev.shape[1]) # dZ_prev = np.dot(np.dot(dZA_prev,np.kron(I, W.T)), dZ) # I = np.eye(W.shape[0]) # dW = np.dot(np.kron(A_prev, I),dZ) # print(A_prev.shape, W.shape, dZ.shape) dZ_prev = np.multiply( A_prev * (1 - A_prev), np.dot(W.T,dZ)) dW = np.dot(dZ,A_prev.T) return dZ_prev, dW def L_back_propagation(cache, parameters, y): w = parameters[&quot;w&quot;] layers = parameters[&quot;layers&quot;] L = len(layers) - 1 A = cache[&quot;A&quot;] dW_list = list() dZ_prev = A[L] * (1 - A[L]) * (A[L] - y) for i in reversed(range(0, L)): dZ_prev, dW = back_propagation(w[i], A[i], dZ_prev) dW_list.append(dW) cache[&quot;dW&quot;] = dW_list return cache æ›´æ–°å‚æ•° pass def update_parameters(cache, parameters, learning_rate): w = parameters[&quot;w&quot;] layers = parameters[&quot;layers&quot;] L = len(layers) - 1 dW = cache[&quot;dW&quot;] for i in range(L): w[i] -= dW[L-i-1] * learning_rate # b[i] = b[i] - db[len(b)-i-1] * learning_rate parameters[&quot;w&quot;] = w return parameters evaulate ä½¿ç”¨å‡†ç¡®åº¦ä½œä¸ºè¯„ä¼°æ ‡å‡† def evaluate(Z, Y): bools = Z == Y accuracy = np.sum(np.reshape(bools,bools.size))/Y.shape[1] return accuracy def evaluate_detial(y_t, y_p): y_test = copy.deepcopy(y_t) y_pred = copy.deepcopy(y_p) print(&quot;The roc_auc_score is {}&quot;.format(roc_auc_score(y_test, y_pred))) tpr,fpr,thresholds = roc_curve(y_test,y_pred) plt.subplot(1,2,1) plt.plot(fpr, tpr) plt.xlim([0.0, 1.0]) plt.ylim([0.0, 1.0]) plt.title('ROC curve for diabetes classifier') plt.xlabel('False Positive Rate (1 - Specificity)') plt.ylabel('True Positive Rate (Sensitivity)') plt.grid(True) # mean = np.sum(y_pred)/y_pred.shape[0] y_pred[(y_pred &lt; 0.5)] = 0 y_pred[(y_pred &gt;= 0.5)] = 1 # plt.scatter(x_test[0, :], x_test[1, :], c = y_pred[:, 0]) print(&quot;The accuracy is {}&quot;.format(accuracy_score(y_test[:,0], y_pred[:,0]))) # è®¡ç®—å¬å›ï¼Œ æŸ¥å…¨ç‡ï¼Œ æŸ¥å‡†ç‡ ã€‚ã€‚ã€‚ã€‚ target_names = ['class0','class1'] print(classification_report(y_test,y_pred,target_names = target_names)) ## ç»˜å›¾ def Plot(X, label, parameters): x_min, x_max = X[0,:].min() - .5, X[0,:].max() + .5 y_min, y_max = X[1,:].min() - .5, X[1,:].max() + .5 h = 0.01 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) Z = predict(parameters, np.c_[xx.ravel(), yy.ravel(), np.ones((yy.ravel().shape))].T) Z = Z.reshape(xx.shape) plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral) plt.scatter(X[0,:],X[1,:],c=label[0,:]) load_data åŠ è½½æ•°æ®çš„ç®¡é“ def load_data(shape = &quot;circle&quot;): X = np.random.rand(2,200) one = np.ones((1,200)) X = np.vstack((X,one)) C = [] for x in X.T: if shape == &quot;circle&quot;: # åŒå¿ƒåœ† if (x[0]-.5)**2 + (x[1]-.5)**2 &lt; .03: C.append(1) elif (x[0]-.5)**2 + (x[1]-.5)**2 &lt; .13: C.append(0) else: C.append(1) elif shape == &quot;xor&quot;: # å››åˆ† if (x[0] - .5)*(x[1] - .5) &gt;=0: C.append(1) else: C.append(0) x_min, x_max = X[0,:].min() - .05, X[0,:].max() + .05 y_min, y_max = X[1,:].min() - .05, X[1,:].max() + .05 h = 0.01 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) test = np.c_[xx.ravel(), yy.ravel(), np.ones((yy.ravel().shape))].T return X, np.array(C).reshape(1,-1), test, (xx,yy) Back Propagation(BPç®—æ³•çš„æ•´ä½“æ¡†æ¶) ä½¿ç”¨æ¢¯åº¦ä¸‹é™çš„ä¼˜åŒ–æ–¹æ³• å…¶ä»–å¯ç”¨çš„ä¼˜åŒ–æ–¹æ³• SGD éšæœºæ¢¯åº¦ä¸‹é™ MBGD ï¼ˆMini Batch Gradient Descentï¼‰ç”¨äºæ ·æœ¬å®¹é‡å¤§ï¼Œå†…å­˜/ç°å­˜ä¸å¤Ÿçš„æƒ…å†µ Momentum åŠ¨é‡æ¢¯åº¦ä¸‹é™ Nesterov NAG Adagrad Adaelta Adam def model(X, Y, test,canvs, layers, learning_rate = 0.01, epoch = 1000, detial = True, draw = False): parameters = initial(layers) draw_param = [] for i in range(epoch): cache = L_layers_propagation(parameters, X) cache = L_back_propagation(cache, parameters, Y) parameters = update_parameters(cache, parameters, learning_rate) if i % 500 == 0 and draw == True: # draw_param.append(copy.deepcopy(parameters)) yield predict(parameters, test, draw = True).reshape(canvs[0].shape) if i % 1000 == 0 and detial == True: print(&quot;this is {}th epoch.&quot;.format(i)) Y_predict = predict(parameters, X, draw=False) accuracy = evaluate(Y, Y_predict) print(&quot;accuracy is {}&quot;.format(accuracy)) if draw == False: return parameters å®ç°ç´¯è®¡BPç®—æ³• def model_caculate(X, Y, X_test, Y_test, layers, learning_rate = 0.01, epoch = 1000, interval = 50): parameters = initial(layers) Loss = [] loss = None Acc = [] accuracy = None start = time.time() Y_predict = None for i in range(epoch): cache = L_layers_propagation(parameters, X) cache = L_back_propagation(cache, parameters, Y) loss = lossFunc(Y, cache[&quot;A&quot;][-1]) parameters = update_parameters(cache, parameters, learning_rate) if i % interval == 0: Loss.append(loss[0,0]) Y_predict = predict(parameters, X_test, draw=False) accuracy = evaluate(Y_test, Y_predict) Acc.append(accuracy) if i % (interval * 50) == 0: now = time.time() print(&quot;Calculate Dense Net:~$ {}th epoch, accuracy: {}, loss:{}, time:{}-&quot;.format(i, accuracy, loss[0,0], now - start)) start = time.time() return Loss, Acc, Y_predict X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] epoch = 25000 Loss, accuracy, Y_pred = model_caculate(X, label, X, label, layers, learning_rate=0.01, epoch= epoch) #å¼€å§‹ç”»å›¾ x = np.linspace(0, 25000, 500) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # æ˜¾ç¤ºå›¾ä¾‹ plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(label.T, Y_pred.T) Calculate Dense Net:~$ 0th epoch, accuracy: 0.725, loss:21.40100100371333, time:0.0010008811950683594- Calculate Dense Net:~$ 2500th epoch, accuracy: 0.725, loss:19.748958341789084, time:0.7027204036712646- Calculate Dense Net:~$ 5000th epoch, accuracy: 0.725, loss:18.484585855571503, time:0.7009453773498535- Calculate Dense Net:~$ 7500th epoch, accuracy: 0.705, loss:16.377806924887945, time:0.6996634006500244- Calculate Dense Net:~$ 10000th epoch, accuracy: 0.87, loss:10.950215467935237, time:0.7041025161743164- Calculate Dense Net:~$ 12500th epoch, accuracy: 0.88, loss:9.160948492962692, time:0.701648473739624- Calculate Dense Net:~$ 15000th epoch, accuracy: 0.885, loss:8.84026852930535, time:0.6946816444396973- Calculate Dense Net:~$ 17500th epoch, accuracy: 0.965, loss:6.105461022050368, time:0.685279369354248- Calculate Dense Net:~$ 20000th epoch, accuracy: 0.99, loss:2.3057686501449832, time:0.7090015411376953- Calculate Dense Net:~$ 22500th epoch, accuracy: 0.99, loss:0.958385284049958, time:0.6965689659118652- The roc_auc_score is 1.0 The accuracy is 1.0 precision recall f1-score support class0 1.00 1.00 1.00 55 class1 1.00 1.00 1.00 145 micro avg 1.00 1.00 1.00 200 macro avg 1.00 1.00 1.00 200 weighted avg 1.00 1.00 1.00 200 å®ç°æ ‡å‡†BPç®—æ³•ï¼ˆä¹Ÿå°±æ˜¯Mini-batch = 1ï¼Œè¿™æ ·çš„è¯åœ¨pythonä¸‹ä½¿ç”¨forå¾ªç¯å–‚æ•°æ®ä¼šéå¸¸æ…¢ï¼‰ def model_std(X, Y, X_test, Y_test, layers, learning_rate = 0.01, epoch = 1000, interval = 50): parameters = initial(layers) Loss = [] Acc = [] accuracy = None loss = None Y_pred = None start = time.time() for i in range(epoch): for j in range(0, X.shape[1]): cache = L_layers_propagation(parameters, X[:, j].reshape(3, -1)) cache = L_back_propagation(cache, parameters, Y[:, j].reshape(1, -1)) parameters = update_parameters(cache, parameters, learning_rate) if i % interval == 0: Y_pred = predict(parameters, X_test, draw = False) loss = lossFunc(Y_test, Y_pred)[0,0] Loss.append(loss) accuracy = evaluate(Y_test, Y_pred) Acc.append(accuracy) if i % (interval * 20) == 0: now = time.time() print(&quot;Stander Dense Net:~$ {}th epoch, accuracy: {}, loss:{}, time:{}&quot;.format(i, accuracy, loss, now - start)) start = time.time() return Loss, Acc, Y_pred X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] epoch = 33300 Loss,accuracy, Y_pred = model_std(X, label, X, label, layers, learning_rate=0.01, epoch= epoch) #å¼€å§‹ç”»å›¾ x = np.linspace(0, 25000, epoch/50) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # æ˜¾ç¤ºå›¾ä¾‹ plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(label.T, Y_pred.T) Stander Dense Net:~$ 0th epoch, accuracy: 0.65, loss:35.0, time:0.018254756927490234 åŠ¨æ€å¯è§†åŒ–è®­ç»ƒè¿‡ç¨‹ def main(epoch= 50000, detial=True, draw=False): X, label, test, canvs = load_data() layers = [3,6,9,9,6,1] if draw == True: for im in model(X, label, test, canvs, layers, learning_rate=0.01, epoch= epoch, detial = detial, draw = True): plt.clf() display.clear_output(wait=True) plt.contourf(canvs[0] ,canvs[1], im, cmap=plt.cm.Spectral) plt.scatter(X[0,:], X[1,:],c=label[0,:]) plt.pause(0.01) else: parameters = model(X, label, test, canvs, layers, learning_rate=0.01, epoch= 30000, detial = detial, draw = draw) Plot(X, label, parameters) main(epoch= 20000, detial=False, draw=True) è¥¿ç“œæ•°æ®é›†3.0Î±\\alphaÎ±ä¸Šçš„åˆ†ç±» å¯¼å…¥æ•°æ® import numpy as np import copy def load(): data = np.array([[0.697, 0.460, 1], [0.774, 0.376, 1], [0.634, 0.264, 1], [0.608, 0.318, 1], [0.556, 0.215, 1], [0.403, 0.237, 1], [0.481, 0.149, 1], [0.437, 0.211, 1], [0.666, 0.091, 0], [0.243, 0.267, 0], [0.245, 0.057, 0], [0.343, 0.099, 0], [0.639, 0.161, 0], [0.657, 0.198, 0], [0.360, 0.370, 0], [0.593, 0.042, 0], [0.719, 0.103, 0]]) Y = copy.deepcopy(data[:, 2].reshape(-1, 1).T) data[:, 2] = 1 X = copy.deepcopy(data.T) X_test = copy.deepcopy(np.c_[X[:, 0:2],X[:, -3:-1]]) Y_test = copy.deepcopy(np.c_[Y[:, 0:2],Y[:, -3:-1]]) X_train = copy.deepcopy(X[:, 2:-2]) Y_train = copy.deepcopy(Y[:, 2:-2]) return X_train, Y_train, X_test, Y_test, X, Y X_train, Y_train, X_test, Y_test, X, Y = load() print(Y.shape) ç´¯è®¡BP X_train, Y_train, X_test, Y_test, X, Y = load() X_train.shape, Y_train.shape, X_test.shape, Y_test.shape layers = [3,5,1] epoch = 5500 interval = 1 Loss, accuracy, Y_pred = model_caculate(X_train, Y_train, X_test, Y_test, layers, learning_rate=0.1, epoch= epoch, interval = interval) #å¼€å§‹ç”»å›¾ x = np.linspace(0, 25000, epoch/interval) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # æ˜¾ç¤ºå›¾ä¾‹ plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(Y_test.T, Y_pred.T) X, label, test, canvs = load_data() X.shape, label.shape æ ‡å‡†BPç®—æ³• ç”±äºå®ç°äº†ç´¯è®¡è¯¯å·®çš„ç®—æ³•ï¼Œ æ‰€ä»¥å¯ä»¥å°†æ ·æ ·æœ¬æ‹†åˆ†å¾—åˆ°mini-batchçš„ç¥ç»ç½‘ç»œå°±æ˜¯æ ‡å‡†BPç®—æ³• layers = [3,5,1] epoch = 5500 interval = 1 Loss,accuracy, Y_pred = model_std(X_train, Y_train, X_test, Y_test, layers, learning_rate=0.01, epoch= epoch) #å¼€å§‹ç”»å›¾ x = np.linspace(0, 25000, epoch/50) plt.plot(x, np.array(Loss)/(max(Loss) - min(Loss)), color='green', label='training loss') plt.plot(x, np.array(accuracy)/(max(accuracy) - min(accuracy)), color='red', label='training accuracy') # æ˜¾ç¤ºå›¾ä¾‹ plt.legend() plt.xlabel('iteration times') plt.ylabel('rate') plt.show() evaluate_detial(Y_test.T, Y_pred.T) æ¨¡å‹æ¯”è¾ƒ æ ‡å‡†BPç®—æ³•æ”¶æ•›æ›´å¿« ç´¯è®¡BPåœ¨pythonå¯ä»¥é€šè¿‡çŸ©é˜µè¿ç®—å‘é‡åŒ–åŠ é€Ÿ,åœ¨è¿­ä»£è¿‡ç¨‹ä¸­éœ‡è¡å˜å° ç´¯è®¡BP æ›´å ç”¨å†…å­˜ï¼Œè€Œæ ‡å‡†BPå¯ä»¥ä¸€è¾¹è¯»ä¸€è¾¹è¿ç®—ï¼Œæ”¶æ•›é€Ÿåº¦å˜æ…¢ä½†æ˜¯æ¢¯åº¦æ–¹å‘æ›´å‡†ç¡® Minibatch = nï¼Œå¯ä»¥é€šè¿‡è°ƒèŠ‚nçš„å¤§å°ä½¿å…¶è¾¾åˆ°ä¸€ä¸ªåˆé€‚çš„å€¼ï¼Œå…¶æ”¶æ•›é€Ÿåº¦å’Œè¿­ä»£çš„å‡†ç¡®æ€§éƒ½èƒ½æé«˜ï¼ ç¥ç»ç½‘ç»œçš„ä¼˜åŠ¿ ç›¸å¯¹äºå†³ç­–æ ‘ï¼Œçº¿æ€§æ¨¡å‹ï¼Œç¥ç»ç½‘ç»œå¯ä»¥é€šè¿‡å¢åŠ å±‚æ•°/å¢åŠ ç¥ç»å…ƒçš„æ–¹å¼æ‹Ÿåˆä»»æ„éçº¿æ€§å‡½æ•° åœ¨ä¹‹å‰çš„åŒå¿ƒåœ†æ•°æ®é›†ä¸­ï¼Œç¥ç»ç½‘ç»œçš„è¡¨è¾¾èƒ½åŠ›è¿œè¿œä¼˜äºå…¶ä»–æ¨¡å‹ \\begin{split} &amp; C(F , G) = \\frac{F \\cdot G+(1 - F\\otimes G)}{2}\\ &amp; F\\cdot G = \\vee_U(\\mu_F(u_i)\\land\\mu_G(u_i)) \\ &amp; F\\otimes G = \\vee_U(\\mu_F(u_i)\\vee\\mu_G(u_i)) \\end{split} ","link":"https://xuaii.github.io/post/neural-network/"},{"title":"SVM","content":"svm.html çº¿æ€§æ ¸SVM å’Œ é«˜æ–¯æ ¸SVM SMO ç®—æ³•è§£æ æœ€ä¼˜åŒ–ç›®æ ‡ (1)maxâ¡Î±=âˆ‘i=1mÎ±iâˆ’âˆ‘i=1mâˆ‘j=1mÎ±iÎ±jyiyjxiTxj\\max_{\\alpha} =\\sum_{i=1}^{m}\\alpha_i - \\sum_{i=1}^{m} \\sum_{j=1}^{m}\\alpha_i\\alpha_jy_iy_jx_i^Tx_j \\tag{1} Î±maxâ€‹=i=1âˆ‘mâ€‹Î±iâ€‹âˆ’i=1âˆ‘mâ€‹j=1âˆ‘mâ€‹Î±iâ€‹Î±jâ€‹yiâ€‹yjâ€‹xiTâ€‹xjâ€‹(1) (2) s.t. Î±iâ‰¥0,âˆ‘i=1NÎ±iyi=1\\text{ s.t. } \\qquad \\alpha_i \\ge 0,\\quad \\sum_{i=1}^{N}\\alpha_iy_i = 1 \\tag{2} s.t. Î±iâ€‹â‰¥0,i=1âˆ‘Nâ€‹Î±iâ€‹yiâ€‹=1(2) çº¦æŸæ¡ä»¶ ç®—æ³•åŸç† æˆ‘ä»¬å¯ä»¥å…ˆç¡®å®š ä¸¤ä¸ªÎ±i,Î±j\\alpha_i,\\alpha_jÎ±iâ€‹,Î±jâ€‹. åœ¨ä¾‹å­ä¸­è®¾i=1,j=2i=1 , \\quad j=2i=1,j=2. æ­¤æ—¶æœ€å¤§åŒ–ç›®æ ‡ï¼š (3)argmaxâ¡Î±1,Î±2W(Î±1,Î±2)=Î±1+Î±2âˆ’12K1,1y12Î±12âˆ’12K2,2y22Î±22âˆ’K1,2y1y2Î±1Î±2âˆ’y1Î±1âˆ‘i=3mÎ±iyiKi,1âˆ’y2Î±2âˆ‘i=3mÎ±iyiKi,2+Carg\\max_{\\alpha_1, \\alpha_2}W(\\alpha_1, \\alpha_2) = \\alpha_1 + \\alpha_2 - \\frac{1}{2}K_{1,1}y_1^2\\alpha_1^2 - \\frac{1}{2}K_{2,2}y_2^2\\alpha_2^2 - K_{1,2}y_1y_2\\alpha_1\\alpha_2 - y_1\\alpha_1\\sum_{i=3}^{m}\\alpha_iy_iK_{i,1} - y_2\\alpha_2\\sum_{i=3}^{m}\\alpha_iy_iK_{i,2} + C \\tag{3} argÎ±1â€‹,Î±2â€‹maxâ€‹W(Î±1â€‹,Î±2â€‹)=Î±1â€‹+Î±2â€‹âˆ’21â€‹K1,1â€‹y12â€‹Î±12â€‹âˆ’21â€‹K2,2â€‹y22â€‹Î±22â€‹âˆ’K1,2â€‹y1â€‹y2â€‹Î±1â€‹Î±2â€‹âˆ’y1â€‹Î±1â€‹i=3âˆ‘mâ€‹Î±iâ€‹yiâ€‹Ki,1â€‹âˆ’y2â€‹Î±2â€‹i=3âˆ‘mâ€‹Î±iâ€‹yiâ€‹Ki,2â€‹+C(3) æ ¹æ®(2) Î±1y1+Î±2y2=âˆ’âˆ‘i=3NÎ±iyi=Î·\\alpha_1y_1 + \\alpha_2y_2 = -\\sum_{i=3}^{N}\\alpha_iy_i = \\eta Î±1â€‹y1â€‹+Î±2â€‹y2â€‹=âˆ’i=3âˆ‘Nâ€‹Î±iâ€‹yiâ€‹=Î· ä¸¤è¾¹åŒæ—¶ä¹˜ä»¥y1,ç”±äºyi2=1y_1,ç”±äºy_i^2 = 1y1â€‹,ç”±äºyi2â€‹=1 (4)Î±1=Î·y1âˆ’Î±2y1y2\\alpha_1 = \\eta y_1 - \\alpha_2y_1y_2 \\tag{4} Î±1â€‹=Î·y1â€‹âˆ’Î±2â€‹y1â€‹y2â€‹(4) ä»¤ï¼š (5)v1=âˆ‘i=3NÎ±iyiKi,1,v2=âˆ‘i=3NÎ±iyiKi,2v_1 = \\sum^{N}_{i=3}\\alpha_iy_iK_{i,1}, \\quad v_2 = \\sum^{N}_{i=3}\\alpha_iy_iK_{i,2} \\tag{5} v1â€‹=i=3âˆ‘Nâ€‹Î±iâ€‹yiâ€‹Ki,1â€‹,v2â€‹=i=3âˆ‘Nâ€‹Î±iâ€‹yiâ€‹Ki,2â€‹(5) å°† (4), (5) å¸¦å…¥(3) (6)W(Î±2)=âˆ’12K1,1(Î·âˆ’Î±2y2)2âˆ’12K2,2Î±22âˆ’K1,2y2Î±2(Î·âˆ’Î±2y2)âˆ’v1(Î·âˆ’Î±2y2)âˆ’v2y2Î±2+Î±1+Î±2+CW(\\alpha_2) = - \\frac{1}{2}K_{1,1}(\\eta - \\alpha_2y_2)^2 - \\frac{1}{2}K_{2,2}\\alpha_2^2 - K_{1,2}y_2\\alpha_2(\\eta - \\alpha_2y_2) - v_1(\\eta - \\alpha_2y_2) - v_2y_2\\alpha_2 + \\alpha_1 + \\alpha_2 + C \\tag{6} W(Î±2â€‹)=âˆ’21â€‹K1,1â€‹(Î·âˆ’Î±2â€‹y2â€‹)2âˆ’21â€‹K2,2â€‹Î±22â€‹âˆ’K1,2â€‹y2â€‹Î±2â€‹(Î·âˆ’Î±2â€‹y2â€‹)âˆ’v1â€‹(Î·âˆ’Î±2â€‹y2â€‹)âˆ’v2â€‹y2â€‹Î±2â€‹+Î±1â€‹+Î±2â€‹+C(6) ç”±äºéœ€è¦æ›´æ–°Î±2\\alpha_2Î±2â€‹æ‰€ä»¥ä»¤dWdÎ±=0\\frac{dW}{d\\alpha} = 0dÎ±dWâ€‹=0 (7)âˆ‚W(Î±2)âˆ‚Î±2=âˆ’Î±2(K1,1+K2,2âˆ’2K1,2)+K1,1Î·y2âˆ’K1,2Î·y2+v1y2âˆ’v2y2âˆ’y1y2+y22=0\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -\\alpha_2(K_{1,1} + K_{2,2} - 2K_{1,2}) + K_{1,1}\\eta y_2 - K_{1,2}\\eta y_2 + v_1y_2 - v_2y_2 - y_1y_2 + y_2^2 = 0 \\tag{7} âˆ‚Î±2â€‹âˆ‚W(Î±2â€‹)â€‹=âˆ’Î±2â€‹(K1,1â€‹+K2,2â€‹âˆ’2K1,2â€‹)+K1,1â€‹Î·y2â€‹âˆ’K1,2â€‹Î·y2â€‹+v1â€‹y2â€‹âˆ’v2â€‹y2â€‹âˆ’y1â€‹y2â€‹+y22â€‹=0(7) å¯¹(7)å¼å˜å½¢ï¼Œä½¿å¾—Î±2new\\alpha_2^newÎ±2nâ€‹ewèƒ½è¢«Î±2old\\alpha_2^oldÎ±2oâ€‹ldè¡¨ç¤º(è€Œä¸æ˜¯ç”¨ä¸æ–¹ä¾¿çš„\\eta)ï¼š SVMé¢„æµ‹å€¼å¦‚ä¸‹(è¯¥å¼å­ä¸éœ€è¦ä¿ç•™æ‰€æœ‰çš„xï¼Œå› ä¸ºå¾ˆå¤šæ— å…³çš„xçš„alphaéƒ½ä¸º0ï¼Œå› æ­¤alphaéœ€è¦åˆå§‹åŒ–ä¸º0)ï¼š (8)f(x)=âˆ‘i=1NÎ±iyiK(xi,x)+bf(x) = \\sum_{i=1}^{N}\\alpha_iy_iK(x_i,x) + b \\tag{8} f(x)=i=1âˆ‘Nâ€‹Î±iâ€‹yiâ€‹K(xiâ€‹,x)+b(8) åˆ™vå¯ä»¥è¡¨ç¤ºä¸ºï¼š v1=âˆ‘i=3NÎ±iyiK1,i=f(x1)âˆ’Î±1y1K1,1âˆ’Î±2y2K1,2âˆ’bv_1 = \\sum^{N}_{i=3}\\alpha_iy_iK_{1,i} = f(x_1) - \\alpha_1y_1K_{1,1} - \\alpha_2y_2K_{1,2} - b v1â€‹=i=3âˆ‘Nâ€‹Î±iâ€‹yiâ€‹K1,iâ€‹=f(x1â€‹)âˆ’Î±1â€‹y1â€‹K1,1â€‹âˆ’Î±2â€‹y2â€‹K1,2â€‹âˆ’b v2=âˆ‘i=3NÎ±iyiK2,i=f(x2)âˆ’Î±1y1K1,2âˆ’Î±2y2K2,2âˆ’bv_2 = \\sum^{N}_{i=3}\\alpha_iy_iK_{2,i} = f(x_2) - \\alpha_1y_1K_{1,2} - \\alpha_2y_2K_{2,2} - b v2â€‹=i=3âˆ‘Nâ€‹Î±iâ€‹yiâ€‹K2,iâ€‹=f(x2â€‹)âˆ’Î±1â€‹y1â€‹K1,2â€‹âˆ’Î±2â€‹y2â€‹K2,2â€‹âˆ’b å·²çŸ¥ï¼š Î±1=(Î·âˆ’Î±2y2)y2\\alpha_1= (\\eta - \\alpha_2y_2)y_2 Î±1â€‹=(Î·âˆ’Î±2â€‹y2â€‹)y2â€‹ å¯å¾—åˆ°ï¼š (9)v1âˆ’v2=f(x1)âˆ’f(x2)âˆ’K1,1Î·+K1,2Î·+Î±2y2(K1,1+K2,2âˆ’2K1,2)v_1 - v_2 = f(x_1) - f(x_2) - K_{1,1}\\eta + K_{1,2}\\eta + \\alpha_2y_2(K_{1,1}+K_{2,2}-2K_{1,2}) \\tag{9} v1â€‹âˆ’v2â€‹=f(x1â€‹)âˆ’f(x2â€‹)âˆ’K1,1â€‹Î·+K1,2â€‹Î·+Î±2â€‹y2â€‹(K1,1â€‹+K2,2â€‹âˆ’2K1,2â€‹)(9) å°†(9)å¸¦å…¥(7): âˆ‚W(Î±2)âˆ‚Î±2=âˆ’(K1,1+K2,2âˆ’2K1,2)Î±2new+(K1,1+K2,2âˆ’2K1,2)Î±2old+y2(y2âˆ’y1+f(x1)âˆ’f(x2))\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -(K_{1,1} + K_{2,2} - 2K_{1,2})\\alpha_2^{new} + (K_{1,1} + K_{2,2}- 2K_{1,2})\\alpha_2^{old} + y_2(y_2 - y_1 + f(x_1) - f(x_2)) âˆ‚Î±2â€‹âˆ‚W(Î±2â€‹)â€‹=âˆ’(K1,1â€‹+K2,2â€‹âˆ’2K1,2â€‹)Î±2newâ€‹+(K1,1â€‹+K2,2â€‹âˆ’2K1,2â€‹)Î±2oldâ€‹+y2â€‹(y2â€‹âˆ’y1â€‹+f(x1â€‹)âˆ’f(x2â€‹)) è®°è¯¯å·®é¡¹Ei=f(xi)âˆ’yiE_i = f(x_i) - y_iEiâ€‹=f(xiâ€‹)âˆ’yiâ€‹ ä»¤Î¸=K1,1,+K2,2âˆ’2K1,2\\theta = K_{1,1,}+K_{2,2}-2K_{1,2}Î¸=K1,1,â€‹+K2,2â€‹âˆ’2K1,2â€‹ å¯ä»¥å¾—åˆ°æœ€ç»ˆè¡¨è¾¾å¼ï¼š âˆ‚W(Î±2)âˆ‚Î±2=âˆ’Î¸Î±2new+Î¸Î±2old+y2(E1âˆ’E2)=0\\frac{\\partial W(\\alpha_2)}{\\partial \\alpha_2} = -\\theta\\alpha_2^{new}+ \\theta\\alpha_2^{old}+y2(E_1-E_2) = 0 âˆ‚Î±2â€‹âˆ‚W(Î±2â€‹)â€‹=âˆ’Î¸Î±2newâ€‹+Î¸Î±2oldâ€‹+y2(E1â€‹âˆ’E2â€‹)=0 å¾—åˆ°ï¼š (10)Î±2new=Î±2old+y2(E1âˆ’E2)Î¸\\alpha_2^{new} = \\alpha_2^{old} + \\frac{y_2(E_1- E_2)}{\\theta} \\tag{10} Î±2newâ€‹=Î±2oldâ€‹+Î¸y2â€‹(E1â€‹âˆ’E2â€‹)â€‹(10) åˆ°äº†è¿™é‡Œï¼Œå¦‚æœè¦æ›´æ–°å‚æ•°ï¼Œä»…éœ€è®¡ç®—Eï¼Œå’Œ\\theta ç„¶åè®¡ç®—\\alpha2 åŸå§‹è§£çš„ä¿®å‰ª ç°åœ¨è€ƒè™‘çº¦æŸæ¡ä»¶ ä¸Šé¢é€šè¿‡å¯¹ä¸€å…ƒå‡½æ•°æ±‚æå€¼çš„æ–¹å¼æ›´æ–°äº†å‚æ•°å¾—åˆ°äº†Î±2new,unclipped\\alpha_2^{new,unclipped}Î±2new,unclippedâ€‹ ç°åœ¨é€šè¿‡å¯¹åŸå§‹è§£çš„ä¿®æ­£å¾—åˆ°Î±2new,cilpped\\alpha_2^{new,cilpped}Î±2new,cilppedâ€‹ (10)Î±2new,unclipped=Î±2old+y2(E1âˆ’E2)Î¸\\alpha_2^{new,unclipped} = \\alpha_2^{old} + \\frac{y_2(E_1- E_2)}{\\theta} \\tag{10} Î±2new,unclippedâ€‹=Î±2oldâ€‹+Î¸y2â€‹(E1â€‹âˆ’E2â€‹)â€‹(10) çº¦æŸæ¡ä»¶ï¼ˆç”»å›¾åˆ†æï¼‰ï¼š ify1â‰ y2:if \\quad y_1 \\ne y_2 :ify1â€‹î€ â€‹=y2â€‹: ä¸Šç•Œï¼šL=max(0,Î±2oldâˆ’Î±1old)ä¸Šç•Œï¼š\\qquad L = max(0, \\quad \\alpha_2^{old} - \\alpha_1^{old}) ä¸Šç•Œï¼šL=max(0,Î±2oldâ€‹âˆ’Î±1oldâ€‹) ä¸‹ç•Œï¼šH=max(C,C+Î±2oldâˆ’Î±1old)ä¸‹ç•Œï¼š\\qquad H = max(C, \\quad C+\\alpha_2^{old} - \\alpha_1^{old}) ä¸‹ç•Œï¼šH=max(C,C+Î±2oldâ€‹âˆ’Î±1oldâ€‹) elify1=y2:elif \\quad y_1 = y_2 :elify1â€‹=y2â€‹: ä¸Šç•Œï¼šL=max(0,Î±2old+Î±1oldâˆ’C)ä¸Šç•Œï¼š\\qquad L = max(0, \\quad \\alpha_2^{old} + \\alpha_1^{old} -C) ä¸Šç•Œï¼šL=max(0,Î±2oldâ€‹+Î±1oldâ€‹âˆ’C) ä¸‹ç•Œï¼šH=max(C,Î±2old+Î±1old)ä¸‹ç•Œï¼š\\qquad H = max(C, \\quad \\alpha_2^{old} + \\alpha_1^{old}) ä¸‹ç•Œï¼šH=max(C,Î±2oldâ€‹+Î±1oldâ€‹) æ›´æ–°å‚æ•°éƒ½å¯ä»¥è®¡ç®—ï¼šÎ±1new\\alpha_1^{new}Î±1newâ€‹ ç”±ï¼š Î±1oldy1+Î±2oldy2=Î±1newy1+Î±2newy2\\alpha_1^{old}y_1 + \\alpha_2^{old}y_2 = \\alpha_1^{new}y_1 + \\alpha_2^{new}y_2 Î±1oldâ€‹y1â€‹+Î±2oldâ€‹y2â€‹=Î±1newâ€‹y1â€‹+Î±2newâ€‹y2â€‹ å¾—åˆ°ï¼š Î±1new=Î±1old+y1y2(Î±2oldâˆ’Î±2new)\\alpha_1^{new} = \\alpha_1^{old} + y_1y_2(\\alpha_2^{old} - \\alpha_2^{new}) Î±1newâ€‹=Î±1oldâ€‹+y1â€‹y2â€‹(Î±2oldâ€‹âˆ’Î±2newâ€‹) æœ€åç”±å¼(6.17)-&gt;(6.18)å¯å¾—åˆ°ï¼š b=1mâˆ‘s=1m[1/ysâˆ’âˆ‘mi=1Î±iyixiTxs]b = \\frac{1}{m}\\sum_{s=1}^{m}[1/y_s - \\sum_{m}^{i=1}\\alpha_iy_ix_i^Tx_s] b=m1â€‹s=1âˆ‘mâ€‹[1/ysâ€‹âˆ’mâˆ‘i=1â€‹Î±iâ€‹yiâ€‹xiTâ€‹xsâ€‹] 3.å¯å‘å¼é€‰æ‹©å˜é‡ ä¸Šè¿°åˆ†ææ˜¯åœ¨ä»Nä¸ªå˜é‡ä¸­å·²ç»é€‰å‡ºä¸¤ä¸ªå˜é‡è¿›è¡Œä¼˜åŒ–çš„æ–¹æ³•ï¼Œä¸‹é¢åˆ†æå¦‚ä½•é«˜æ•ˆåœ°é€‰æ‹©ä¸¤ä¸ªå˜é‡è¿›è¡Œä¼˜åŒ–ï¼Œä½¿å¾—ç›®æ ‡å‡½æ•°ä¸‹é™çš„æœ€å¿«ã€‚ ç¬¬ä¸€ä¸ªå˜é‡çš„é€‰æ‹© ç¬¬ä¸€ä¸ªå˜é‡çš„é€‰æ‹©ç§°ä¸ºå¤–å¾ªç¯ï¼Œé¦–å…ˆéå†æ•´ä¸ªæ ·æœ¬é›†ï¼Œé€‰æ‹©è¿åKKTæ¡ä»¶çš„Î±i\\alpha_iÎ±iâ€‹ä½œä¸ºç¬¬ä¸€ä¸ªå˜é‡ æ¥ç€ä¾æ®ç›¸å…³è§„åˆ™é€‰æ‹©ç¬¬äºŒä¸ªå˜é‡(è§ä¸‹é¢åˆ†æ),å¯¹è¿™ä¸¤ä¸ªå˜é‡é‡‡ç”¨ä¸Šè¿°æ–¹æ³•è¿›è¡Œä¼˜åŒ–ã€‚ å½“éå†å®Œæ•´ä¸ªæ ·æœ¬é›†åï¼Œéå†éè¾¹ç•Œæ ·æœ¬(0&lt;Î±i&lt;C)(0&lt;Î±_i&lt;C)(0&lt;Î±iâ€‹&lt;C)ä¸­è¿åKKTçš„Î±i\\alpha_iÎ±iâ€‹ä½œä¸ºç¬¬ä¸€ä¸ªå˜é‡ï¼ŒåŒæ ·ä¾æ®ç›¸å…³è§„åˆ™é€‰æ‹©ç¬¬äºŒä¸ªå˜é‡ï¼Œå¯¹æ­¤ä¸¤ä¸ªå˜é‡è¿›è¡Œä¼˜åŒ–ã€‚å½“éå†å®Œéè¾¹ç•Œæ ·æœ¬é›†åï¼Œå†æ¬¡å›åˆ°éå†æ•´ä¸ªæ ·æœ¬é›†ä¸­å¯»æ‰¾ï¼Œå³åœ¨æ•´ä¸ªæ ·æœ¬é›†ä¸éè¾¹ç•Œæ ·æœ¬é›†ä¸Šæ¥å›åˆ‡æ¢ï¼Œå¯»æ‰¾è¿åKKTæ¡ä»¶çš„Î±iÎ±iä½œä¸ºç¬¬ä¸€ä¸ªå˜é‡ã€‚ç›´åˆ°éå†æ•´ä¸ªæ ·æœ¬é›†åï¼Œæ²¡æœ‰è¿åKKTæ¡ä»¶Î±i\\alpha_iÎ±iâ€‹ï¼Œç„¶åé€€å‡ºã€‚ è¾¹ç•Œä¸Šçš„æ ·æœ¬å¯¹åº”çš„Î±i=0\\alpha_i = 0Î±iâ€‹=0æˆ–è€…Î±i=C\\alpha_i = CÎ±iâ€‹=Cï¼Œåœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­å¾ˆéš¾å˜åŒ–ï¼Œç„¶è€Œéè¾¹ç•Œæ ·æœ¬0&lt;Î±i&lt;C0&lt;Î±_i&lt;C0&lt;Î±iâ€‹&lt;Cä¼šéšç€å¯¹å…¶ä»–å˜é‡çš„ä¼˜åŒ–ä¼šæœ‰å¤§çš„å˜åŒ–ã€‚ KTTæ¡ä»¶ Î±i=0âŸºy(i)(wTx(i)+b)â‰¥1\\alpha_i = 0 \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b)\\ge1 Î±iâ€‹=0âŸºy(i)(wTx(i)+b)â‰¥1 Î±i=CâŸºy(i)(wTx(i)+b)â‰¤1\\alpha_i = C \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b)\\le 1 Î±iâ€‹=CâŸºy(i)(wTx(i)+b)â‰¤1 0&lt;Î±i&lt;CâŸºy(i)(wTx(i)+b)=10 \\lt \\alpha_i \\lt C \\Longleftrightarrow y^{(i)}(w^Tx^{(i)}+b) =1 0&lt;Î±iâ€‹&lt;CâŸºy(i)(wTx(i)+b)=1 ç¬¬äºŒä¸ªå˜é‡çš„é€‰æ‹© SMOç§°ç¬¬äºŒä¸ªå˜é‡çš„é€‰æ‹©è¿‡ç¨‹ä¸ºå†…å¾ªç¯ï¼Œå‡è®¾åœ¨å¤–å¾ªç¯ä¸­æ‰¾ä¸ªç¬¬ä¸€ä¸ªå˜é‡è®°ä¸ºÎ±1\\alpha_1Î±1â€‹ï¼Œç¬¬äºŒä¸ªå˜é‡çš„é€‰æ‹©å¸Œæœ›èƒ½ä½¿Î±2\\alpha_2Î±2â€‹æœ‰è¾ƒå¤§çš„å˜åŒ–ï¼Œç”±äºÎ±2\\alpha_2Î±2â€‹æ˜¯ä¾èµ–äºâˆ£E1âˆ’E2âˆ£|E1âˆ’E2|âˆ£E1âˆ’E2âˆ£,å½“E1E1E1ä¸ºæ­£æ—¶ï¼Œé‚£ä¹ˆé€‰æ‹©æœ€å°çš„EiEiEiä½œä¸ºE2E2E2,å¦‚æœE1E1E1ä¸ºè´Ÿï¼Œé€‰æ‹©æœ€å¤§EiEiEiä½œä¸ºE2E2E2ï¼Œé€šå¸¸ä¸ºæ¯ä¸ªæ ·æœ¬çš„EiEiEiä¿å­˜åœ¨ä¸€ä¸ªåˆ—è¡¨ä¸­ï¼Œé€‰æ‹©æœ€å¤§çš„âˆ£E1âˆ’E2âˆ£|E1âˆ’E2|âˆ£E1âˆ’E2âˆ£æ¥è¿‘ä¼¼æœ€å¤§åŒ–æ­¥é•¿ã€‚ æœ‰æ—¶æŒ‰ç…§ä¸Šè¿°çš„å¯å‘å¼é€‰æ‹©ç¬¬äºŒä¸ªå˜é‡ï¼Œä¸èƒ½å¤Ÿä½¿å¾—å‡½æ•°å€¼æœ‰è¶³å¤Ÿçš„ä¸‹é™ï¼Œè¿™æ—¶æŒ‰ä¸‹è¿°æ­¥éª¤: 1.é¦–å…ˆåœ¨éè¾¹ç•Œé›†ä¸Šé€‰æ‹©èƒ½å¤Ÿä½¿å‡½æ•°å€¼è¶³å¤Ÿä¸‹é™çš„æ ·æœ¬ä½œä¸ºç¬¬äºŒä¸ªå˜é‡ï¼Œ 2.å¦‚æœéè¾¹ç•Œé›†ä¸Šæ²¡æœ‰ï¼Œåˆ™åœ¨æ•´ä¸ªæ ·æœ¬é›†ä¸Šé€‰æ‹©ç¬¬äºŒä¸ªå˜é‡ï¼Œ 3.å¦‚æœæ•´ä¸ªæ ·æœ¬é›†ä¾ç„¶ä¸å­˜åœ¨ï¼Œåˆ™é‡æ–°é€‰æ‹©ç¬¬ä¸€ä¸ªå˜é‡ã€‚ å‚è€ƒ æœºå™¨å­¦ä¹ ç®—æ³•å®è·µ-SVMä¸­çš„SMOç®—æ³• è¯¦ç»†æ¨å¯¼çš„SMOæ›´æ–°å‚æ•°å’Œä¿®å‰ªç»“æœçš„å…¬å¼ï¼Œ ä¼˜åŒ–ç®—æ³•æ•ˆç‡ï¼šä¾‹å¦‚åªéœ€æœ€åè®¡ç®—bã€‚ã€‚ã€‚ã€‚ æµ…è°ˆæœ€ä¼˜åŒ–é—®é¢˜çš„KKTæ¡ä»¶ import numpy as np import matplotlib.pyplot as plt import copy from sklearn.metrics import roc_curve, auc, accuracy_score, confusion_matrix, classification_report, roc_auc_score np.random.seed(1) å®šä¹‰è®­ç»ƒé›† XtrainâˆˆRnÃ—mX_{train} \\in \\R^{n \\times m} Xtrainâ€‹âˆˆRnÃ—m xiâˆˆRn,å³æ¯ä¸€ä¸ªæ ·æœ¬æœ‰nä¸ªç‰¹å¾x_i \\in \\R^n,å³æ¯ä¸€ä¸ªæ ·æœ¬æœ‰nä¸ªç‰¹å¾ xiâ€‹âˆˆRn,å³æ¯ä¸€ä¸ªæ ·æœ¬æœ‰nä¸ªç‰¹å¾ labelâˆˆ{âˆ’1,1},äºŒåˆ†ç±»é—®é¢˜label \\in \\{-1,1\\},äºŒåˆ†ç±»é—®é¢˜ labelâˆˆ{âˆ’1,1},äºŒåˆ†ç±»é—®é¢˜ å¤šç§æ ¸å‡½æ•° def LinearKernel(x_i, x_j): if x_i.shape[1] != 1: raise Exception(&quot;x_i is wrong shape!&quot;) if x_j.shape[1] != 1: raise Exception(&quot;x_j is wrong shape!&quot;) return np.dot(x_i.T, x_j) def GaussKernel(x_i, x_j, sigmoid): if x_i.shape[1] != 1: raise Exception(&quot;x_i is wrong shape!&quot;) if x_j.shape[1] != 1: raise Exception(&quot;x_j is wrong shape!&quot;) if sigmoid &lt;= 0: raise Exception(&quot;sigmoid must be a positive number&quot;) return np.exp(-np.dot((x_i - x_j).T, (x_i - x_j))/(2 * sigmoid**2)) def PolyKernel(x_i, x_j, d): if x_i.shape[1] != 1: raise Exception(&quot;x_i is wrong shape!&quot;) if x_j.shape[1] != 1: raise Exception(&quot;x_j is wrong shape!&quot;) if d &lt; 0: raise Exception(&quot;d must be a Semi-positive number&quot;) return LinearKernel(x_i, x_j)**d def LaplaceKernel(x_i, x_j, s): if x_i.shape[1] != 1: raise Exception(&quot;x_i is wrong shape!&quot;) if x_j.shape[1] != 1: raise Exception(&quot;x_j is wrong shape!&quot;) if s &lt;= 0: raise Exception(&quot;sigmoid must be a positive number&quot;) # print(np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / sigmoid)) return np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / s)[0][0] def SigmoidKernel(x_i, x_j, beta, theta): if x_i.shape[1] != 1: raise Exception(&quot;x_i is wrong shape!&quot;) if x_j.shape[1] != 1: raise Exception(&quot;x_j is wrong shape!&quot;) if theta &gt;= 0: raise Exception(&quot;theta must be a negetive number&quot;) if beta &lt;= 0: raise Exception(&quot;theta must be a positive number&quot;) return np.tanh(beta * LinearKernel(x_i, x_j) + theta) def K(x_i, x_j, kernel = &quot;linear&quot;, s = .5, beta = 1, theta = -1, d = 2): # print(x_i.shape, x_j.shape) kernel = kernel.lower() try: if kernel == 'linear': return LinearKernel(x_i, x_j) elif kernel == 'gauss': return GaussKernel(x_i, x_j, s) elif kernel == 'poly': return PolyKernel(x_i, x_j, d) elif kernel == 'laplace': return LaplaceKernel(x_i, x_j, s) elif kernel == 'sigmoid': return SigmoidKernel(x_i, x_j, beta, theta) except Exception as err: print('An exception happened: ' + str(err)) if __name__ == &quot;__main__&quot;: x_i = np.ones((10,1)) x_j = np.random.randn(10,1) print(np.exp(-np.sqrt(np.dot((x_i - x_j).T, (x_i - x_j))) / 1)) print(K(x_i,x_j,kernel=&quot;Laplace&quot;, s=1)) [[0.005973]] 0.005973003723489288 ç”ŸæˆåŒå¿ƒåœ†æ•°æ® import numpy as np def load(type = &quot;circle&quot;): x = np.random.uniform(-1,1,(100,1)) y = np.random.uniform(-1,1,(100,1)) x_train = np.c_[x,y].T print(x_train.shape) label_train = np.ones((100,1)) mask = (x**2 + y**2 ) &lt; .5 label_train[mask] = -1 x1 = np.random.uniform(-1,1,(100,1)) y1 = np.random.uniform(-1,1,(100,1)) x_test = np.c_[x1,y1].T print(x_test.shape) label_test = np.ones((100,1)) mask = (x1**2 + y1**2 ) &lt; .5 label_test[mask] = -1 return x_train, label_train, x_test, label_test if __name__ == &quot;__main__&quot;: x_train, label_train, x_test, label_test = load() print(x_train.shape, label_train.shape, x_test.shape, label_test.shape) (2, 100) (2, 100) (2, 100) (100, 1) (2, 100) (100, 1) å‚ç…§ç¬¬ä¸€ä¸ªSMOæ¨å¯¼ç¬”è®°éœ€è¦å®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š åˆå§‹åŒ–å‚æ•°ï¼ˆä¸»è¦æ˜¯\\alphaï¼‰ ç”±äºé‡‡ç”¨ç¼“å­˜ï¼ˆç”¨ä¸€ä¸ªåˆ—è¡¨è®°å½•ï¼‰æ‰€æœ‰çš„Ei=yiâˆ’f(xi)E_i = y_i - f(x_i)Eiâ€‹=yiâ€‹âˆ’f(xiâ€‹) æ‰€ä»¥æ¯ä¸€æ¬¡æ›´æ–°å‚æ•°Î±\\alphaÎ±åéƒ½éœ€è¦æ›´æ–°Ei,EjE_i, E_jEiâ€‹,Ejâ€‹ å› ä¸ºç”±KKTæ¡ä»¶çº¦æŸï¼Œæ‰€ä»¥éœ€è¦å¯¹æœ€åçš„ç»“æœè¿›è¡Œä¿®å‰ª æ‰€ä»¥éœ€è¦å®ç° clip() f(indexi)ç”¨äºå®ç°å¯¹è®­ç»ƒé›†çš„æŸä¸€ä¸ªç‰¹å¾å‘é‡è®¡ç®—é¢„æµ‹å€¼f(index_i)ç”¨äºå®ç°å¯¹è®­ç»ƒé›†çš„æŸä¸€ä¸ªç‰¹å¾å‘é‡è®¡ç®—é¢„æµ‹å€¼f(indexiâ€‹)ç”¨äºå®ç°å¯¹è®­ç»ƒé›†çš„æŸä¸€ä¸ªç‰¹å¾å‘é‡è®¡ç®—é¢„æµ‹å€¼ predict(xi)ç”¨äºé¢„æµ‹ä»»æ„ç»™å®šçš„ç‰¹å¾å‘é‡xipredict(x_i)ç”¨äºé¢„æµ‹ä»»æ„ç»™å®šçš„ç‰¹å¾å‘é‡x_ipredict(xiâ€‹)ç”¨äºé¢„æµ‹ä»»æ„ç»™å®šçš„ç‰¹å¾å‘é‡xiâ€‹ select()å‡½æ•°çš„å†…å¾ªç¯å’Œå¤–å¾ªç¯ç”¨äºé€‰æ‹©æœ€ä¸æ»¡è¶³KKTæ¡ä»¶çš„å¹¶ä¸”èƒ½å¤Ÿä½¿å¾—æ›´æ–°æ•ˆæœæœ€æ˜æ˜¾çš„Î±iÎ±j\\alpha_i \\quad \\alpha_jÎ±iâ€‹Î±jâ€‹ loss()ç”¨äºè®¡ç®—E update_a2()ç”¨äºæ›´æ–°Î±2\\alpha_2Î±2â€‹ update_a1()ä½¿ç”¨Î±2\\alpha_2Î±2â€‹å’ŒÎ±1old\\alpha_1^{old}Î±1oldâ€‹æ›´æ–°Î±1\\alpha_1Î±1â€‹ SMO()æ˜¯smoç®—æ³•çš„ä¸»å¾ªç¯ ä»¥ä¸Šå‡½æ•°ä¸SMOç®—æ³•ç´§å¯†ç›¸å…³ï¼Œä¸ºäº†æ–¹ä¾¿å‚æ•°ï¼Œæ•°æ®é›†ï¼Œçš„ä¼ è¾“å°†ä»–ä»¬æ”¾åˆ°ä¸€ä¸ªSMOç±»ä¸­å®ç° class SMO: def __init__(self, x, y, kernel = &quot;Laplace&quot;, C=10): self.x = copy.deepcopy(x) self.y = copy.deepcopy(y) self.m = x.shape[1] self.n = x.shape[0] self.kernel = kernel self.C = C def init(self): # self.w = np.random.randn(self.n, 1) self.b = np.zeros((1, 1)) self.a = np.zeros((self.m, 1)) E = [] for i in range(0, self.m): E.append(self.loss(i)) self.E = E # æ¯æ¬¡æ›´æ–°å‚æ•°åéœ€è¦æ›´æ–°E def updateE(self, i, j): self.E[i] = self.loss(i) self.E[j] = self.loss(j) def clip(self, index_1, index_2, old_1, old_2): # get H, L alpha = self.a[index_2,:][0] if self.y[index_1, :] != self.y[index_2, :]: L = max(0.0, old_2[0] - old_1[0]) H = max(self.C, self.C + old_2[0] - old_1[0]) else: # print(&quot;----------&quot; , self.C, old_2[0], self.C + old_2[0],'-------------') L = max(0.0, old_2[0] + old_1[0] - self.C) H = max(self.C, old_2[0] + old_1[0]) if alpha &lt; L: return L elif alpha &gt; H: return H else: return alpha def f(self, x_index): k = np.zeros(self.y.shape) for i in range(0, self.m): k[i,:] = copy.deepcopy(K(self.x[:,i].reshape(-1,1), self.x[:,x_index].reshape(-1,1), kernel = self.kernel)) return np.sum(self.a * self.y * k)+self.b # æ­¤å¤„æ˜¯é€‰æ‹©ç¬¬äºŒä¸ªå˜é‡ï¼Œç¬¬ä¸€ä¸ªå˜é‡ä»…éœ€è¦æ— è„‘ä¾¿åˆ©å°±å¥½äº† # éœ€è¦ä¼ å…¥ç¬¬ä¸€ä¸ªå˜é‡çš„indexä»¥è®¡ç®—E_1 # æ˜¯å¦å¯ä»¥å°†selectå†™æˆä¸€ä¸ªç”Ÿæˆå™¨ï¼Ÿ def select(self): for i in range(0, self.m): # labelç”¨äºæ ‡å¿—æ˜¯å¦è¿åKKT label = False temp = self.y[i, :] * self.f(i) if self.a[i, :] == 0: if temp &lt; 1 : label = True elif 0 &lt; self.a[i, :] and self.a[i, :] &lt; self.C: if temp &gt; 1: label = True else: if temp != 1: label = True # å¦‚æœè¿åKKTæ¡ä»¶ï¼Œè¿›å…¥å†…å¾ªç¯é€‰æ‹©ç¬¬äºŒä¸ªa if label == True and self.E[i] &lt;= 0: j = np.argmax(np.array(self.E)) yield i,j if label == True and self.E[i] &gt;0: j = np.argmin(np.array(self.E)) yield i,j # éœ€è¦å¾—åˆ°è¾¹ç•Œå˜é‡çš„ä¸‹æ ‡å€¼ boolen = (self.a &gt; 0) &amp; (self.a &lt; self.C) edgeVar = [] for i in range(0, len(boolen)): if boolen[i] == True: edgeVar.append(i) for i in edgeVar: # labelç”¨äºæ ‡å¿—æ˜¯å¦è¿åKKT label = False temp = self.y[i, :] * self.f(i) if self.a[i, :] == 0: if temp &lt; 1 : label = True elif 0 &lt; self.a[i, :] and self.a[i, :] &lt; self.C: if temp &gt; 1: label = True else: if temp != 1: label = True # å¦‚æœè¿åKKTæ¡ä»¶ï¼Œè¿›å…¥å†…å¾ªç¯é€‰æ‹©ç¬¬äºŒä¸ªa if label == True and self.E[i] &lt;= 0: j = np.argmax(np.array(self.E)) yield i,j if label == True and self.E[i] &gt;0: j = np.argmin(np.array(self.E)) yield i,j # E_i = f(x_i) - y_i def loss(self, index): return self.f(index) - self.y[index, :] def update_a2(self, alpha2_old, index_1, index_2): theta = K(self.x[:,index_1].reshape(-1,1), self.x[:,index_1].reshape(-1,1), kernel = self.kernel) + K(self.x[:,index_2].reshape(-1,1), self.x[:,index_2].reshape(-1,1), kernel = self.kernel) - 2*K(self.x[:,index_1].reshape(-1,1), self.x[:,index_2].reshape(-1,1), kernel = self.kernel) if theta &lt; 0.001 and theta &gt;= 0: theta = 0.001 if theta &gt; -0.001 and theta &lt;0: theta = 0.001 dE = self.E[index_1] - self.E[index_2] # print(&quot;in update_a2 theta:{}, dE:{}, y2:{}&quot;.format(theta, dE, self.y[index_2])) return alpha2_old + (self.y[index_2] * dE) / theta def update_a1(self, alpha1_old, alpha2_old, alpha2_new, index_1, index_2): return alpha1_old + self.y[index_1] * self.y[index_2] * (alpha2_old - alpha2_new) def SMO(self, maxtimes): for i in range(0, maxtimes): if i % 10 == 0: print(&quot;this is {}th loop.&quot;.format(i)) for i, j in self.select(): temp = copy.deepcopy(self.a[j]) self.a[j] = self.update_a2(self.a[j], i, j) self.a[j] = self.clip(i, j, self.a[i], temp) self.a[i] = self.update_a1(self.a[i], temp, self.a[j], i, j) self.updateE(i, j) # æ›´æ–°b self.b = np.sum(1/self.y)/self.m for i in range(0, self.m): self.b -= (self.f(i)/self.m) print(self.b) def predict(self, x): k = np.zeros(self.y.shape) for i in range(0, self.m): k[i,:] = copy.deepcopy(K(self.x[:,i].reshape(-1,1), x.reshape(-1,1), kernel = self.kernel)) # return k return (np.sum(self.a * self.y * k) + self.b) def predictAll(self, x_test): # get prected y y_pred = np.zeros(y_test.shape) for i in range(0, x_test.shape[1]): y_pred[i, :] = self.predict(x_test[:, i].reshape(2, -1)) return y_pred def evaluate(y_t, y_p): y_test = copy.deepcopy(y_t) y_pred = copy.deepcopy(y_p) print(&quot;The roc_auc_score is {}&quot;.format(roc_auc_score(y_test, y_pred))) tpr,fpr,thresholds = roc_curve(y_test,y_pred) plt.subplot(1,2,1) plt.plot(fpr, tpr) plt.xlim([0.0, 1.0]) plt.ylim([0.0, 1.0]) plt.title('ROC curve for diabetes classifier') plt.xlabel('False Positive Rate (1 - Specificity)') plt.ylabel('True Positive Rate (Sensitivity)') plt.grid(True) # mean = np.sum(y_pred)/y_pred.shape[0] y_pred[(y_pred &lt; 0)] = -1 y_pred[(y_pred &gt;= 0)] = 1 # plt.scatter(x_test[0, :], x_test[1, :], c = y_pred[:, 0]) print(&quot;The accuracy is {}&quot;.format(accuracy_score(y_test[:,0], y_pred[:,0]))) # è®¡ç®—å¬å›ï¼Œ æŸ¥å…¨ç‡ï¼Œ æŸ¥å‡†ç‡ ã€‚ã€‚ã€‚ã€‚ target_names = ['class0','class1'] print(classification_report(y_test,y_pred,target_names = target_names)) def draw_svm(smo): xx, yy = np.meshgrid(np.arange(-1, 1, 0.01), np.arange(-1, 1, 0.01)) zz = np.zeros((200, 200)) for i in range(0, 200): for j in range(0, 200): temp = np.array([xx[i, j], yy[i, j]]).reshape(2, -1) res = smo.predict(temp) # print(res) zz[i, j] = res # print(zz[i, j]) zz[(zz &lt; 0)] = -1 zz[(zz &gt;= 0)] = 1 plt.subplot(1,2,2) plt.contourf(xx, yy, zz) # # print(x[0,:].shape, x[1,:].shape, y.shape) plt.scatter(smo.x[0,:].reshape(1, -1), smo.x[1,:].reshape(1, -1), c = 0 - smo.y.T) plt.show() å¯¼å…¥æ•°æ® æ­¤å¤„ç”ŸæˆåŒå¿ƒåœ†æ•°æ®ï¼Œä»¥åŒºåˆ«çº¿æ€§æ ¸å’Œéçº¿æ€§æ ¸ä¹‹é—´çš„åŒºåˆ« x_train, y_train, x_test, y_test = load() # plt.scatter(x_train[0, :], x_train[1, :], c = y_train[:, 0]) (2, 100) (2, 100) ä½¿ç”¨é«˜æ–¯æ ¸çš„SVM æ­¤å¤„Ïƒ=0.5\\sigma = 0.5Ïƒ=0.5,å–å€¼ä¸º1æ—¶ï¼Œå‡†ç¡®ç‡å°±å¾ˆä½äº†ï¼Œä¸çŸ¥é“æ€ä¹ˆå›äº‹ï¼ˆå…ˆè¡¥ä¸€ä¸‹æ ¸å‡½æ•°æ›´å¤šçš„æŠ€æœ¯äº†ï¼Œ ç‹—å¤´.jpgï¼‰ smo = SMO(x_train, y_train, C = 2, kernel = &quot;gauss&quot;) smo.init() smo.SMO(110) y_pred = smo.predictAll(x_test) evaluate(y_test, y_pred) draw_svm(smo) this is 0th loop. this is 10th loop. this is 20th loop. this is 30th loop. this is 40th loop. this is 50th loop. this is 60th loop. this is 70th loop. this is 80th loop. this is 90th loop. this is 100th loop. 1.0542578147143928 The roc_auc_score is 0.982048143614851 The accuracy is 0.89 precision recall f1-score support class0 0.80 1.00 0.89 43 class1 1.00 0.81 0.89 57 accuracy 0.89 100 macro avg 0.90 0.90 0.89 100 weighted avg 0.91 0.89 0.89 100 ä½¿ç”¨çº¿æ€§æ ¸çš„SVM smo = SMO(x_train, y_train, C = 2, kernel = &quot;linear&quot;) smo.init() smo.SMO(110) y_pred = smo.predictAll(x_test) evaluate(y_test, y_pred) draw_svm(smo) this is 0th loop. this is 10th loop. this is 20th loop. this is 30th loop. this is 40th loop. this is 50th loop. this is 60th loop. this is 70th loop. this is 80th loop. this is 90th loop. this is 100th loop. 0.27041462716608683 The roc_auc_score is 0.4618523051815585 The accuracy is 0.48 precision recall f1-score support class0 0.41 0.49 0.45 43 class1 0.55 0.47 0.51 57 accuracy 0.48 100 macro avg 0.48 0.48 0.48 100 weighted avg 0.49 0.48 0.48 100 è°ƒç”¨ä¹‹å‰å†™è¿‡çš„å†³ç­–æ ‘C4.5 from dt import buildTree, Node, predictAll, predict, draw_tree import pandas as pd X_train = np.r_[x_train, y_train.T] X_train = pd.DataFrame(X_train.T, columns=[&quot;x&quot;,'y',&quot;label&quot;]) X_test = np.r_[x_test, y_test.T] X_test = pd.DataFrame(X_test.T, columns=[&quot;x&quot;,'y',&quot;label&quot;]) Y_test = np.array(list(X_test[&quot;label&quot;])).reshape(-1,1) root = Node(Dataset=X_train, attrList = ['x','y']) root = buildTree(root) Y_pred = predictAll(root ,X_test) evaluate(Y_test, Y_pred) draw_tree(root) plt.scatter(X_train[&quot;x&quot;], X_train[&quot;y&quot;], c = 0 - X_train[&quot;label&quot;]) The roc_auc_score is 0.7105263157894737 The accuracy is 0.67 precision recall f1-score support class0 0.57 1.00 0.72 43 class1 1.00 0.42 0.59 57 accuracy 0.67 100 macro avg 0.78 0.71 0.66 100 weighted avg 0.81 0.67 0.65 100 &lt;matplotlib.collections.PathCollection at 0x7f523e323310&gt; åˆ†æ å¯¹äºåŒå¿ƒåœ†è¿™ç§çº¿æ€§ä¸å¯åˆ†çš„æ•°æ®ï¼Œä½¿ç”¨linear kernelåªèƒ½å¾—åˆ°çº¦50/100çš„å‡†ç¡®åº¦ ä½¿ç”¨å†³ç­–æ ‘ï¼Œè¿™é‡Œç”±äºå†³ç­–å˜é‡åªæœ‰xï¼Œyæ‰€ä»¥ï¼Œè¿™é‡Œçš„å†³ç­–æ ‘è™½å¤šä¸¤å±‚ï¼Œå¯¹äºç‰¹å¾å‘é‡è¾ƒå°çš„æ•°æ®é›†ä¸å‹å¥½ ä½¿ç”¨æ‹‰æ™®æ‹‰æ–¯æ ¸ï¼ˆæµ‹è¯•æ—¶ç”¨çš„æ‹‰æ™®æ‹‰æ–¯æ ¸ï¼Œå‡†ç¡®ç‡ç•¥é«˜äºé«˜æ–¯æ ¸ï¼‰ æˆ–è€… é«˜æ–¯æ ¸åœ¨è¯¥ç§çº¿æ€§ä¸å¯åˆ†çš„æ•°æ®é›†ä¸­èµ·åˆ°äº†å¾ˆå¥½çš„å‡ç»´ä½œç”¨ ä½¿ç”¨ç¥ç»ç½‘ç»œå¯ä»¥å¾—åˆ°å¾ˆå¥½çš„æ•ˆæœï¼ˆåœ¨ç¥ç»ç½‘ç»œå®ç°çš„æ—¶å€™ï¼Œæµ‹è¯•è¿‡è¯¥æ•°æ®é›†ï¼Œéšç€å±‚æ•°çš„å¢åŠ ï¼Œèƒ½è¾¾åˆ°99/100çš„å‡†ç¡®ç‡ï¼‰ import tensorflow==2.0.0 Cannot run import tensorflow because of system compatibility. AI Studio prepared an entire environment based on PaddlePaddle already. Please use PaddlePaddle to build your own model or application. ","link":"https://xuaii.github.io/post/svm/"},{"title":"ã€è½¬è½½ã€‘VRæ‰¯æ‰äº†ä¸­å›½ç§‘æŠ€åœˆçš„é®ç¾å¸ƒ","content":"è½¬è‡ªçŸ¥ä¹ Oculusåº”è¯¥å–ç»™è°ï¼Ÿå¥½å¤§çš„ä¸€ä¸ªé—®é¢˜å•Šã€‚ å–ç»™è°éƒ½å¯ä»¥ï¼Œä½†å°±æ˜¯ä¸è¯¥å–ç»™Facebookï¼ å–ç»™Appleå¤šåˆé€‚ï¼Œé‚£é‡Œæœ‰å…¨ä¸–ç•Œæœ€å¥½çš„æ¶ˆè´¹ç”µå­äº§å“ã€‚å–ç»™Googleä¹Ÿä¸é”™ï¼Œå®‰å“ç³»ç»Ÿé€æ¸ç»Ÿæ²»ä¸–ç•Œï¼ŒGoogleçœ¼é•œåˆšè¢«ã€Šæ—¶ä»£ã€‹æ‚å¿—è¯„ä¸ºé‚£ä¸€å¹´æœ€ä»¤äººæœŸå¾…çš„ç¡¬ä»¶äº§å“ã€‚ è¿˜å¯ä»¥é€‰å¾®è½¯ï¼ŒVRï¼ˆVirtual Realityï¼Œè™šæ‹Ÿç°å®ï¼‰æœ€ç›´è§‚çš„ä½¿ç”¨åœºæ™¯å°±æ˜¯æ¸¸æˆï¼Œè¿™å’Œå¾®è½¯Xboxæ¸¸æˆæœºä¸€è„‰ç›¸æ‰¿ã€‚å°±è¿äºšé©¬é€Šï¼Œå¥½æ­¹ä¹Ÿåšå‡ºäº†Kindleï¼Œåœ¨äººç±»å‡ºç‰ˆç•Œæ”¾äº†ä¸€åœºå¤§ç«ã€‚ å†çœ‹çœ‹Facebookå‘¢ï¼Ÿä¸€ç‚¹åšç¡¬ä»¶çš„ç»éªŒéƒ½æ²¡æœ‰ã€‚æ‰å…‹ä¼¯æ ¼(Mark Zuckerberg)æ›¾ç»æ”¾å‡ºç‹ è¯è¦åšæ‰‹æœºï¼ŒæŠ˜è…¾äº†åŠå¤©ï¼Œåªæ˜¯ç«¹ç¯®æ‰“æ°´ä¸€åœºç©ºã€‚ ä¸ä»…å¦‚æ­¤ï¼ŒOculusè¿˜éå¸¸ä¸facebookã€‚CTOå‹æ ¹æ²¡æœ‰Facebookè´¦æˆ·ï¼ŒCEOçš„åŠå…¬å®¤é‡Œèµ«ç„¶æŒ‚ç€ä¸€å‰¯å¯¹Facebookä¸æ•¬çš„å·¥è‰ºå“ï¼Œå‘˜å·¥æŠŠå˜²ç¬‘Facebookå½“ä½œå·¥ä½œçš„æ—¥å¸¸ï¼ŒFBæ˜¯ä¸€ä¸ªå…¸å‹çš„åé¢æ•™æï¼šåƒµåŒ–çš„å…¬å¸ã€ç³Ÿç³•çš„è®¾è®¡ã€éšç§çš„å°å·ã€‚ å½“æ‰å…‹ä¼¯æ ¼åƒé‡Œè¿¢è¿¢æ¥æ‹œè®¿Oculuså…¨ä½“å‘˜å·¥ï¼Œä¸€ä½å«Dycusçš„å‘˜å·¥ï¼Œå½“ç€å…¨å…¬å¸çš„é¢é—®å°æ‰ï¼šå¾ˆå¤šäººï¼ˆå½“ç„¶ï¼Œä¸åŒ…æ‹¬æˆ‘å“ˆï¼‰ï¼Œéƒ½è§‰å¾—Facebookæ˜¯é‚ªæ¶çš„ï¼ˆFacebook is evilï¼‰ï¼Œä½ è§‰å¾—ï¼Œè¿™ä¼šæ€ä¹ˆå½±å“Oculusçš„å½¢è±¡ï¼Ÿ å›¾ï¼šæˆ´ç€Oculusçš„æ‰å…‹ä¼¯æ ¼ ä½†æ˜¯æ‰å…‹ä¼¯æ ¼å´åƒè¢«æ–½äº†æ³•æœ¯ï¼Œå¯¹Oculusç€äº†é­”ã€‚ æ‰å…‹ä¼¯æ ¼å¸¦ç€Facebookä¸€ä¼—é«˜ç®¡è½®æµæˆ´äº†ä¸€ä¼šOculusçš„VRå¤´ç›”ã€‚ å½“æ—¶è¿˜åªæ˜¯æ ·å“ï¼Œè·ç¦»æˆå“ä¸Šå¸‚ï¼Œè¿˜æœ‰å¾ˆè¿œçš„è·ç¦»ã€‚å³ä½¿åˆ°äº†ä»Šå¤©ï¼ŒVRå¤´ç›”éƒ½æ²¡æœ‰å…‹æœæœ€å¤§çš„bugâ€”â€”æ™•çœ©ã€‚æ›´åˆ«è¯´7å¹´å‰äº†ã€‚å°æ‰å¸ä¸‹å¤´ç›”çš„åˆ¹é‚£ï¼Œä¼°è®¡å’Œå­¦ç”Ÿæ—¶ä»£åœ¨å“ˆä½›å¤§å­¦é€šå®µå®¿é†‰åä¸€æ ·çš„éš¾å—ï¼Œä½†æ˜¯ï¼Œå°æ‰è¿åŒCTOå’Œè´Ÿè´£äº§å“çš„VPï¼Œå¯¹è¿™ä¸ªæ–°å¥‡çš„ç©æ„èµä¸ç»å£ï¼Œåå¤è¯´ç€ï¼šholy crapï¼ˆä¸“ä¸šç¿»è¯‘ï¼šæˆ‘X, NBå•Šï¼‰ã€‚ 5å¤©åï¼Œè¿™ä½å…¨çƒæœ€å¤§ç¤¾äº¤ç½‘ç»œçš„ç®¡ç†è€…äº²è‡ªå»äº†è¿™å®¶åˆ›ä¸šå…¬å¸çš„åŠå…¬å®¤ã€‚ è¿™ä¸€å¤©ï¼Œè¿™ä½å…¨ä¸–ç•Œæœ€å¯Œæœ‰çš„80åèƒŒäº†ä¸€ä¸ªéº¦å½“åŠ³çš„è´­ç‰©è¢‹ã€‚è¿™çœŸæ˜¯ç¥æ¥ä¹‹ç¬”ã€‚æœ¬æ¥å¯¹Facebookæ²¡æœ‰ä¸€ç‚¹å¥½æ„Ÿçš„å¹´è½»æå®¢ä»¬ï¼Œç¬é—´è®®è®ºçº·çº·ï¼šçœŸæ˜¯æ²¡æƒ³åˆ°ï¼Œäº’è”ç½‘è¶…çº§å¤§ä½¬ï¼ŒåŸæ¥æ˜¯å’Œæˆ‘ä¸€æ ·çš„äººã€‚ åœ¨ç‹ ç‹ æ‹‰äº†ä¸€æ³¢å¥½æ„Ÿå€¼åï¼Œæ‰å…‹ä¼¯æ ¼ä¸ºè¿™å®¶åˆ›åŠä»…ä»…2å¹´çš„å…¬å¸å¼€å‡ºäº†æ— æ³•æ‹’ç»çš„ä»·ç â€”â€”30äº¿ç¾å…ƒã€‚ä»¥åŠåå¤çš„åŠè¯±å’Œè®¸è¯ºï¼šOculusä¼šæˆä¸ºFacebookå”¯ä¸€çš„å¹³å°ï¼Œæˆ‘è¦è®©Oculusæˆä¸ºVRçš„é¢†å¯¼è€…ï¼ æ€ä¹ˆæ‹‰è¿‘èµ„æœ¬å’Œåˆ›ä¸šè€…çš„è·ç¦»ï¼Œå°æ‰å¯èƒ½æ˜¯å…¨ä¸–ç•Œæœ€æ‡‚è¿™ä»¶äº‹çš„äººã€‚å½“å¹´Facebookåˆšåˆšæˆç«‹ï¼Œå°æ‰è¦å»çº¢æ‰èµ„æœ¬çš„åŠå…¬å®¤è°ˆèèµ„ã€‚åœ¨è‚–æ©Â·å¸•å…‹ï¼ˆSean Parkerï¼‰çš„æ•™å”†ä¸‹ï¼Œä»–ç©¿ç€ç¡è¡£èµ°è¿›äº†é«˜å¤§ä¸Šçš„åŠå…¬å®¤ã€‚ è¥¿è£…é©å±¥çš„ä¸­å¹´æ²¹è…»ç”·è¢«æŒ‘é€—å¾—æ¬²ç«ç„šèº«ï¼Œè¿™æ‰æ˜¯TMDçœŸæå®¢ï¼æŠ•ä»–ï¼Œå¿…é¡»æŠ•ä»–ï¼ é‚£åªéº¦å½“åŠ³çš„æ‰‹æè¢‹ï¼Œå¾ˆéš¾è¯´ä¸æ˜¯ä¸€åœºç²¾å¿ƒè®¾è®¡çš„è½®å›ã€‚è¿™ä½å“ˆä½›è¾å­¦ç”Ÿï¼Œæœ‰ä¸€ä¸ªæœ¨è®·çš„å¤–è¡¨ï¼Œä»¥è‡³äºå¸¸å¸¸è®©æˆ‘ä»¬å¿½ç•¥äº†ä»–æå…¶ç²¾æ˜å’Œå¤æ‚çš„å†…å¿ƒä¸–ç•Œã€‚ ä½†æ˜¯ã€‚ æVRï¼Ÿï¼ä½ è¿˜æ˜¯æƒ³æƒ³æ¸…æ¥šå§ï¼Œè¿™ä¸ªä¸“é—¨ç»æ€ç§‘æŠ€å·¨å¤´çš„æˆ˜åœºï¼Œæ—©å·²ç™½éª¨ç´¯ç´¯ã€‚ 01 ä»å¼—å…°å…‹é²å§†çš„ã€Šä¸‡èƒ½é’¥åŒ™ã€‹åˆ°èµ«èƒ¥é»çš„ã€Šç¾ä¸½æ–°ä¸–ç•Œã€‹ï¼Œä»ä¼è¿ªè‰¾ä¼¦çš„ã€Šæ²‰ç¡è€…ã€‹ï¼ˆ1973å¹´ï¼‰ï¼Œåˆ°æ–¯çš®å°”ä¼¯æ ¼çš„ã€Šå¤´å·ç©å®¶ã€‹ï¼ˆ2018å¹´ï¼‰ï¼ŒVRï¼ˆè™šæ‹Ÿç°å®ï¼‰æ˜¯æ‰€æœ‰ç§‘å¹»å°è¯´ã€ç§‘å¹»ç”µå½±çš„å¿…å¤‡å…ƒç´ ã€‚ å¸¦ä¸Šä¸€å¥—è£…å¤‡ï¼Œé€šè¿‡è§†è§‰ã€å—…è§‰ã€è§¦è§‰ï¼Œè®©äººèµ°è¿›ä¸€ä¸ªå®Œå…¨è™šæ‹Ÿçš„ä¸–ç•Œã€‚è¿˜æœ‰æ¯”è¿™æ›´coolçš„ç§‘æŠ€äº§å“å—ï¼Ÿ æ–¯çš®å°”ä¼¯æ ¼çš„ç”µå½±ã€Šå¤´å·ç©å®¶ã€‹ä¸»é¢˜å°±æ˜¯ä¸€ä¸ªVRæ¸¸æˆ å†™å‡ºã€Šæ•°å­—åŒ–ç”Ÿå­˜ã€‹çš„MITï¼ˆéº»çœç†å·¥ï¼‰æ•™æˆå°¼è‘›æ´›åºå¸è¯´ï¼Œä»–ä»1969å¹´å°±å¼€å§‹å…³æ³¨VRã€‚ æ²¡é”™ï¼Œåœ¨è¿å½©è‰²ç”µè§†æœºéƒ½æ²¡æœ‰æ™®åŠçš„60å¹´ä»£ï¼ŒçœŸæå®¢ä»¬å°±å·²ç»åœ¨å°è¯•åšVRå¤´ç›”ã€‚90å¹´ä»£ï¼Œä»»å¤©å ‚ã€ä¸–å˜‰ï¼Œä»¥åŠä¹”å¸ƒæ–¯å®ä¹ è¿‡çš„é›…è¾¾åˆ©ï¼Œå…ˆåå¯¹ç€VRè®¾å¤‡ï¼Œå¤§æç‰¹æã€‚ ä¸–å˜‰ï¼ˆSEGAï¼‰æå¾—æœ€è½°åŠ¨ã€‚äº§å“å®£ä¼ äº†ä¸‰å¹´ï¼Œå‘å¸ƒä¼šå¼€äº†åˆå¼€ï¼Œã€Šå¤§ä¼—ç§‘æŠ€ã€‹çš„æ‚å¿—å°é¢ä¹Ÿå¦‚æ„¿ç™»è¿‡äº†ã€‚ç»“æœï¼Œä¸´é—¨ä¸€è„šï¼Œçªç„¶å®£å¸ƒä¸å‘å¸ƒäº†ï¼Œæ”¾äº†å…¨ä¸–ç•Œä¸€ä¸ªå¤§é¸½å­ã€‚ä¸–å˜‰çš„ç†ç”±æ˜¯ï¼šVRæ¸¸æˆå¤ªè¿‡çœŸå®ï¼Œç©å®¶åœ¨æ¸¸æˆè¿‡ç¨‹ä¸­ä¸ç”±è‡ªä¸»åœ°ç§»åŠ¨ï¼Œå®¹æ˜“å—ä¼¤ã€‚ æ‹‰å€’å§ã€‚ å—ä¼¤æ˜¯çœŸçš„ï¼Œä½†ä¸æ˜¯å› ä¸ºç§»åŠ¨ï¼Œè€Œæ˜¯å› ä¸ºæ™•çœ©å¯¼è‡´çš„æ¶å¿ƒå¤´ç–¼ã€‚VRè¥é€ äº†ä¸€ä¸ªæ·±åº¦æ²‰æµ¸çš„ä¸–ç•Œï¼Œå¦‚æœæŠ€æœ¯è·Ÿä¸ä¸Šï¼Œè™šæ‹Ÿç”»é¢å’Œç°å®åŠ¨ä½œæœ‰å»¶æ—¶ï¼Œä¼šé€ æˆä¸¥é‡çš„æ™•çœ©ï¼Œç±»ä¼¼ç°å®ä¸­çš„æ™•è½¦ã€‚ ä»æ­¤ï¼Œæ™•çœ©æ„Ÿæˆä¸ºæ¨ªäº˜åœ¨VRäº§ä¸šé¢å‰çš„ä¸€é“å¤©å ‘ï¼Œæˆ–è€…è¯´ä¸€é“é­”å’’ã€‚äººç±»ç§‘æŠ€ç•Œå¯¹VRçš„ç¬¬ä¸€æ¬¡æ”»å…³ï¼Œä»¥è¢«å›¢ç­çš„æ–¹å¼å‘Šç»ˆã€‚ ç´§æ¥ç€ï¼Œäº’è”ç½‘æ¥äº†ã€‚äºšé©¬é€Šã€Googleå…ˆåé—®ä¸–ï¼Œé‚£äº›åˆ©ç”¨äº’è”ç½‘è¿æ¥å­˜é‡èµ„æºï¼Œé‚£äº›æ¶ˆè´¹ä¸»ä¹‰çš„è¿åˆè€…ï¼Œæˆäº†ç¡…è°·çš„æ–°å® ã€‚ æ—¶ä»£æ¢äº†ä¸€æ‰¹æ–°çš„å®¾å®¢ï¼Œä½†æ˜¯æå®¢çš„ç«è‹—æ²¡æœ‰å®Œå…¨ç†„ç­ã€‚æŠŠç§‘å¹»å°è¯´é‡Œæœ€coolçš„è£…å¤‡å˜æˆç°å®ï¼Œä¹Ÿæ˜¯ç§‘æŠ€æ–°è´µçš„æ¢¦ã€‚ Googleå…ˆåšAR(Augmented realityï¼Œå¢å¼ºç°å®)ï¼Œè°·æ­Œçœ¼é•œï¼ˆGoogle Glassï¼‰æ‰å‡ºäº†å‡ å¼ å®£ä¼ ç…§ï¼Œå…¨ä¸–ç•Œç§‘æŠ€è¿·å°±è‡ªå—¨åˆ°äº†é«˜æ½®ï¼Œä¸ä»…æœ‰è‹±å›½ç‹å­è¿™æ ·çš„ç¤¾ä¼šåæµé‡ç”Ÿä»£è¨€ï¼Œè€Œä¸”é¢‘é¢‘è¢«å„ç±»åª’ä½“è¯„ä»·ä¸ºäººç±»æœ€å…·åˆ›æ–°ã€æœ€å€¼å¾—æœŸå¾…çš„äº§å“ã€‚Googleåˆæ„ŸåŠ¨åˆå…´å¥‹ï¼Œå†æ¥å†å‰åšäº†ä¸€ä¸ªVRçš„å¹³å°Daydreamï¼Œæ»¡è…”çƒ­è¡€æœŸå¾…å¤åˆ¶ä¸€ä¸ªå®‰å“çš„ç¥è¯ã€‚ ä¸‰æ˜Ÿï¼Œä½œä¸ºå½“æ—¶å…¨çƒå‡ºè´§é‡ç¬¬ä¸€çš„æ‰‹æœºå“ç‰Œï¼Œä¹Ÿç‹ ç‹ è¡¨ç¤ºäº†ä¸€æŠŠï¼Œå¼„å‡ºä¸ªGear VRã€‚ä½†æ˜¯ï¼ŒGoogleçœ¼é•œã€Daydreamï¼ŒGearVRï¼Œå…¨éƒ¨ç«ä¸è¿‡ä¸¤å¹´ï¼Œæœ€ç»ˆé”€å£°åŒ¿è¿¹ã€‚ ç›®å‰ä¸ºæ­¢ï¼Œäººç±»æœ€é‡è¦çš„ç¡¬ä»¶è¿˜æ˜¯æ™ºèƒ½æ‰‹æœºã€‚Googleå’Œä¸‰æ˜Ÿæ˜¯è¿™ä¸ªè¡Œä¸šç»å¯¹çš„é¢†å¯¼è€…ï¼Œåœ¨äº§ä¸šé“¾é‡Œæ˜¯ä¸€å‘¼ç™¾åº”ã€‚é‚£ä¹ˆå¼ºçš„èƒ½åŠ›ï¼Œé‚£ä¹ˆåšçš„èƒŒæ™¯ï¼Œåœ¨VRè¡Œä¸šä¹Ÿä¸è¿‡æ˜¯ç¢°ä¸€é¼»å­ç°ï¼Œç¾ç¾åœ°æ‰¾ä¸ªå°é˜¶ä¸‹ã€‚ è¿™å°±æ˜¯Facebookæ”¶è´­Oculusçš„èƒŒæ™¯ã€‚åœ¨ç¡…è°·ï¼ŒFacebookçš„æ ‡ç­¾æ˜¯ä¾µçŠ¯éšç§ã€æŠ„è¢­æ¨¡ä»¿ã€åŠŸåˆ©ä¸»ä¹‰ï¼Œè¿™æ ·çš„æ‰å…‹ä¼¯æ ¼å¯èƒ½åšå‡ºäººç±»æœ€æ–°å¥‡çš„ç¡¬ä»¶å—ï¼Ÿ 02 2016å¹´ï¼Œå°æ‰æ­£åœ¨ä¸ºFacebookè¿›å…¥ä¸­å›½åŠªåŠ›ã€‚é¡¶ç€å¤§é›¾éœ¾ï¼Œæ¯…ç„¶å†³ç„¶åœ°åœ¨å¤©å®‰é—¨å‰è·‘æ­¥ï¼Œæ˜¯ä¸ªåˆçº¢åˆä¸“çš„å¥½å°‘å¹´ã€‚ é‚£æ¬¡æ‰å…‹ä¼¯æ ¼æ¥åŒ—äº¬ï¼Œç›®çš„æ˜¯å‚åŠ ç”±å›½åŠ¡é™¢å‘å±•ç ”ç©¶ä¸­å¿ƒä¸»åŠçš„ä¸­å›½å‘å±•é«˜å±‚è®ºå›ã€‚ 93å²çš„åŸºè¾›æ ¼è€çˆ·å­åšäº†ã€Šé¿å…ä¿®æ˜”åº•å¾·é™·é˜±ã€‹çš„æ¼”è®²ï¼Œæ¥ä¸‹æ¥å°±æ˜¯æ‰å…‹ä¼¯æ ¼å’Œé©¬äº‘çš„è°ˆè¯ã€‚æ‰å…‹ä¼¯å…‹è¡¨ç¤ºï¼Œå‰ä¸¤å¹´æˆ‘æ”¶è´­äº†Oculusï¼Œä»Šå¹´ä¼šæ¨å‡ºä¸€æ¬¾VRå¤´ç›”ï¼Œä»Šå¹´æ¶ˆè´¹çº§VRå°±ä¼šçˆ†å‘ï¼Œäº”åˆ°åå¹´ä¹‹åï¼ŒVRæ‰‹æœºä¼šæˆä¸ºå¸‚åœºä¸»æµã€‚ é©¬äº‘è¯´ï¼Œè¡Œå•Šï¼Œæˆ‘ä¼šå¸®ä½ ã€‚ å…¶å®ï¼Œä¸åªæ˜¯å§“èµµã€‚å§“é©¬ï¼Œä¹Ÿæ˜¯æœ‰é„™è§†é“¾çš„ã€‚ å°±æ‹¿é©¬å…‹Â·æ‰å…‹ä¼¯æ ¼ã€é©¬äº‘ã€é©¬æ–¯å…‹æ¥è¯´ã€‚ å°æ‰åƒä¸ªä¸­å›½äººï¼Œåœºé¢ä¸Šè¯´è¯ä¸€å®šåœ†æ»‘ï¼Œä¸è½»æ˜“å¾—ç½ªäººã€‚å’Œé©¬äº‘èŠå¤©å®¢å®¢æ°”æ°”çš„ï¼Œä¸Šæ¥å…ˆä»‹ç»è‡ªå·±æ­£åœ¨å­¦ä¹ ä¸­æ–‡ï¼Œä½†æ˜¯è¿˜å¾ˆç³Ÿï¼Œæ‰€ä»¥è¾›è‹¦é©¬äº‘ä»Šå¤©ç”¨è‹±è¯­äº¤æµï¼Œè°¢è°¢å¤§å®¶çš„ç†è§£ã€‚ ä½ å†çœ‹çœ‹é©¬æ–¯å…‹ï¼Ÿé‚£å‰¯å¾—ç‘ŸåŠ²ã€‚åŒæ ·æ˜¯æ¥ä¸­å›½å‚åŠ å¯¹è¯ï¼Œé©¬æ–¯å…‹ä¸€ç‚¹ä¸ç»™é©¬è€å¸ˆé¢å­ï¼ŒæŠŠé©¬æ°é¸¡æ±¤é‡Œçš„é€»è¾‘çŸ›ç›¾ã€äº‹å®é”™è¯¯å…¨æŒ‡äº†å‡ºæ¥ã€‚å–œæ¬¢é˜¿é‡Œçš„äººåƒä¸‡åˆ«æ”¾å¿ƒä¸Šï¼Œå…¶å®ç©ç¡¬æ ¸ç§‘æŠ€çš„é©¬æ–¯å…‹æœ€çœ‹ä¸èµ·çš„äººï¼Œæ˜¯é©¬å…‹Â·æ‰å…‹ä¼¯æ ¼ã€‚é©¬æ–¯å…‹ä¸å¸¦ä¿®é¥°åœ°è¯´è¿‡ï¼šFacebookåƒåœ¾ï¼ˆFacebook sucksï¼‰ï¼Œçªƒå–éšç§ã€åªä¼šå„æ–­ï¼Œæ‰å…‹ä¼¯æ ¼å°æœ‹å‹å¯¹äºAIä¸€æ— æ‰€çŸ¥â€¦â€¦ç„¶åï¼Œä»¥èº«ä½œåˆ™åœ°æŠŠè‡ªå·±çš„Facebookè´¦æˆ·æ³¨é”€äº†ã€‚ å°æ‰å¿ƒé‡Œæ˜¯çœŸè‹¦å•Šã€‚Facebookæ˜¯å…¨ä¸–ç•Œå¸‚å€¼å‰äº”çš„äº’è”ç½‘å…¬å¸ï¼Œè¯´èµ·æ¥æœ‰å¤´æœ‰è„¸ï¼Œä½†æ˜¯æ”¶å…¥çš„95%éƒ½æ˜¯å¹¿å‘Šã€‚æ‰å…‹ä¼¯æ ¼æ°”ä¸è¿‡çš„æ—¶å€™ä¹Ÿæƒ³å›æ€¼ä¸¤å¥ï¼Œä½†æ˜¯å°„ç«ç®­ã€å–ç”µåŠ¨çš„é©¬æ–¯å…‹ææ€•è¦æ€¼ä¸€å¥æ›´å‰å®³çš„å›æ¥ï¼Œâ€œä½ ä¸ªå–å¹¿å‘Šçš„ï¼Œè£…ä»€ä¹ˆBâ€ï¼Œé‚£å¹´è½»çš„å°æ‰åˆè¦æ°”å¾—å‡ å¤©ç¡ä¸ç€è§‰äº†ã€‚ é©¬å®¶äººçš„é„™è§†é“¾è¯´åˆ°åº•å°±æ˜¯ä¸€å¥è¯ï¼šäº’è”ç½‘ä¼ä¸šå‹æ ¹ä¸æ˜¯ç§‘æŠ€å…¬å¸ã€‚ æ¸…é†’ç‚¹ï¼Œå¥½ä¸å¥½ï¼Œä½ ä¸è¿‡æ˜¯åšäº†ä¸€ä¸ªç½‘é¡µï¼Œå› ä¸ºä¸Šçº¿å¾—è¶³å¤Ÿæ—©ï¼Œæ—©æ—©å äº†ä¸ªå¥½å‘ï¼Œå¾ˆå¤šäººç”¨ã€‚å½¢æˆäº†å¹³å°ï¼Œå½¢æˆäº†å„æ–­ï¼Œç‹¬å äº†æ•°æ®ï¼Œä»…æ­¤è€Œå·²ã€‚å·´è¥¿ç”·è¶³è¸¢ä¸­å›½ç”·è¶³ï¼Œå³ä½¿æ•™ç»ƒå¸­æ “ä¸€æ¡ç‹—ï¼Œä¹Ÿèƒ½èµ¢ã€‚æ˜¯çš„ï¼Œä»…æ­¤è€Œå·²ã€‚è¿™æ€ä¹ˆèƒ½é…å«é«˜ç§‘æŠ€ï¼Ÿ åœ¨é©¬æ–¯å…‹çœ¼ä¸­ï¼Œæ‰å…‹ä¼¯æ ¼å°±æ˜¯è¿™ç§ä¸é…çš„å…¸å‹ã€‚ è¿™å°±æ˜¯æ‰å…‹ä¼¯æ ¼åšæŒåšVRçš„ç¬¬äºŒä¸ªèƒŒæ™¯ã€‚ ä½•æ­¢æ˜¯Googleã€ä¸‰æ˜Ÿï¼Œä¸­å›½ä¹Ÿå¤šçš„æ˜¯åˆ©ç”¨VRå¹ç‰›é€¼çš„å¤§å…¬å¸ã€‚å°±åœ¨æ‰å…‹ä¼¯æ ¼å’Œé©¬äº‘äº²åˆ‡äº¤è°ˆçš„é‚£ä¸€å¹´ï¼Œé˜¿é‡Œæ¨å‡ºVRè´­ç‰© â€œBuyï¼‹â€ï¼Œç›®æ ‡æ˜¯åˆ©ç”¨VRè®©ç½‘è´­å˜æˆé€›å•†åœºçš„æ¨¡æ ·ã€‚å¦ä¸€ä¸ªå¤§æ‰‹ç¬”æ˜¯é¢†æŠ•äº†ç¾å›½å¾ˆç«çš„ARåˆ›ä¸šå…¬å¸Magic Leapï¼Œ7.94äº¿ç¾å…ƒçš„èèµ„ã€‚ åŒä¸€å¹´ï¼Œé©¬åŒ–è…¾ä¹Ÿç»™VRç«™è¿‡å°ï¼Œâ€œVRæ˜¯ä¸€åœºå¤§æ´—ç‰Œï¼Œå³å°†å¼€å§‹ã€‚å°±åƒç§»åŠ¨äº’è”ç½‘è½¬å‹ä¸€æ ·ï¼Œä¸Šä¸äº†èˆ¹çš„äººå°†é€æ¸è½ä¼â€ã€‚å½“å¹´ç”±å¾®ä¿¡å¼•å‘çš„â€œèˆ¹ç¥¨è®ºâ€å†æ¬¡ç”šåš£å°˜ä¸Šã€‚æ®è¯´è…¾è®¯å¯åŠ¨äº†å¤šæ¬¾VRæ¸¸æˆçš„åˆ¶ä½œã€‚è¿˜æ‰¬è¨€ä¹ŸåƒFacebookä¸€æ ·åšVRç¡¬ä»¶ï¼Œè¿åŸå‹æœºéƒ½æå‡ºæ¥äº†ã€‚ç„¶åï¼Œå°±æ²¡æœ‰ç„¶åäº†ã€‚ VRè¿™ä»¶äº‹ï¼Œç§‘æŠ€æ„Ÿçˆ†æ£šï¼Œä½†æ˜¯æ¯æ¬¡ä¸€ç‡ƒï¼Œå°±ä¼šè¢«æ³¼ä¸‹ä¸€ç›†åˆä¸€ç›†çš„å†·æ°´ã€‚å½’æ ¹ç»“åº•ï¼Œæœ‰è¿™æ ·å‡ ä¸ªè¿‡ä¸å»çš„åâ€”â€”æ™•åŠ¨ç—‡ã€åŠŸèƒ½å•ä¸€ã€ç¼ºä¹ä¼˜è´¨å†…å®¹ã€è®¾å¤‡è‡ƒè‚¿ã€ä»·æ ¼æ˜‚è´µâ€¦â€¦ æ²¡è¿‡å¤šä¹…ï¼ŒGoogleã€ä¸‰æ˜Ÿã€é˜¿é‡Œã€è…¾è®¯éƒ½æ’¤äº†ï¼Œå®ƒä»¬éƒ½ä¸è¿‡æ˜¯åŒ†åŒ†çš„è¿‡å®¢ï¼Œéƒ½æ²¡æœ‰æˆä¸ºæ¨åŠ¨è¡Œä¸šå‰è¿›çš„åŠ›é‡ã€‚ æ„å¤–çš„æ˜¯æ‰å…‹ä¼¯æ ¼å´å›ºæ‰§åœ°åšæŒäº†ä¸€ä¸‹ã€‚ ä¸ºä»€ä¹ˆï¼Ÿ å¾€ä½äº†è¯´ï¼Œæ˜¯å®ˆæŠ¤Facebookçš„ç¤¾äº¤è¾¹ç•Œã€‚æ‰å…‹ä¼¯æ ¼è¿™ä¸ªäººï¼Œæ°¸è¿œåœ¨è­¦æƒ•Facebookå¯èƒ½çš„é¢ è¦†è€…ã€‚Facebookçš„å…¥èŒæ‰‹å†Œä¸­ï¼Œå†™ç€è¿™æ ·ä¸€å¥è¯ï¼šå¦‚æœæˆ‘ä»¬ä¸å»åˆ›é€ å‡ºèƒ½æ€æ­»Facebookçš„äº§å“ï¼Œæœ‰äººä¼šå»åšã€‚ é©¬åŒ–è…¾ä¹Ÿè¡¨ç¤ºè¿‡ï¼ŒVR/ARå¾ˆå¯èƒ½æ˜¯ä¸‹ä¸€ä»£ç¤¾äº¤ï¼Œé¢ è¦†å¾®ä¿¡çš„é‚£ä¸€ç§ã€‚ çš„ç¡®ï¼Œå¾®ä¿¡æ¯•ç«Ÿåªæ˜¯ä¸€ä¸ªå¹³é¢çš„èŠå¤©æ¡†ã€‚ç”¨è„šè¶¾å¤´å°±èƒ½æƒ³æ˜ç™½ï¼Œå¦‚æœVRåˆ›å»ºä¸€ä¸ªè™šæ‹Ÿspaceï¼Œæ¸£ç”·æ’©å¦¹çš„ç©ºé—´ä¼šå¤§å¾ˆå¤šå¾ˆå¤šã€‚ Facebookå¼€å‘çš„VRç¤¾äº¤å¹³å°Horizon å¾€é«˜äº†è¯´ï¼Œæ‰å…‹ä¼¯æ ¼å°±æ˜¯æ†‹äº†ä¸€å£æ°”ï¼Œå»TMDé©¬å®¶äººé„™è§†é“¾ã€‚æˆ‘è¦äº²è‡ªè¯æ˜Facebookçš„ç§‘æŠ€æ„Ÿâ€”â€”æˆ‘æ¥åšä¸€ä¸ªæ–°ç¡¬ä»¶ï¼Œæˆ‘æ¥æ‰©å±•äººç±»çš„è¾¹ç•Œï¼Œæˆ‘æ¥æ‰“ç¢è™šæ‹Ÿä¸–ç•Œå’Œç°å®ä¸–ç•Œçš„è¿™é¢å¢™ã€‚ ä½ ä»¬ç»™æˆ‘çœ‹æ¸…æ¥šäº†ã€‚ 03 æ‰å…‹ä¼¯æ ¼æœ‰ä¸ªæ¯ç‡¥ä¸”ä¹å‘³çš„çˆ±å¥½â€”â€”å¯»è®¿æœ‰ç¤¾äº¤ç«äº‰åŠ›çš„åˆ›ä¸šå…¬å¸ï¼Œå’Œåˆ›å§‹äººä¸€è§å¦‚æ•…ï¼Œå†å¼€ä¸€ä¸ªä½ æ— æ³•say noçš„æ¡ä»¶ï¼Œæ¥ç€å¸¦ä½ é£ä¸€æ®µï¼Œç„¶åé—¹æ°ï¼Œæœ€ç»ˆäº¤æ¶ã€‚ æ‰å…‹ä¼¯æ ¼å…ˆåæ”¶è´­Instagramå’ŒWhatsAppï¼Œå®ƒä»¬çš„åˆ›å§‹äººæ–¯ç‰¹ç½—å§†(Kevin Systrom)ã€å…‹é‡Œæ ¼(Mike Krieger)ã€åº“å§†(Jan Koum)éƒ½åœ¨2018å¹´æ»šè›‹ã€‚ Oculusè‡ªç„¶ä¸ä¼šä¾‹å¤–ï¼Œå‹’åŸº(Palmer Luckey)åªåœ¨Facebookå¾…äº†ä¸‰å¹´å°±ä¸æ„‰å¿«åœ°ç¦»å¼€ã€‚å‰©ä¸‹çš„ä¼Šé‡Œæ¯”ï¼ˆBrendan Iribeï¼‰ä¹Ÿåœ¨2018å¹´æ‰“åŒ…èµ°äººã€‚ VRè®¾å¤‡æœ‰ä¸€é¡¹è·¯çº¿ä¹‹äº‰â€”â€”åšä¸€ä¸ªè¿æ¥ç”µè„‘/æ‰‹æœºçš„ç¡¬ä»¶ï¼Œè¿˜æ˜¯åšä¸€ä¸ªç‹¬ç«‹çš„è®¾å¤‡ï¼Ÿ è¿æ¥ç”µè„‘/æ‰‹æœºçš„å¥½å¤„æ˜¾è€Œæ˜“è§ï¼Œç”µè„‘/æ‰‹æœºæ€§èƒ½å¼ºï¼ŒVRè®¾å¤‡ä¸éœ€è¦è®¡ç®—ï¼Œåªéœ€è¦è´Ÿè´£æ˜¾ç¤ºï¼Œå› æ­¤é‡é‡æ›´è½»ï¼ˆæ›´é€‚åˆæˆ´åœ¨å¤´ä¸Šï¼‰ï¼Œæˆæœ¬æ›´ä½ã€‚ä½†æ˜¯ç¼ºç‚¹ä¹Ÿå¾ˆæ˜æ˜¾ï¼Œæ°¸è¿œåªèƒ½å½“é™„åº¸ï¼Œæœ¬è´¨å°±æ˜¯ä¸€å°æ˜¾ç¤ºå™¨ï¼Œä¸€å°æˆ´åœ¨å¤´ä¸Šè£…Xçš„æ˜¾ç¤ºå™¨ã€‚ æ—©æœŸçš„Oculuså¾ˆæƒŠè‰³ï¼Œä½†æ˜¯é€‰æ‹©çš„æŠ€æœ¯è·¯çº¿æ˜¯åšä¸€ä¸ªè¿æ¥åˆ°ç”µè„‘çš„æ˜¾ç¤ºå™¨ï¼Œå› ä¸ºåˆ›å§‹äººçš„é¦–è¦çš„ç›®æ ‡æ˜¯æ‰“æ¸¸æˆè¦çˆ½ã€‚ è¿™ç¾¤æ­»è‚¥å®…æ€ä¹ˆå¯èƒ½ç†è§£é©¬å…‹Â·æ‰å…‹ä¼¯æ ¼çš„ç—›è‹¦å’Œé‡å¿ƒï¼Ÿ Facebookéº¾ä¸‹çš„Oculusä¸€å®šè¦åšç‹¬ç«‹çš„è®¾å¤‡ï¼æ€ä¹ˆå¯ä»¥ä¾é™„åœ¨ç”µè„‘å’Œæ‰‹æœºä¸Šï¼Ÿç”µè„‘ï¼Œæ˜¯å¾®è½¯Windowsçš„å¤©ä¸‹ï¼Œæ‰‹æœºç‹å›½å·²ç»è¢«è‹¹æœiOSå’ŒGoogleå®‰å“çš„ç“œåˆ†å®Œäº†ã€‚ä½ ä»¬è¿˜æƒ³æˆ‘æ‰å…‹ä¼¯æ ¼å‘èº¬å±ˆè†åˆ°ä»€ä¹ˆæ—¶å€™ï¼Ÿ è¿™äº›å¹´Facebook Reality Labsç©å‘½åœ°åœ¨å±æ˜¾æŠ€æœ¯ã€çœ¼çƒè¿½è¸ªã€æ‰‹æŒ‡è¿½è¸ªã€é¢éƒ¨å’Œèº«ä½“è¿½è¸ªæŠ€æœ¯ä¸Šçƒ§é’±ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªå‰æã€‚ ä¸€å®šè¦åšç‹¬ç«‹çš„è®¾å¤‡ï¼ æ‰å…‹ä¼¯æ ¼ä¸ºOculusè®¾è®¡çš„æˆ˜ç•¥æ˜¯ï¼Œç¡¬ä»¶+æ“ä½œç³»ç»Ÿ+å†…å®¹ç”Ÿæ€+åº”ç”¨å•†åº—åˆ†å‘+ç¤¾äº¤ã€‚æˆ‘è¯´å¾—å†ç®€å•ä¸€ç‚¹å“ˆï¼Œè‹¹æœå’ŒiPhoneåœ¨æ™ºèƒ½æ‰‹æœºè¡Œä¸šæ˜¯ä»€ä¹ˆåœ°ä½ï¼ŒOculusåœ¨VRè¿™ä¸ªäººç±»æ–°ç¡¬ä»¶ä¸Šï¼Œå°±è¦ä»€ä¹ˆåœ°ä½ã€‚ å¯¹ï¼Œè‹¹æœæœ‰å¤šNBï¼Œæˆ‘å°±è¦å¤šï¼ŒNï¼ŒBã€‚ 04 2016å¹´ï¼ŒARæ¸¸æˆç²¾çµå®å¯æ¢¦GO ï¼ˆPokemon Goï¼‰æƒŠè‰³é—®ä¸–ï¼Œè®©VR/ARäº§ä¸šå®å®åœ¨åœ¨åœ°ç«äº†å…­ä¸ªæœˆã€‚ ç´§æ¥ç€å…¨çƒVR/ARäº§ä¸šåˆè·Œå›æ— ä¼‘æ­¢çš„å¯’å†°æœŸï¼Œä¸€çœ¼æœ›å»çœ‹ä¸åˆ°å¤´çš„é‚£ç§ã€‚ æ³•å¾‹é¢å‰ä¸ä¸€å®šäººäººå¹³ç­‰ï¼Œä½†æ˜¯VRé¢å‰å´åšåˆ°äº†äººäººå¹³ç­‰ï¼Œä¸ç®¡ä½ æ˜¯Googleä¸‰æ˜Ÿé˜¿é‡Œè…¾è®¯è¿™æ ·çš„å·¨å¤´ï¼Œè¿˜æ˜¯çˆ±é€å¼ºçˆ±å˜´ç‚®çš„è…°éƒ¨äº’è”ç½‘ï¼Œåˆæˆ–è€…æ˜¯çµæ´»æ•¢é—¯çš„ç‹¬è§’å…½ï¼Œåæ­£ç»Ÿç»Ÿè®©ä½ ä»¬æ­»ã€‚ 2016å¹´ï¼Œä¹è§†è¯´ï¼ŒVRæ˜¯ä¹è§†ç”Ÿæ€é‡è¦çš„ç»„æˆéƒ¨åˆ†ï¼Œç„¶åä¹è§†å´©ç›˜ã€‚æš´é£è¯´ï¼Œæš´é£ä¼šæˆä¸ºä¸­å›½ä¹ƒè‡³ä¸–ç•ŒVRè¡Œä¸šçš„é¢†å¯¼è€…ï¼Œç„¶åæš´é£åŠ¿ä¸å¯æŒ¡åœ°æˆäº†â€œå°ä¹è§†â€ã€‚Magic Leapï¼ŒARè¡Œä¸šæœ€ç¥ç§˜çš„å…¬å¸ï¼Œæ‹¿äº†Googleå’Œé˜¿é‡Œå·´å·´çš„æŠ•èµ„ï¼Œè¿™ä¸ªå¤Ÿéªšäº†å§ï¼Ÿä½†æ˜¯è¿™äº›å¹´ï¼Œç®¡å®ƒå«â€œç¾å›½ä¹è§†â€çš„äººè¶Šæ¥è¶Šå¤šâ€¦â€¦ äººç±»å°±æ˜¯å¯ç¬‘ï¼ŒæŠ˜è…¾äº†é‚£ä¹ˆä¹…ï¼Œé‚£ä¹ˆå¤šäººé‚£ä¹ˆå¤šé’±é‚£ä¹ˆå¤šä¼šï¼Œæœ€ç»ˆè¿˜ä¸å¦‚ä¸€åªå«çš®å¡ä¸˜çš„é»„è‰²è€é¼ æœ‰èƒ½é‡â€”â€”ä¸€æ¬¾æ¸¸æˆä¸ºä¸€ä¸ªè¡Œä¸šå……ç”µå…­ä¸ªæœˆã€‚ è¸è¸å®å®åœ°è¯´ï¼ŒVRæœ€åŸºæœ¬çš„ä½¿ç”¨åœºæ™¯å°±æ˜¯ç©æ¸¸æˆï¼Œå› æ­¤ï¼Œå‡ºä¸€æ¬¾å£ç¢‘çˆ†è¡¨çš„VRæ¸¸æˆï¼Œæ¯”ä¸€ä¸‡åœºå£å—¨å‘å¸ƒä¼šéƒ½ç®¡ç”¨ã€‚ çœ‹çœ‹éš”å£çš„ä»»å¤©å ‚switchï¼Œè¿™å°ç ´æ¸¸æˆæœºä¹Ÿé»˜é»˜æ— é—»å¥½å¤šå¹´ï¼Œæœ€ç»ˆå‡­å€Ÿã€Šå¥èº«ç¯å¤§å†’é™©ã€‹å’Œã€ŠåŠ¨ç‰©æ£®æ—ã€‹ä¸¤ä¸ªçˆ†æ¬¾æ¸¸æˆï¼Œåœ¨2020å¹´é¡ºåˆ©å‡ºåœˆã€‚ VRäººå–œæ¬¢è¿™ä¸ªåŠ±å¿—æ•…äº‹ï¼Œå¿ƒé‡Œæœ‰ä¸ªä¿¡å¿µVRè¡Œä¸šä¸€å®šä¹Ÿèƒ½å®ˆå¾—äº‘å¼€è§æœˆæ˜ã€‚ 2020å¹´ï¼Œã€ŠåŠè¡°æœŸï¼šçˆ±è‰å…‹æ–¯ã€‹ï¼ˆHalf-Life: Alyxï¼‰æ¥äº†ã€‚æ¸¸æˆåª’ä½“IGNç»™äº†ç½•è§çš„æ»¡åˆ†è¯„ä»·ï¼Œè¯´â€œè¿™åƒæ˜¯ä¸€æ¬¾æ¥è‡ªæœªæ¥çš„æ¸¸æˆâ€ã€‚ è¿˜è®°å¾—å°æ—¶å€™æ•´ä¸ªç½‘å§éƒ½åœ¨ç©çš„CSå§ï¼Œã€ŠåŠè¡°æœŸï¼šçˆ±è‰å…‹æ–¯ã€‹å’ŒCSåŒå®—åŒæºï¼Œç”±é¡¶çº§æ¸¸æˆå…¬å¸Valveå¼€å‘ã€‚ä¸ä»…æœ‰äººç±»æ¸¸æˆç•Œçš„é¡¶çº§IPåé•‡ï¼Œè€Œä¸”æ¸¸æˆæ“ä½œç”¨åˆ°äº†â€œçœŸçš„VRâ€ã€‚ åœ¨PCå’Œæ™ºèƒ½æ‰‹æœºï¼Œæ¸¸æˆå†å¥½ç©ä¹Ÿåªæ˜¯äºŒç»´çš„å¹³é¢ã€‚ä½†æ˜¯VRæ¸¸æˆå‘ç”Ÿåœ¨ä¸€ä¸ªä¸‰ç»´çš„ç©ºé—´ã€‚åœ¨ã€ŠåŠè¡°æœŸï¼šçˆ±è‰å…‹æ–¯ã€‹é‡Œï¼Œæœ‰æ€ªç‰©å‘ä½ æ‰‘æ¥ï¼Œä½ ä¼šåƒç°å®ç”Ÿæ´»ä¸­ä¸€æ ·ï¼Œå¾ˆè‡ªç„¶åœ°ä¸¾èµ·æ¤…å­ï¼ŒæŠŠæ€ªç‰©éš”å¼€ã€‚ åŠ¨å›¾å°é¢ ã€ŠåŠè¡°æœŸï¼šçˆ±è‰å…‹æ–¯ã€‹ï¼ˆHalf-Life: Alyxï¼‰ Valve Index ControlleræŒ‡è™å‹çš„è®¾è®¡æä¾›äº†å¯è¯†åˆ«å•ä¸ªæ‰‹æŒ‡åŠ¨ä½œçš„åŠŸèƒ½ï¼Œè¿™å°±æ˜¯VRçš„é­…åŠ›ï¼Œä½ å¯ä»¥çœŸçš„ç”¨æ‰‹ç©æ¸¸æˆï¼Œè€Œä¸æ˜¯ç”¨é¼ æ ‡å’Œé”®ç›˜â€”â€”ç°å®é‡Œæ‰‹æ€ä¹ˆåŠ¨ï¼Œæ¸¸æˆé‡Œæ‰‹å°±æ€ä¹ˆåŠ¨ã€‚ å¦‚æœè¯´2016å¹´çš„Pokemon Goæ˜¯ARæ¸¸æˆçš„ä»£è¡¨ä½œï¼Œé‚£ä¹ˆ2020å¹´çš„ã€ŠåŠè¡°æœŸï¼šçˆ±è‰å…‹æ–¯ã€‹å°±æ˜¯VRè¡Œä¸šçš„é‡Œç¨‹ç¢‘ã€‚ç»“ç»“å®å®åœ°è®©å„å¤§ç”µå•†å¹³å°çš„VRå¤´æ˜¾å–åˆ°äº†ç¼ºè´§ã€‚ AR/VRçš„ä½¿å‘½æ˜¯æ‰“ç©¿è™šæ‹Ÿå’Œç°å®ä¹‹é—´çš„é‚£é“å¢™ï¼Œ2020å¹´ï¼Œè¿™é“å¢™è‚‰çœ¼å¯è§åœ°åœ¨å˜è–„ã€‚ è½¯ä»¶ä¸Šé™†ç»­æœ‰äº†å¥½æ¸¸æˆï¼ŒVRç¡¬ä»¶ä¹Ÿæœ‰äº†æ™®éçš„è¿›æ­¥ã€‚ä½“ç°åœ¨ä¸€äº›ä¸“ä¸šçš„æŒ‡æ ‡ä¸Šï¼Œ6è‡ªç”±åº¦ï¼ˆ6Dofï¼‰å®šä½è¿½è¸ªã€90Hzåˆ·æ–°ç‡ï¼Œä»¥åŠæ›´é«˜çš„åˆ†è¾¨ç‡ã€‚ è¿˜è®°å¾—é‚£ä¸ªè¯¥æ­»çš„æ™•çœ©æ„Ÿå—ï¼ŸVRå¤´ç›”è®©äººæ™•çœ©ï¼Œæœ€ä¸»è¦çš„åŸå› åœ¨äºè®¡ç®—èƒ½åŠ›ä¸è¡Œï¼Œæœ‰å»¶è¿Ÿã€‚ä½ åœ¨çœŸå®ç©ºé—´ç§»åŠ¨äº†ï¼Œä½†æ˜¯è™šæ‹Ÿç”»é¢æ²¡æœ‰è·Ÿä¸ŠåŒæ­¥ç§»åŠ¨ï¼Œæ¯”å¦‚å»¶è¿Ÿäº†30æ¯«ç§’ï¼Œæ¥æ¥å›å›ï¼Œå°±æ™•äº†ã€‚å’Œæ™•è½¦ä¸€ä¸ªé“ç†ã€‚ å¾—ç›Šäºä¸“ä¸šAIèŠ¯ç‰‡å’ŒAIç©ºé—´å®šä½ç®—æ³•ï¼ŒåŠ ä¸Š5Gå¸¦æ¥å»¶æ—¶ä¸‹é™ï¼Œæ™•çœ©çš„è§£å†³æŒ‡æ—¥å¯å¾…ã€‚è¡Œä¸šä¸€èˆ¬è®¤ä¸ºæŠŠå»¶æ—¶ç¼©çŸ­åˆ°15æ¯«ç§’ä»¥å†…ï¼Œæ™•çœ©æ„Ÿå°±å¯ä»¥æ¶ˆé™¤ï¼Œè€Œç°åœ¨å·²ç»æ— é™é€¼è¿‘ã€‚ VRç¡¬ä»¶æ¥è¿å‡ºç°å¥½è®¾å¤‡ï¼ŒFacebookçš„Oculus Quest 2å’Œç´¢å°¼çš„PSVRï¼Œæ˜¯å…¬è®¤çš„ä¸¤å¼ºã€‚ ç´¢å°¼æœ‰PSæ¸¸æˆæœºçš„åº•å­ï¼Œç®—æ˜¯å¹²å¥½äº†è€æœ¬è¡Œï¼Œä½†æ˜¯Facebookè¿™ä¸ªäº’è”ç½‘æš´å‘æˆ·ä¹Ÿæ€äº†è¿›æ¥ï¼Œç¡®å®è®©äººåˆ®ç›®ç›¸çœ‹ã€‚ å¦å¤–ï¼ŒPSVRä¸æ˜¯ç‹¬ç«‹è®¾å¤‡ï¼Œéœ€è¦è¿æ¥ç´¢å°¼PSä¸»æœºæ‰èƒ½ç©ã€‚Oculus Questä¸€é—®ä¸–ï¼Œç´¢å°¼çš„å¸‚åœºä»½é¢èŠ‚èŠ‚è´¥é€€ã€‚ç´¢å°¼æ„Ÿè§‰åˆ°äº†åç»§ä¹åŠ›ï¼Œæ˜ç¡®è¡¨ç¤ºå›å®¶é—­å…³ä¿®ç‚¼å†…åŠŸï¼Œåˆ°2022å¹´å†å‘å¸ƒæ–°äº§å“ï¼Œä¸€å†³é›Œé›„ã€‚ è¿™æ ·çœ‹æ¥ï¼ŒOculusåŠ¿ä¸å¯æŒ¡çš„åŠ²å¤´ä¼šå»¶ç»­ä¸€ä¼šã€‚æ±Ÿæ¹–æœ‰äº†ä¼ è¯´ï¼Œè¦ç­‰æ­¦æ—ç›Ÿä¸»è‹¹æœäº²è‡ªå‡ºæ‰‹ï¼Œæ‰èƒ½æ€ä¸€æ€Oculusçš„åš£å¼ æ°”ç„°ã€‚ æ‰å…‹ä¼¯æ ¼å¯ç®—æ˜¯æ‰¬çœ‰åæ°”äº†ã€‚ 05 2014å¹´ï¼Œè…¾è®¯æ”¶è´­WhatsAppçš„äº¤æ˜“å‡ ä¹å·²ç»è°ˆå¦¥ï¼Œå°±å·®é©¬åŒ–è…¾å’ŒWhatsAppåˆ›å§‹äººJan Koumè§ä¸€é¢ã€‚ äººç®—ä¸å¦‚å¤©ç®—ï¼Œå…³é”®æ—¶åˆ»ï¼Œé©¬åŒ–è…¾è…°ä¼¤çš„è€æ¯›ç—…åˆçŠ¯äº†ï¼Œå†³å®šå…ˆåšæ‰‹æœ¯ï¼Œäºæ˜¯è§é¢æ¨è¿Ÿã€‚ ä¸æ–™æ‰å…‹ä¼¯æ ¼è¶è™šè€Œå…¥ï¼Œç»™Jan Koumå¼€å‡º190äº¿ç¾å…ƒçš„å¤©ä»·ã€‚å½“æ—¶ï¼ŒWhatsAppæ‰æˆç«‹äº”å¹´ï¼Œ50ä¸ªäººã€‚ 190äº¿ç¾å…ƒï¼é‚£è¿˜ç­‰ä»€ä¹ˆé©¬åŒ–è…¾ç‰›åŒ–è…¾ã€‚Dealï¼ æ—¶éš”ä¸ƒå¹´æ¥çœ‹ï¼Œé©¬åŒ–è…¾çš„ä¸€æ¬¡è…°ç–¼ï¼Œè®©è…¾è®¯ä¸¢æ‰äº†å›½é™…åŒ–æœ€å¥½çš„æŠ“æ‰‹ã€‚æ—¶è‡³ä»Šæ—¥ï¼Œè¿™å®¶å¸‚å€¼7ä¸‡äº¿æ¸¯å…ƒçš„ä¸­å›½ç¬¬ä¸€äº’è”ç½‘å…¬å¸ï¼Œå¹´æ”¶å…¥çš„95%éƒ½åœ¨ä¸­å›½ï¼Œè¿è·¨å›½ä¼ä¸šéƒ½ç§°ä¸ä¸Šã€‚ä½ è¯´ä½ æ˜¯é ç«äº‰èµ¢çš„ï¼Œä¸æ˜¯é å„æ–­ï¼Œä¸è¿‡åœ¨å…¨çƒå¸‚åœºï¼Œä½ å¥½åƒæ²¡èµ¢è¿‡å§ï¼Ÿ ä½†æ˜¯ï¼Œ2014å¹´ï¼Œè°èƒ½çœ‹å¾—é‚£ä¹ˆæ·±è¿œï¼Ÿå¾®ä¿¡æ”¯ä»˜å¥‡è¢­æ”¯ä»˜å®ï¼Œè…¾è®¯æ­£åœ¨é«˜æ­ŒçŒ›è¿›ï¼Œé©å‘½æ°”æ°›ä¸€ç‰‡å¤§å¥½ã€‚ ç›´åˆ°ç¾å›½çš„ç§‘æŠ€åª’ä½“the Informationå†™äº†ä¸€ç¯‡æ–‡ç« ã€ŠFacebookåº”è¯¥å‘å¾®ä¿¡å­¦ä¹ ä»€ä¹ˆã€‹ï¼ˆWhat Facebook Should Learn from WeChatï¼‰ï¼Œä¸­å›½äº’è”ç½‘åœˆï¼Œé™¤äº†é˜¿é‡Œå·´å·´è„¸è‰²ä¸å¥½ï¼Œåˆ«çš„ä»ä¸šè€…éƒ½é›†ä½“é«˜æ½®äº†ã€‚ è¾›è¾›è‹¦è‹¦è¿™ä¹ˆå¤šå¹´ï¼Œæˆ‘ä»¬åšçš„éƒ½æ˜¯copy to chinaã€‚æ°¸è¿œéƒ½æ˜¯ç¾å›½ä»€ä¹ˆç«äº†ï¼Œå°±copyä¸€ä¸‹å»ä¸­å›½åšä¸€ä¸ªä¸€æ ·çš„ã€‚ä¸­å›½çš„åˆ›ä¸šè€…å»åå°”è¡—ã€ç¡…è°·è®¨é’±ï¼ŒBPç”»å¾—å†ç²¾è‡´è€å¤–ä¹Ÿå¬ä¸æ‡‚ï¼Œè¿œè¿œä¸å¦‚æ¢ä¸€ä¸ªè°¦å‘çš„å£å»ï¼Œæœ‰ä¸€ç§æ„å‘³æ·±é•¿çš„å£°éŸ³è¯´ï¼Œâ€œæˆ‘ä»¬åšçš„è¿™ä¸ªï¼Œå°±æ˜¯è¿™æ˜¯ä¸­å›½çš„Facebookâ€ï¼Œâ€œä¸­å›½çš„Yelpâ€ï¼Œâ€œä¸­å›½çš„Amazonâ€â€¦â€¦è€å¤–ç«‹åˆ»æ‡‚äº†ï¼Œç™¾è¯•ä¸çˆ½ã€‚ å“ªèƒ½æƒ³åˆ°æœ‰ç”Ÿä¹‹å¹´èƒ½çœ‹åˆ°è¿™ä¸ªï¼Ÿï¼å¤šè±ªæƒ…å•Šï¼Œæ˜¯æ­£å„¿å…«ç»çš„è¥¿æ–¹åª’ä½“ï¼Œä¸¥è‚ƒçš„å‘Šè¯«ï¼ŒFacebookåº”è¯¥å‘ä¸­å›½çš„å¾®ä¿¡å­¦ä¹ ï¼ç”šè‡³æœ‰äººå¼€å§‹é€ ä¸€ä¸ªæ–°è¯â€œcopy from chinaâ€ã€‚ å‰å®³äº†ï¼Œæˆ‘çš„ä¸­å›½äº’è”ç½‘ã€‚ ä¸è¿‡ï¼Œè¿™æ•…äº‹è¿˜æœ‰ä¸€ä¸ªæ›´éªšçš„ç»“å°¾ã€‚2019å¹´ï¼Œæ‰å…‹ä¼¯æ ¼ç«Ÿç„¶äº²è‡ªå›åº”äº†è¿™ç¯‡æ–‡ç« ï¼Œæ‰¿è®¤è‡ªå·±é”™äº†ï¼Œè¯´ï¼Œæ‚”ä¸å¬å›ä¸€å¸­è¯ï¼Œæ—©å­¦å¾®ä¿¡å°±å¥½å•¦ã€‚ å¾ˆå¥‡æ€ªï¼Œè¿™ä¸€æ¬¡ï¼Œä¸­å›½çš„èˆ†è®ºä¸€ç‚¹éƒ½ä¸å—¨äº†ã€‚å—¨ä¸èµ·æ¥ã€‚æ²¡é”™ï¼Œè…¾è®¯å’ŒFacebookå„è‡ªç®¡ç†ç€ä¸­å›½æœ€å¤§å’Œä¸–ç•Œæœ€å¤§çš„ç¤¾äº¤äº§å“ï¼Œè…¾è®¯çš„å¸‚å€¼ç”šè‡³å·²ç»ç¨³ç¨³åœ°è¶…è¿‡äº†Facebookã€‚ ä½†æ˜¯ã€‚ è…¾è®¯ä¸‰åˆ†ä¹‹ä¸€çš„æ”¶å…¥æ˜¯æ¸¸æˆã€‚ä¸€å¹´1000å¤šäº¿å…ƒçš„æ¸¸æˆæ”¶å…¥ï¼Œå¸¸å¹´åœ¨ä¸–ç•Œæ¸¸æˆå…¬å¸æ”¶å…¥ä¸­æ’åç¬¬ä¸€ã€‚è®½åˆºçš„æ˜¯ï¼Œè¿™ä¸ªç¬¬ä¸€æ—¢åšä¸å‡ºåƒä½¿å‘½å¬å”¤ã€æ˜Ÿé™…äº‰éœ¸è¿™æ ·å¾æœå…¨çƒçš„3Aæ¸¸æˆï¼Œä¹Ÿä¸èƒ½åƒMicrosoftã€ä»»å¤©å ‚ã€ç´¢å°¼ä¸€æ ·ï¼Œåšå‡ºXboxã€Switchã€PSè¿™æ ·çš„é¡¶çº§æ¸¸æˆç¡¬ä»¶ã€‚ è¿™ä¸ªæ˜Ÿçƒä¸Šæœ€èµšé’±çš„æ¸¸æˆå…¬å¸ï¼Œå´å¯¹æ¸¸æˆè¡Œä¸šçš„è¿›æ­¥æä¾›ä¸äº†ä¸€ä¸ä¸€æ¯«çš„æ¨åŠ¨ã€‚ä»–æ˜¯å…¨ä¸–ç•Œæœ€å°´å°¬çš„æ¸¸æˆä¹‹ç‹ã€‚ è¿™å°±ä¸éš¾ç†è§£ï¼Œåœ¨çªå¦‚å…¶æ¥çš„VRæ—¶ä»£é‡Œï¼Œèƒ½æŒ‡æœ›ä»–åšå•¥å‘¢ï¼Ÿ 06 VRï¼Œä»¥åŠä¸€è„‰ç›¸æ‰¿çš„ARï¼Œå†åˆ°ç°åœ¨æ–°è¯è¿åŠ¨é‡Œçš„MR(Mixed Realityï¼Œæ··åˆç°å®)å’ŒXRï¼ˆExtended Realityï¼Œæ‹“å±•ç°å®ï¼‰ï¼Œæ ¸å¿ƒæ˜¯ä¸€æ ·çš„ï¼šæŠŠç°å®å’Œè™šæ‹Ÿæ›´æ·±åœ°æåˆ°ä¸€èµ·ã€‚ çºµè§‚äººç±»äº§ä¸šå†å²ï¼Œä¸€é¡¹é«˜ç²¾å°–çš„æŠ€æœ¯å¾€å¾€ç»å†å…ˆå†›ç”¨ï¼Œå†å•†ç”¨/æ°‘ç”¨çš„å‘å±•è¿‡ç¨‹ã€‚é™¤äº†æ·±åº¦æ¸¸æˆç©å®¶å’Œç§‘æŠ€è¿·ï¼ŒAR/VRè·ç¦»æ™®é€šäººçš„ç”Ÿæ´»è¿˜æœ‰ä¸€äº›è¿œï¼Œä½†æ˜¯å…¶åœ¨å†›ç”¨å’Œ2Bä¸šåŠ¡ä¸Šå·²ç»ç«™ç¨³äº†è„šè·Ÿï¼Œè€Œæ¶ˆè´¹çº§çš„æ°‘ç”¨äº§å“ï¼Œå·²ç»èµ°åˆ°äº†çˆ†å‘çš„å‰å¤œã€‚ å¯¹ä¸€ä¸ªäººæ¥è¯´ï¼Œä»˜å‡ºæ€»æœ‰å›æŠ¥ã€‚å¯¹ä¸€ä¸ªäº§ä¸šæ¥è¯´ï¼Œä¹Ÿæ˜¯åŠŸä¸å”æã€‚ VRäº§ä¸šçš„æ ¸å¿ƒæŠ€æœ¯åŒ…æ‹¬å®šä½æŠ€æœ¯ã€å…‰å­¦å…ƒä»¶ã€æ“ä½œç³»ç»Ÿã€èŠ¯ç‰‡ã€ä¼ æ„ŸæŠ€æœ¯ã€äººå·¥æ™ºèƒ½ã€ç”µå­ç»‡ç‰©ã€‚VRå¤´ç›”çœ‹ä¼¼æ˜¯ä¸€å°æ¸¸æˆæœºï¼Œä½†å®é™…ä¸Šæ˜¯ä¸€åœºé«˜ç²¾å°–æŠ€æœ¯çš„å¤§é˜…å…µã€‚ æ¯”å¦‚ï¼ŒVRè¡Œä¸šæ™®éä½¿ç”¨çš„SLAMæŠ€æœ¯ï¼Œåœ¨å®æ—¶æ€§å’Œç²¾åº¦ä¸Šè¦æ±‚éå¸¸é«˜ã€‚èƒ½èƒœä»»VRçš„æŠ€æœ¯ï¼Œåæ‰‹å°±å¯ä»¥ç”¨äºè‡ªåŠ¨é©¾é©¶å’Œæœºå™¨äººã€‚ å†æ¯”å¦‚ï¼ŒVRä¸­çš„è¯­éŸ³è¯†åˆ«ä¹Ÿæœ‰å¾ˆé«˜çš„è¦æ±‚ï¼Œä¸ä»…è¦è¯»æ‡‚è¯­æ„ï¼Œè¿˜è¦åŒ¹é…å˜´éƒ¨è¿åŠ¨ï¼Œä¸ä»…è¦åšåˆ°å®æ—¶æ€§ï¼Œè¿˜è¦èƒ½æ•æ‰é¢éƒ¨åŠ¨ä½œã€‚ é‡ä¸­ä¹‹é‡æ˜¯AIæŠ€æœ¯ï¼ŒVRä¸­çš„å®šä½å’Œè¯†åˆ«ï¼Œä¸€æ–¹é¢éœ€è¦ç¡¬ä»¶æ”¯æ’‘ï¼Œä¸€æ–¹é¢ï¼Œè¦é AIåšäº†å‡ åäº¿æ¬¡çš„æ¨¡æ‹Ÿã€‚ä¸­å›½çš„ç§‘æŠ€å¤§ä½¬ï¼ŒåŠ¨ä¸åŠ¨å°±è¯´è‡ªå·±å¯¹äºäººå·¥æ™ºèƒ½çš„æŠ•å…¥ï¼Œå¦‚ä»Šï¼Œæ˜¯éª¡å­æ˜¯é©¬ï¼Œæ˜¯æ—¶å€™æ‹‰å‡ºæ¥é›é›äº†ã€‚ ä¸ºä»€ä¹ˆè¯´VRæ‰¯æ‰äº†ä¸­å›½ç§‘æŠ€å•†ä¸šåœˆçš„é®ç¾å¸ƒï¼Ÿ å› ä¸ºå¯ä»¥ç¡®å®šçš„æ˜¯ï¼Œä¸­å›½äº§ä¸šç•Œä¸€å®šä¼šé‡å¤è‡ªå·±åœ¨PCå’Œæ™ºèƒ½æ‰‹æœºæ—¶ä»£ä¸€æ¨¡ä¸€æ ·çš„é—æ†¾â€”â€”é€ ä¸æ¥æ ¸å¿ƒæŠ€æœ¯ï¼Œç«™ä¸ä¸Šä¸»å¯¼åœ°ä½ã€‚ VRé‡Œï¼ŒèŠ¯ç‰‡è¿˜æ˜¯é«˜é€šçš„ã€‚å¦‚æœè¯´æ™ºèƒ½æ‰‹æœºè¿˜æœ‰åä¸ºã€è‹¹æœä¸¤ä¸ªå·¨å¤´è‡ªç ”èŠ¯ç‰‡çš„æ‚éŸ³ï¼Œé‚£ä¹ˆVRè¡Œä¸šå°±å®‰é™å¾ˆå¤šï¼ŒOculusã€HTCï¼Œå›½å†…çš„å°é¸Ÿã€å¤§æœ‹æ‰€æœ‰ä¸»æµè®¾å¤‡çš„èŠ¯ç‰‡éƒ½æ˜¯é«˜é€šçš„ã€‚ å†æ¯”å¦‚ï¼Œç”Ÿæ€çš„äº‰å¤ºè¿˜æ˜¯åœ¨ç¡…è°·å†…éƒ¨ã€‚å¾®è½¯Windowsæ“ä½œç³»ç»Ÿäº†PCæ—¶ä»£ï¼Œæ™ºèƒ½æ‰‹æœºæœ‰iOSå’Œå®‰å“äº‰é”‹ï¼ŒåŒæ ·ï¼ŒVRç”Ÿæ€ä¹Ÿä¼šæœ‰æ“ä½œç³»ç»Ÿã€‚ç›®å‰æ¥çœ‹ï¼ŒFacebookèµ°åœ¨å‰é¢ï¼Œåé¢è·Ÿç€å¾®è½¯ï¼ˆWindows Mixed Realityï¼‰å’Œè‹¹æœè¿™ä¸¤ä¸ªè€å®¶ä¼™çš„è¿½èµ¶ï¼Œè‡³æ­¤ï¼Œæ‹¿ç€æœ›çœ¼é•œçœ‹ï¼Œæ“ä½œç³»ç»Ÿè¿™ä»¶äº‹ä¹Ÿå’Œä¸­å›½æ— å…³ã€‚ å†…å®¹å¼€å‘æ›´æ˜¯ä¸­å›½ä¼ä¸šå¼±é¡¹ä¸­çš„å¼±é¡¹ï¼ŒOculus Questä¸Šçº¿äº†ä¸Šç™¾æ¬¾æ¸¸æˆï¼Œåªæœ‰ä¸€ä¸¤æ¬¾æ¥è‡ªä¸­å›½ã€‚ åœ¨VRæˆ˜åœºçš„æœ€å‰æ²¿ï¼Œå”¯ä¸€çš„ä¸­å›½å…ƒç´ åº”è¯¥æ˜¯æ­Œå°”ï¼Œæä¾›ä»£å·¥ï¼Œå’Œéƒ¨åˆ†éæ ¸å¿ƒå…ƒå™¨ä»¶ã€‚ VRä¸€å®šä¼šå’ŒPCå’Œæ™ºèƒ½æ‰‹æœºä¸€æ ·ï¼Œé‡å¤ä¸€æ ·çš„å‰§æœ¬â€”â€”å…ˆæ¥çš„äººå»ºå¥½äº†ç”Ÿæ€ï¼Œåæ¥çš„ç©å®¶æ°¸è¿œåªèƒ½å½“ç»¿å¶æˆ–è€…å½“è‚¥æ–™ï¼Œåƒä»Šå¤©ä¸€æ ·ï¼Œç»§ç»­äº¤è‹¹æœç¨ï¼Œäº¤å®‰å“ç¨ï¼Œäº¤é«˜é€šç¨â€¦â€¦ PCæ—¶ä»£ã€æ™ºèƒ½æ‰‹æœºæ—¶ä»£ï¼Œä¸­å›½ä¼ä¸šè¿˜æœ‰å€Ÿå£ï¼Œå› ä¸ºå‘å±•æµ…ï¼Œå› ä¸ºåº•å­è–„ï¼Œé™¤äº†è”æƒ³æœ‰é’±ï¼Œéƒ½æ‰¾ä¸å‡ºèƒ½åšå¤§äº‹çš„å¤§å…¬å¸ã€‚ä½†æ˜¯è¿™ä¸€æ¬¡ï¼Œé¢å¯¹VRè¿™ä¸ªæ–°ç¡¬ä»¶ï¼Œæ²¡å€Ÿå£äº†å§ï¼Œé‚£ä¹ˆå¤šäº’è”ç½‘ä¼ä¸šåœ¨ä¸­å›½æŒ£åˆ°äº†æƒŠæ‰è¥¿æ–¹åŒåƒšä¸‹å·´çš„å¤§åˆ©æ¶¦ã€‚ å½“å¹´ï¼Œè”æƒ³æâ€œè´¸å·¥æŠ€â€ï¼Œè¢«éª‚æƒ¨äº†â€”â€”ä½ çœ‹ï¼Œè”æƒ³å¤šçŸ­è§†ï¼Œèµšäº†é’±ä¸å¥½å¥½æç ”å‘ï¼Œæ²¡æœ‰å¡ä½å…³é”®æŠ€æœ¯å’Œå…³é”®ä½ç½®ï¼Œæ··æˆä»Šå¤©è¿™æ ·çœŸæ˜¯æ´»è¯¥ã€‚ ç„¶åï¼Œäº§ä¸šç•Œç”¨äº†20å¹´æ—¶é—´ï¼Œåªä¸ºäº†å‘ä¸–ç•Œè¯æ˜ï¼Œæˆ‘ä»¬äººäººéƒ½æ˜¯è”æƒ³ã€‚ å»åšçœŸçš„ç§‘æŠ€å…¬å¸ï¼Œåœ¨ç®¡ç†å¥½è´¢åŠ¡å¹³è¡¡çš„åŒæ—¶ï¼Œå°½æœ€å¤§å¯èƒ½åœ°ç”¨ç§‘æŠ€æ‹“å®½äººç±»çš„è¾¹ç•Œï¼Œè€Œä¸æ˜¯åªç›¯ç€çŸ­æœŸèƒ½èµšé’±çš„äº‹ï¼Œé å„æ–­åˆ©æ¶¦ï¼ŒæŠŠå¸‚å€¼å’å¾—å¦‚æ­¤è™šé«˜â€”â€”è¿™æ˜¯ä¸­å›½äº§ä¸šç•Œæœ€è¦å­¦ä¹ ï¼Œå´æ°¸è¿œæ— æ³•å¸å–çš„æ•™è®­ã€‚ å°±æ‹¿VRæ¥è¯´ï¼Œå…ˆè¡Œè€…å’Œé•¿æœŸä¸»ä¹‰è€…çš„æ›™å…‰æ¸æ¸å±•ç°ã€‚ æŒ‰ç…§é”€å”®æ•°æ®ä¼°ç®—ï¼ŒOculus Quest 1å’ŒOculus Quest 2çš„ç´¯è®¡é”€é‡å³å°†çªç ´1000ä¸‡ã€‚1000ä¸‡ä»€ä¹ˆæ¦‚å¿µï¼Ÿæ™ºèƒ½æ‰‹æœºè½»è½»æ¾æ¾ä¸€å¹´å–å‡º10äº¿å°ï¼ŒPCä¸æ–­è¡°è½ï¼Œä½†æ˜¯å…¨çƒå¹´é”€é‡ä¾æ—§åœ¨2-3äº¿ã€‚è¿™æ ·çœ‹æ¥1000ä¸‡ï¼ˆè€Œä¸”è¿˜æ˜¯ç´¯è®¡æ•°ï¼‰ï¼Œç®€ç›´ä¸å€¼ä¸€æï¼Œè·ç¦»å°æ‰è‡ªå·±å¹çš„ç‰›Bï¼Œâ€œè¦è®©10äº¿äººä½¿ç”¨Oculusâ€ï¼Œè¿˜å·®9.9äº¿ã€‚ ä½†æ˜¯ï¼Œè¡Œä¸šé‡Œçš„å‚ä¸è€…æ‰çŸ¥é“ï¼Œ1000ä¸‡ï¼Œæ„å‘³ç€è¡Œä¸šçš„ç”Ÿæ€æˆå‹ï¼Œå·²ç»æœ‰äº†è§„æ¨¡ç»æµï¼Œä»æ­¤å†…å®¹ç”Ÿäº§è€…å¯ä»¥èµšåˆ°é’±äº†ï¼Œä¼šæœ‰è¶Šæ¥è¶Šå¤šçš„å¼€å‘è€…æŠ•å…¥è¿›æ¥ã€‚å†…å®¹è¶Šä¸°å¯Œï¼Œç”Ÿæ€å°±è¶Šå¸å¼•ç”¨æˆ·ã€‚ä¸‡äº‹å¼€å¤´éš¾ï¼Œä½†Oculusè¿ˆè¿‡äº†ç¬¬ä¸€é“æ§›ï¼Œè¿™ä¸ªç”Ÿæ€å°†å¼€å§‹è‰¯æ€§å¾ªç¯ã€‚ æ‰å…‹ä¼¯æ ¼çœŸæ˜¯å¤Ÿå¿ƒç‹ æ‰‹è¾£çš„ï¼ŒæŠŠOculusçš„ä»·æ ¼æ€åˆ°299ç¾å…ƒï¼Œæ¯”ä¸€å°æ™®é€šæ™ºèƒ½æ‰‹æœºè¿˜ä¾¿å®œã€‚è¿™æ˜¯ä»€ä¹ˆæ¦‚å¿µï¼Ÿå‰é¢æåˆ°Vavleå…¬å¸è‡ªå·±çš„VRè®¾å¤‡è¦999ç¾å…ƒï¼Œå“é€€ä¸€ä¼—å±Œä¸ï¼Œä¸å¯èƒ½æ™®åŠã€‚åä¸ºç»å¯¹æ˜¯å›½äº§ä¹‹å…‰å’Œä»·æ ¼å± å¤«ï¼Œä½†æ˜¯åä¸ºVRäº§å“çš„ä»·æ ¼åªèƒ½å‹åˆ°3000å…ƒäººæ°‘å¸ï¼Œè€Œä¸”å’ŒOculusæ¯”ï¼Œåä¸ºVRç¬¬ä¸€ä¸æ˜¯ç‹¬ç«‹è®¾å¤‡ï¼Œç¬¬äºŒæ€§èƒ½å·®ä¸€æˆªï¼Œç¬¬ä¸‰ç”Ÿæ€å·®ï¼Œæ²¡æœ‰å¥½æ¸¸æˆã€‚ Oculusçš„299ç¾å…ƒï¼Œå°±å¥½æ¯”æ—©å·²æ˜¯è¡Œä¸šç¬¬ä¸€å´åœ¨ä¸æ–­é™ä»·çš„ç‰¹æ–¯æ‹‰ï¼Œåæ¥è€…æƒ³è¿›å…¥è¿™ä¸ªè¡Œä¸šï¼Œä½†æ˜¯å¤§é—¨æ­£åœ¨è¢«æ‰å…‹ä¼¯æ ¼ä¸€ç‚¹ç‚¹å…³ä¸Šã€‚ Facebookå’Œä»–çš„VRå™äº‹ï¼Œåº”è¯¥æ˜¯ä¸­å›½åŒè¡Œçš„ä¸€é¢é•œå­ã€‚ åœ¨VRèº«ä¸Šï¼Œå€¼å¾—æˆ‘ä»¬ç¾¡æ…•çš„æ˜¯ç¾å›½çš„å•†ä¸šç”Ÿæ€ã€‚å·¨å¤´å…¬å¸æ•¢æ‰“ç§‘æŠ€ç¡¬ä»—ï¼Œé‡é‡‘æŠ•å…¥åœ¨å‘¨æœŸé•¿ã€å®šä½é«˜çš„èµ›é“ï¼Œè€å¿ƒå­µåŒ–é€ ç”Ÿæ€ï¼Œè¦å¹²å°±è¦å¹²æ ¸å¿ƒæŠ€æœ¯ã€‚ è¿™æ°æ°æ˜¯ä¸­å›½ç§‘æŠ€ç•Œã€äº§ä¸šç•Œæœ€çŸ­ç¼ºçš„ã€‚çŸ­è§†ã€åŠŸåˆ©ï¼Œä»€ä¹ˆèµšé’±åšä»€ä¹ˆï¼Œå·²ç»æ˜¯æ·±å…¥çµé­‚çš„ä¿¡ä»°ã€‚å¾€æ·±äº†è¯´ï¼Œå› ä¸ºä½ ä»¬æ²¡æœ‰æå®¢ç²¾ç¥ï¼Œä»æ¥æ²¡æœ‰æŠŠæ‰©å®½äººç±»è¾¹ç•Œå½“ä½œè‡ªå·±çš„ä½¿å‘½ã€‚ä»¥ä¸ºæå€¡å‘˜å·¥ç©¿ç‰›ä»”è£¤ï¼Œç»™å‘˜å·¥é…macç”µè„‘å°±æ˜¯ç§‘æŠ€å…¬å¸äº†ï¼Œå…¶å®å‘¢ï¼Œå¤§å‚çš„èƒ¸ç‰Œå†æ˜å…‰æ™ƒæ™ƒï¼Œä¸€å¼€å£è¯´è¯éƒ½æ˜¯å¸‚ä¾©çš„å‘³é“ï¼Œæ˜¯ä¸€ä¸ªèµ¶é›†çš„ä¹°å–äººï¼Œå…¶å®å¾ˆåœŸçš„ã€‚ ä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Ÿ ç¬¬ä¸€æ˜¯çºµå®¹å„æ–­ï¼Œè€Œå„æ–­çš„åŸå› åˆæ˜¯å¸‚åœºä¸å¼€æ”¾ã€‚æ¯”å¦‚ï¼Œè¯´äº†é‚£ä¹ˆå¤šï¼Œå…¶å®ä¸­å›½æ ¹æœ¬ä¹°ä¸åˆ°Oculusï¼Œæ¯•ç«ŸFacebookéƒ½è¿˜æ²¡æœ‰è¿›å…¥ä¸­å›½å¸‚åœºã€‚æ‹¿è…¾è®¯æ¥è¯´ï¼Œåªæœ‰é‡åˆ°ä½“é‡ç›¸å½“çš„ç«äº‰å¯¹æ‰‹ï¼Œæ‰èƒ½èµ°å‡ºâ€œæ²¡æœ‰æ¢¦æƒ³â€çš„è¯…å’’ã€‚ ç¬¬äºŒï¼ŒçŸ¥è¯†äº§æƒçš„ä¿æŠ¤è¿˜æ˜¯è¿œè¿œä¸å¤Ÿã€‚åœ¨ä¸­å›½åªæœ‰å‚»å­æ‰å¥½å¥½åšæ¸¸æˆå’Œå†…å®¹ï¼Œä½ åšå¾—å†å¥½ï¼Œç¬¬äºŒå¤©å°±æœ‰äº†å…è´¹ä¸‹è½½çš„ç ´è§£ç‰ˆã€‚æŒ‡æœ›â€œç”¨çˆ±å‘ç”µâ€ï¼Œèƒ½å®Œæˆäº§ä¸šè¿è·ƒï¼Œç¬‘è¯ã€‚ æ–°ç¡¬ä»¶ä¹‹æˆ˜ï¼Œæˆ–è€…è¯´ï¼Œç”Ÿæ€ä¹‹æˆ˜æ€ä¹ˆæ‰“ï¼Ÿè¿™éœ€è¦ï¼Œå¤§å…¬å¸æ•¢æ‰“ç¡¬ä»—ï¼Œå°å…¬å¸èƒ½é å†…å®¹æœ¬èº«èµšåˆ°é’±ã€‚è€Œæˆ‘ä»¬æš‚æ—¶è¿˜æ²¡æœ‰è¿™æ ·çš„åœŸå£¤ã€‚ VRçœŸæœ‰æ„æ€ï¼Œå®ƒçš„ç›®æ ‡æ˜¯æ‹†æ‰è™šæ‹Ÿå’Œç°å®ä¹‹é—´çš„é‚£é“å¢™ã€‚åœ¨æˆ‘çœ‹æ¥ï¼Œä¸­å›½è¦å®ç°VRäº§ä¸šçš„å¤§çªç ´ï¼Œæˆ‘ä»¬çš„ç›®æ ‡åº”è¯¥æ˜¯å…ˆæ‹†æ‰ç°å®ç”Ÿæ´»é‡Œçš„æŸäº›å¢™ã€‚ è°¢è°¢è¯»å®Œï¼Œè™šæ‹ŸäººVRåˆ›å§‹äººå€ªå¿—åŠ›ï¼Œå¯¹æ­¤æ–‡äº¦æœ‰æŒ‡å¯¼ ","link":"https://xuaii.github.io/post/zhuan-zai-vr-che-diao-liao-zhong-guo-ke-ji-quan-de-zhe-xiu-bu/"},{"title":"æ¸¸æˆæœºåˆ¶-é‡Œä¸–ç•Œ","content":"é‡Œä¸–ç•Œæœºåˆ¶ æœºåˆ¶æ¦‚å¿µç®€è¿°ï¼šå­˜åœ¨ä¸¤ä¸ªä¸åŒçš„ä¸–ç•Œï¼Œé‡Œä¸–ç•Œå’Œè¡¨ä¸–ç•Œ ä»–ä»¬æœ‰å¤§è‡´ç›¸åŒçš„åœºæ™¯æ•´ä½“å½¢çŠ¶ï¼Œä¸åŒçš„åœºæ™¯é£æ ¼ï¼ˆä¾‹å¦‚ï¼Œå´­æ–°&lt;-&gt;è€æ—§ï¼Œæ¸…æ´&lt;-&gt;æ±¡æŸ“ï¼‰ æœ‰ä¸€ä¸ªé€é•œèƒ½åœ¨è¡¨ä¸–ç•Œçœ‹è§é‡Œä¸–ç•Œçš„ç‰©ä½“å¹¶ä¸”äº’åŠ¨ åªæœ‰ç©å®¶èƒ½åœ¨é‡Œä¸–ç•Œå’Œè¡¨ä¸–ç•Œé—´ç©¿æ¢­ï¼Œè¿™æ„å‘³ç€ç©å®¶å¯ä»¥é€šè¿‡åˆ‡æ¢ä¸–ç•Œæ¥èº²é¿ä¼¤å®³ æ‰€æœ‰çš„å¤–éƒ¨ç‰©ä½“ï¼ˆé™¤ç©å®¶å¤–ï¼‰ï¼Œä¸é€é•œå‘ç”Ÿç¢°æ’æ—¶å¯ä»¥ ä»¥ä¸€ç§ç‰¹æ•ˆçš„çš„æ–¹å¼ç©¿è¿‡ï¼Œæš—ç¤ºå¯¹ç©å®¶æ²¡æœ‰ä¼¤å®³ ç›´æ¥ä¸é€é•œç¢°æ’ç„¶åæ¶ˆå¤± é€šè¿‡å¯¹é€é•œçš„å½¢çŠ¶é™åˆ¶æ¥è®¾è®¡å…³å¡ å®ç°ï¼šè¡¨ç¤ºä¸–ç•Œå’Œé‡Œä¸–ç•Œå°†åœ¨ä¸€ä¸ªåœºæ™¯èŠ‚ç‚¹ä¸­è¡¨ç¤º é€é•œç‰©ä½“æ˜¯ä¸€ä¸ªLight2Dï¼Œ é€šè¿‡å…‰ç…§Maskæ˜¾ç¤º/å‰”é™¤é‡Œä¸–ç•Œçš„ç‰©ä½“çš„Sprite é€é•œç‰©ä½“æ˜¯ä¸€ä¸ªArea2Dï¼Œé€šè¿‡è®°å½•è¿›å…¥åŒºåŸŸä¸­çš„é‡Œä¸–ç•Œç‰©ä½“ï¼Œå¹¶ä¸”å®æ—¶ä¿®æ”¹é‡Œä¸–ç•Œç‰©ä½“çš„ç¢°æ’å½¢çŠ¶ï¼Œå¦‚æœæ˜¯è¡¨ä¸–ç•Œï¼ˆé‚£ä¹ˆæ ¹æ®ç®€è¿°3æ¥å¤„ç†ï¼‰ public class SuperLens : Area2D { public Dictionary&lt;string, InnerObject&gt; data = new Dictionary&lt;string, InnerObject&gt;(); public void OnObjectExit(Node node) { if(node is InnerObject innerObject &amp;&amp; data.ContainsKey(innerObject.Name)) { data.remove(innerObject.Name); } } public void OnObjectEnter(Node node) { if(node is InnerObject innerObject ) { data[innerObject.Name] = innerObject; } if(node is OuterObject outerObject ) { ProcessOuterObject(outerObject); } } public override void _PhysicsProcess(float delta) { foreach(var inner in data.Values) { // æ›´æ”¹ç¢°æ’ä½“ç§¯ inner.Rect = inner.DefaultRect.overlap(this.Rect); } } } ","link":"https://xuaii.github.io/post/you-xi-ji-zhi-li-shi-jie/"},{"title":"æ¸¸æˆæœºåˆ¶-çª—ä½“äº’åŠ¨","content":"ä½¿ç”¨ Godot å¯¹WindowFrame è¿›è¡Œæ‹™åŠ£çš„æ¨¡ä»¿ï¼Œè§‚å¯Ÿè§†é¢‘ä¸­çš„çª—ä½“æœ‰ä»¥ä¸‹æ€§è´¨ï¼š çª—ä½“æ—¢æ˜¯ UI ä¹Ÿæ˜¯å¯ä»¥ä¸ç©å®¶äº’åŠ¨çš„ åœºæ™¯ç‰©ä½“ çª—å£çš„ä½ç½®å¯ä»¥ç”±åœºæ™¯ç‰©ç†æ”¹å˜ä¹Ÿå¯ä»¥ç”±é¼ æ ‡æ§åˆ¶æ”¹å˜ ç©å®¶å¯ä»¥å‘å°„å­å¼¹ï¼Œå­å¼¹ç¢°åˆ°çš„è¾¹è¿›å…¥é”å®šçŠ¶æ€ï¼Œä¸€æ®µæ—¶é—´åå­å¼¹æ¶ˆå¤±ï¼Œå¹¶ä¸”è§£é™¤é”å®š è€ƒè™‘ä¸€ä¸‹å‡ ç§è®¾è®¡ï¼š æ–¹æ¡ˆä¸€ å­˜åœ¨ä¸€ä¸ªçª—ä½“å¯¹è±¡windowå’Œåœºæ™¯å¯¹è±¡rect æ¯ä¸€å¸§å°†rectå¤§å°å’Œä½ç½®ç»è¿‡MPVå˜æ¢ååŒæ­¥åˆ°çª—å£å¤§å° æ¯ä¸€ä¸ªrect å¯¹è±¡æœ‰ä¸€ä¸ªé»˜è®¤çš„åˆå§‹å¤§å° rect å¯¹è±¡æŒæœ‰å››æ¡è¾¹çš„å¯¹è±¡ lineï¼Œæ¯ä¸ªlineå¯¹è±¡æœ‰ follow/move/lock/idleçŠ¶æ€ Follow çŠ¶æ€çš„è¾¹è·Ÿéš target(player) è¿åŠ¨ Move çŠ¶æ€çš„è¾¹èƒ½è¢«é¼ æ ‡æ‹–åŠ¨ Lock çŠ¶æ€çš„è¾¹åœ¨ç©å®¶ç§»åŠ¨è¿‡ç¨‹ä¸­å……å½“ å¢™ æˆ– åœ°æ¿ Idle çŠ¶æ€ï¼Œæ˜¯åœºæ™¯ä¸­æ²¡æœ‰ target æ—¶çš„çŠ¶æ€ rect å¯¹è±¡å®è¿›å…¥åœºæ™¯æ ‘çš„æ—¶å€™ç”Ÿæˆ windows å¯¹è±¡ï¼Œå¹¶æŒæœ‰ï¼Œrecté€€å‡ºåœºæ™¯æ ‘çš„æ—¶å€™å›æ”¶ windows å¯¹è±¡ å„ä¸ªçŠ¶æ€éƒ½æœ‰å¯¹åº”çš„ Physics Collision Layer / Maskï¼Œä¾‹å¦‚é”å®šçŠ¶æ€çš„è¾¹ä¼šé˜»æŒ¡æŸäº›æ”»å‡»ï¼Œæ‹–åŠ¨æ—¶å’Œé”å®šæ—¶ä¸ç©å®¶çš„ç¢°æ’æ˜¯ä¸ä¸€æ ·çš„ã€‚ using Godot; using System; public class InteractiveAnchor : RigidBody2D { public Vector2 velocity; public bool IsStop = false; public Vector2 StopPosition = Vector2.Zero; ColorRect rect; RandomNumberGenerator _random = new RandomNumberGenerator(); public delegate void InteractiveAnchorCallBack(InteractiveAnchor anchor); public InteractiveAnchorCallBack callback; // cache ä¸€æ—¦é”å®šç›®æ ‡ï¼Œä¸å¯æ›´æ”¹ï¼ï¼ InteractiveLine AnotherCache = null; public override void _Ready(); public void Init(Vector2 _velocity, InteractiveAnchorCallBack _callback); public override void _ExitTree(); // // Called every frame. 'delta' is the elapsed time since the previous frame. public override void _PhysicsProcess(float delta); // æ·»åŠ æŠ–åŠ¨å°†è¦åˆ é™¤æ—¶ public void _on_DeleteEffect_timeout(); void _on_Area2D_body_entered(Node body); void _on_Area2D_body_exited(Node body); void CacheCurrentState(Vector2 origin_global_position); } public class InteractiveArea : Area2D { public override void _Ready(); Node Scene; public override void _EnterTree(); public override void _PhysicsProcess(float delta); void _on_Area2D_body_entered(Node body); void _on_Area2D_body_exited(Node body); } public class InteractiveBorder : Node2D { // æ˜¾ç¤ºåŒºåŸŸå¤§å° public Rect2 window; [Export] public Rect2 DefalutRect; [Export] public float BorderWidth; public InteractiveLine left; public InteractiveLine right; public InteractiveLine top; public InteractiveLine down; public InteractiveWindow interactiveWindow; public Vector2 Start; public Vector2 End; public Rect2 UIRect; public override void _Ready(); public override void _EnterTree(); public override void _Draw(); public override void _Process(float delta); public override void _PhysicsProcess(float delta); public void Reset(); public void SetRect(Rect2 _window); public void SetCollision(bool flag); } public class InteractiveLine : KinematicBody2D { public bool IsLocked; static public string IsSlideName = &quot;&quot;; public SegmentShape2D shape; public InteractiveWindow window; public Vector2 velocity = Vector2.Zero; public int ColllisionCount = 0; [Export] public Vector2 DefaultBias; public override void _Ready(); public override void _ExitTree(); public override void _PhysicsProcess(float delta); public void SetCollision(uint layer, uint mask); public void Reset(); public float DistanceToLine(Vector2 P, Vector2 A, Vector2 B); } public class InteractiveLineFollow : StateNode&lt;InteractiveLine&gt; { public override void Enter() { target.SetCollision(target.window.FollowLayer, target.window.FollowMask); } public override void _PhysicsUpdate(float delta) { /// å¦‚æœæ²¡æœ‰ç›®æ ‡ï¼Œå°±è½¬ç§»åˆ°Lockï¼Ÿ if(!target.window.IsLockTarget) { _machine.Transition&lt;InteractiveLineIdle&gt;(); return; } if(target.window.Target.IsInsideTree()) { target.GlobalPosition = target.window.Target.GlobalPosition + target.DefaultBias; } if(target.ColllisionCount != 0) { _machine.Transition&lt;InteractiveLineLock&gt;(); return; } } public class InteractiveLineIdle : StateNode&lt;InteractiveLine&gt; { public override void _PhysicsUpdate(float delta) { if(target.window.IsLockTarget) { _machine.Transition&lt;InteractiveLineFollow&gt;(); return; } } } public class InteractiveLineLock : StateNode&lt;InteractiveLine&gt; { Vector2 cachePosition = Vector2.Zero; public override void Enter() { target.IsLocked = true; cachePosition = target.Position; target.SetCollision(target.window.LockLayer, target.window.LockMask); } public override void Exit() { target.IsLocked = false; } public override void _PhysicsUpdate(float delta) { // TODO:è¿™é‡Œæ˜¯å¦å¯ä»¥ä¸ç§»åŠ¨é”å®šçš„ç›®æ ‡ä¸ç§»åŠ¨ if(cachePosition != null) target.Position = cachePosition; if(target.ColllisionCount == 0) { _machine.Transition&lt;InteractiveLineFollow&gt;(); return; } if(Input.IsActionJustPressed(&quot;mouse_right&quot;) &amp;&amp; target.NormalToLine(target.GetGlobalMousePosition(), target.GlobalPosition + target.shape.A, target.GlobalPosition + target.shape.B).Length() &lt; 14f) { // è¿›å…¥æ‹–åŠ¨çŠ¶æ€ _machine.Transition&lt;InteractiveLineMove&gt;(); return; } } } public class InteractiveLineMove : StateNode&lt;InteractiveLine&gt; { public override void Enter() { target.SetCollision(target.window.MoveLayer, target.window.MoveMask); } public float PlayerMargin = 50f; private float MoveSpeed = 50f; public override void _PhysicsUpdate(float delta) { if(!target.window.IsLockTarget) { _machine.Transition&lt;InteractiveLineIdle&gt;(); return; } Vector2 line_movement = target.NormalToLine(target.GetGlobalMousePosition(), target.GlobalPosition + target.shape.A, target.GlobalPosition + target.shape.B); Vector2 player_movement = target.NormalToLine(target.window.Target.GlobalPosition, target.GlobalPosition + target.shape.A, target.GlobalPosition + target.shape.B); if(line_movement.Dot(player_movement) &lt; 0f || !target.window.Target.TestMove(target.window.Target.GlobalTransform, line_movement * delta) || player_movement.Length() &gt; PlayerMargin) { // é¼ æ ‡ä½ç½®ä¸Playeråœ¨lineå¼‚ä¾§ä¸é™åˆ¶é€Ÿåº¦ï¼Œplayerä¸lineè·ç¦»è¶³å¤Ÿå¤§ä¸é™åˆ¶é€Ÿåº¦ï¼›å…¶ä½™æƒ…å†µé™åˆ¶é€Ÿåº¦ if(line_movement.Dot(player_movement) &lt; 0f || player_movement.Length() &gt; PlayerMargin) { target.GlobalPosition += line_movement; } else { target.GlobalPosition += line_movement.Normalized() * MoveSpeed * delta; } } if(Input.IsActionJustReleased(&quot;mouse_right&quot;)) { _machine.Transition&lt;InteractiveLineLock&gt;(); return; } } } public class InteractiveWindow : Node2D { // window local position [Export] PackedScene bullet; [Export(PropertyHint.Layers2dPhysics)] public uint MoveMask; [Export(PropertyHint.Layers2dPhysics)] public uint MoveLayer; [Export(PropertyHint.Layers2dPhysics)] public uint FollowMask; [Export(PropertyHint.Layers2dPhysics)] public uint FollowLayer; [Export(PropertyHint.Layers2dPhysics)] public uint LockMask; [Export(PropertyHint.Layers2dPhysics)] public uint LockLayer; ShaderMaterial shader; public InteractiveBorder border; Main screen; // canvas + window related WindowDialog dialog; CanvasLayer canvas; // screen effects Tween tween; RandomNumberGenerator _random = new RandomNumberGenerator(); Queue&lt;InteractiveAnchor&gt; queue = new Queue&lt;InteractiveAnchor&gt;(); // mouse related // physics's disabled area Area2D area; RectangleShape2D shape; [Export] Vector2 SoftMargin = new Vector2(5, 5); // target lock related public bool IsLockTarget = false; public KinematicBody2D Target = null; public Console _wrapper; public override void _Ready(); public override void _EnterTree(); public override void _ExitTree(); void _DeferredPrograce() { screen.RemoveChild(canvas); screen.ResetScreen(); this.AddChild(canvas); } public override void _PhysicsProcess(float delta) { // 1. window æ›´æ–° + å¯è§†åŒºå‰ªè£ screen.SetDisplayRect(border.Start, border.End); // 2. windowdialog å¯¹é½ dialog.Popup_(border.UIRect.Clip(screen.viewport.GetVisibleRect())); // 3. ç‰©ç†å¼€å¯åŒºåŸŸå¯¹é½ area.Position = border.window.Position - SoftMargin; shape.Extents = border.window.Size + SoftMargin * 2; } public void OnWindowGuiInput(InputEvent inputEvent) { if (inputEvent is InputEventMouseButton mouseEvent &amp;&amp; mouseEvent.Pressed) { switch ((ButtonList)mouseEvent.ButtonIndex) { case ButtonList.Left: { if(IsLockTarget) { InteractiveAnchor anchor = bullet.Instance&lt;InteractiveAnchor&gt;(); anchor.GlobalPosition = GetGlobalTransform().AffineInverse() * GetViewportTransform().AffineInverse() * (border.Start + mouseEvent.Position); this.CallDeferred(&quot;add_child&quot;, anchor); // anchor.CallDeferred(&quot;Init&quot;, border.Start + mouseEvent.Position - BasicFollowCamera.Target.ScreenPosition, (object)EffectCallback); anchor.Init((border.Start + mouseEvent.Position - BasicFollowCamera.Target.ScreenPosition), EffectCallback); } break; } case ButtonList.WheelUp: break; } } if (inputEvent is InputEventKey keyEvent &amp;&amp; keyEvent.Pressed) { switch ((int)keyEvent.Scancode) { case (int)KeyList.L: { break; } } } } // delete callback public void EffectCallback(InteractiveAnchor anchor); void disturb_offset(float _strength) { dialog.RectPosition += new Vector2(_random.RandfRange(-_strength, _strength), _random.RandfRange(-_strength, _strength)); screen.GetNode&lt;TextureRect&gt;(&quot;CanvasLayer/_ScreenTexture&quot;).RectPosition += new Vector2(_random.RandfRange(-_strength, _strength), _random.RandfRange(-_strength, _strength)); } public void LockTarget(KinematicBody2D target); public void UnlockTarget(); public void EnableBackground(); public void DisableBackground(); public void SetRect(Rect2 _window); public void Reset(); // CommandLine private void LockPlayer(); private void _on_ActivateArea_body_entered(Node body); } æ€»ç»“ï¼šè¿™æ ·çš„è®¾è®¡æœ‰ä»¥ä¸‹ç¼ºé™· æ‹–åŠ¨ Line æ—¶ä¸èƒ½ç›´æ¥ä¿®æ”¹ velocityï¼Œå› ä¸ºæ‹–åŠ¨æ—¶Lineæœ‰å¯èƒ½ä¼šä¸Playerå‘ç”Ÿç¢°æ’ï¼ˆéœ€è¦KinematicBody2D çš„SlideAndCollideæ–¹æ³•æ›´æ–°é€Ÿåº¦ï¼‰ï¼Œæ‰€ä»¥åªèƒ½è®¾è®¡ä¸€ç§æœ‰é¼ æ ‡ä½ç½®è®¡ç®— Line.velocity çš„æ–¹æ³•ã€‚ çª—å£Windowå¯¹è±¡åœ¨åœºæ™¯çš„UIèŠ‚ç‚¹ä¸‹ï¼Œå€Ÿæ­¤å°†åœºæ™¯ç›¸æœºçš„ç”»é¢ç»˜åˆ¶åˆ°çª—å£ç›¸åº”çš„ä½ç½®ï¼Œè¿™æ ·è®¾è®¡ä¸ç‰©ä½“å¤–çš„ç»“æ„è€¦åˆã€‚ å¦‚æœæƒ³å®ç°çª—å£å¤–çš„ä¸€åˆ‡å¯¹è±¡åœæ­¢æ›´æ–°æ¯”è¾ƒéº»çƒ¦ï¼ˆä»…ä»… Update ç›¸æœºå†…çš„å¯¹è±¡ï¼‰ï¼Œåº”è¯¥æœ‰å¼•æ“è‡ªå¸¦çš„æ–¹æ³•æ¯”è¾ƒæ–¹ä¾¿ã€‚ æ–¹æ¡ˆäºŒ ä¸ä½¿ç”¨ UI å¯¹è±¡ï¼Œå°†äº¤äº’å’Œç‰©ç†å…¨éƒ¨é›†ä¸­åˆ°ä¸€ä¸ª Rect å¯¹è±¡ä¸­ã€‚ äº¤äº’çª—ä½“åŒ…å«å››æ¡è¾¹ï¼Œæ¯æ¡è¾¹åŒ…å«ç¢°æ’è®¾ç½®å’Œé¼ æ ‡é è¿‘æ£€æŸ¥ï¼ˆé”å®šçŠ¶æ€ï¼‰ æ¯æ¡è¾¹æ‹¥æœ‰ç›¸ä¼¼çš„å‡ ç§çŠ¶æ€ï¼Œç‰¹åˆ«çš„åœ¨æ‹–åŠ¨æ—¶ï¼Œä¾ç„¶ä½¿ç”¨velocityæ¥ç§»åŠ¨æ¯æ¡è¾¹ å½“é¼ æ ‡å·¦é”®æŒ‰ä¸‹ &amp;&amp; é¼ æ ‡ä½ç½®åœ¨è¾¹çš„æ‹–åŠ¨åŒºåŸŸæ—¶ ==&gt; è¿›å…¥æ‹–åŠ¨çŠ¶æ€ æ¾å¼€é¼ æ ‡å·¦é”®æ—¶ ==&gt; é€€å‡ºæ‹–åŠ¨çŠ¶æ€ æ‹–åŠ¨çŠ¶æ€ä¸‹ï¼Œé¼ æ ‡ä½ç½®ï¼Œè¾¹ä½ç½®ï¼Œè¾¹é€Ÿåº¦çš„å…³ç³»å¦‚ä¸‹ velocityL=(posMâˆ’posL)â‹…normalLâˆ£âˆ£normalLâˆ£âˆ£velocity_L = \\frac{(pos_M - pos_L) \\cdot normal_L}{||normal_L||} velocityLâ€‹=âˆ£âˆ£normalLâ€‹âˆ£âˆ£(posMâ€‹âˆ’posLâ€‹)â‹…normalLâ€‹â€‹ è¿™æ ·ï¼Œçª—å£ç§»åŠ¨å§‹ç»ˆæ¯”é¼ æ ‡ä½ç½®å»¶åä¸€å¸§ï¼Œä½†æ˜¯ç§»åŠ¨è¿‡ç¨‹ä¸­å¯ä»¥è¿›è¡Œç‰©ç†æ£€æµ‹ 3. çª—å£æ ¹æ®ä¸‰æ¡è¾¹çš„ä½ç½®ç»˜åˆ¶çª—å£ï¼ˆåœºæ™¯ä¸­ç»˜åˆ¶ï¼‰ï¼Œå¹¶ä¸”ç”Ÿæˆä¸€ä¸ªmaskè¦†ç›–æ•´ä¸ªå±å¹•ï¼ˆä¸ä½¿ç”¨æ–¹æ¡ˆä¸€ä¸­ç”Ÿæˆç›¸æœºçº¹ç†åœ¨windowsä¸­æ˜¾ç¤ºï¼‰ 4. å¦‚æœæŸæ¡è¾¹çš„ç§»åŠ¨ä¼šä½¿å¾— player ä¸å…¶ä»–ç‰©ä½“ç¢°æ’ï¼Œé‚£ä¹ˆè¯¥ç§»åŠ¨åº”è¯¥è¢«ä¿®æ­£: ä¼šä¸playerç¢°æ’çš„ç‰©ä½“æœ‰ä¸¤ç§å¯èƒ½ï¼š a. åœºæ™¯ä¸­çš„ç‰©ä½“ -&gt; ä¸¢å¼ƒå½“å‰çš„ç§»åŠ¨ b.çª—ä½“ä¸­çš„è‡ªç”±å¯¹è¾¹ -&gt; ä¿æŒå½“å‰ç§»åŠ¨ c.çª—ä½“ä¸­çš„é”å®šå¯¹è¾¹ -&gt; ä¸¢å¼ƒå½“å‰ç§»åŠ¨ ä¸ºäº†ä½¿ç§»åŠ¨è¾¹æ„ŸçŸ¥åˆ°ç©å®¶çš„ç¢°æ’ï¼Œéœ€è¦ä¸ºè¾¹å¢åŠ ä¸€ä¸ªPushçŠ¶æ€ï¼ˆä¸ç”¨å¢åŠ ï¼Œå†™åœ¨Moveé‡Œå³å¯ï¼‰ï¼Œè¯¥çŠ¶æ€ä¸‹æ¯æ¬¡ç§»åŠ¨æ—¶åº”è¯¥å¯¹ç©å®¶è¿›è¡Œç§»åŠ¨æµ‹è¯•ï¼Œå¦‚æœé€šè¿‡æµ‹è¯•åˆ™ç§»åŠ¨å¦åˆ™ä¸ç§»åŠ¨ã€‚ 5. åœ¨è¾¹çš„MoveçŠ¶æ€ä¸‹ï¼Œåº”è¯¥åœæ­¢ç›¸æœºå¯¹ Playerçš„è·Ÿè¸ª 6. 2D å¼•æ“ä¸èƒ½å¦‚3Dä¸€æ ·å‰”é™¤è§†é”¥å¤–çš„ç‰©ä½“ï¼Œä¸æ¸²æŸ“/ä¸æ›´æ–°çª—å£å¤–çš„ç‰©ä½“åªèƒ½é€šè¿‡ç¢°æ’æ¥å®ç° a. æ‰€æœ‰è¿›å…¥çª—ä½“çš„å¯¹è±¡å°†æ¢å¤æ›´æ–°ï¼Œé€€å‡ºçª—ä½“çš„å¯¹è±¡åœæ­¢æ›´æ–° b. åœºæ™¯å¯¹è±¡æŒæœ‰æ‰€æœ‰åœºæ™¯ç‰©ä½“çš„å¼•ç”¨ï¼Œæ‰€ä»¥å½“ç©å®¶è¿›å…¥çª—å£æ—¶å¯ä»¥ç›´æ¥è°ƒç”¨åœºæ™¯èŠ‚ç‚¹çš„Stopæ–¹æ³•ï¼Œè¿™å°†åœæ­¢æ‰€æœ‰é™¤ï¼ˆplayerï¼Œwindowï¼Œobj_in_windowï¼‰çš„å¯¹è±¡ã€‚ ","link":"https://xuaii.github.io/post/you-xi-ji-zhi-chuang-ti-hu-dong/"},{"title":"çŠ¶æ€æœºçš„å‡ ç§å†™æ³•","content":"åœ¨å„ä¸ªGodotåˆå­¦è€…æ•™ç¨‹ä¸­ï¼Œå®ç°ç¬¬ä¸€ä¸ªäººç‰©æ§åˆ¶å™¨éƒ½æ˜¯ä½¿ç”¨çš„çŠ¶æ€æœºï¼Œå¸¸è§çš„æœ‰ä»¥ä¸‹å†™æ³•ï¼š å†™æ³•ä¸€ å…¨åœ¨ Update ä¸­ using Godot; using System; public class ScriptName : Node { // fields [Export] float Speedï¼› [Export] float JumpHeight; private State state = State.Idle; public enum State : int { Run, Jump, Idle, Fall } public void Update { switch(state) { case State.Idel: // code case State.Run: // code case State.Jump: // code case State.Fall: // code default: // code } } } ä¼˜ç‚¹ ï¼š è‡³å°‘èƒ½å®ç°åŠŸèƒ½ï¼Œ ç¼ºç‚¹ï¼š ä¸åˆ©äºç»´æŠ¤ï¼Œä¸æ–¹ä¾¿æ‹“å±• å†™æ³•äºŒ å†™æˆçŠ¶æ€ç±»å’ŒçŠ¶æ€æœºç±» public interface IState { void Enter(); void Exit(); void Update(float delta); void PhysicsUpdate(float delta); } public class StateBase&lt;T&gt; : IState { private StateMachine _machine; private T agent; public virtual void Enter() { } public virtual void Exit() { } public virtual void Update(float delta) { } public virtual void PhysicsUpdate(float delta) { } } public class StateMachine : Node { Dictionary&lt;string, IState&gt; StateInfo; IState CurrentState; public void ChangeTo&lt;T&gt;() where T : IState { ... } public override void _Process(float delta){ CurrentState.Update(delta); } public override void _Process(float delta) { CurrentState.PhysicsUpdate(delta); } } class RunState : StateBase&lt;T&gt; { ... } class JumpState : StateBase&lt;T&gt; { ... } class IdleState : StateBase&lt;T&gt; { if(Mathf.Abs(horizontalInput) &gt; 0.01) { _machine.ChangeTo&lt;RunState&gt;(); } if(verticalInput &gt; 0.1) { _machine.ChangeTo&lt;Jump&gt;(); } } ä¼˜ç‚¹:æ¯”å†™æ³•ä¸€ä¾¿äºç»´æŠ¤ ç¼ºç‚¹ï¼šå¦‚æœè¦å®ç°ä¸€ä¸ª Player çš„çŠ¶æ€æœº å’Œä¸€ä¸ªEnemyçš„çŠ¶æ€æœºï¼Œä»–ä»¬éƒ½æœ‰ç›¸ä¼¼çš„ç§»åŠ¨é€»è¾‘ï¼Œä½†æ˜¯PlayerçŠ¶æ€æœºå¤šå‡ºä¸€äº›æŠ€èƒ½ç›¸å…³çš„çŠ¶æ€ï¼›å¦‚æœé‡‡ç”¨ä¸Šè¿°å†™æ³•ï¼ŒChangeTo()æ˜¯ç¡¬ç¼–ç åœ¨çŠ¶æ€å†…éƒ¨çš„ï¼Œè¿™æ ·å°±ä¸æ–¹ä¾¿æ·»åŠ è¾¹å’ŒçŠ¶æ€ä»¥æ‹“å±•çŠ¶æ€æœº å†™æ³•ä¸‰ ï¼šåŸºäº GraphEditorçš„çŠ¶æ€æœº Godot Asset Store æœ‰å¾ˆå¤šåŸºäº GraphEdit çš„çŠ¶æ€æœºå®ç°ï¼Œé€šè¿‡ï¼š ä¸ºçŠ¶æ€ç»‘å®šçŠ¶æ€è„šæœ¬ ä¸ºè½¬ç§»è¾¹ç»‘å®šè„šæœ¬æˆ–è€…æ·»åŠ è½¬æ¢æ¡ä»¶ å‡å°‘çŠ¶æ€ å’Œ è½¬ç§»è¾¹ çš„è€¦åˆã€‚ å®ƒä»¬éƒ½æœ‰ä¸€ä¸ªå…±åŒçš„ç¼ºç‚¹ï¼šä¸æ”¯æŒ c# æˆ–è€…c#ç‰ˆæœ¬bugå¤š æ‰€ä»¥èƒ½ä¸èƒ½å®ç°ä¸€ä¸ªè¶³å¤Ÿç®€å•çš„ï¼ŒC#ç‰ˆæœ¬çš„ï¼Œè§£è€¦çŠ¶æ€å’Œè½¬åŒ–è¾¹çš„çŠ¶æ€æœºå‘¢ï¼Ÿ å†™æ³•å›› çŠ¶æ€ç±» using Godot; using Godot.Collections; namespace StateMachine.Base { public interface IState { string StateName {get;} void Init(Object agent, Dictionary&lt;string, object&gt; blackboard, IStateMachine machine); void OnEnter(); void OnExit(); void Update(float delta); void PhysicsUpdate(float delta); void Exit(); } public class StateBase : Object, IState { // state åªæŒæœ‰ agent å¯¹è±¡ä¸æŒæœ‰çŠ¶æ€æœºå¯¹è±¡ protected string _StateName = &quot;&quot;; public string StateName =&gt; _StateName; public Object agent; public IStateMachine machine; private Dictionary&lt;string, object&gt; blackboard; public virtual void Init(Object _agent, Dictionary&lt;string, object&gt; _blackboard, IStateMachine _machine) { agent = _agent; blackboard = _blackboard; machine = _machine; } public virtual void OnEnter() { } public virtual void Update(float delta) { } public virtual void PhysicsUpdate(float delta) { } public virtual void OnExit() { } public virtual void Exit() { machine.Transition(StateName); } } } çŠ¶æ€ç±»å†…éƒ¨ä¸èƒ½è°ƒç”¨StateMachineçš„ChangeTo()æ–¹æ³•ï¼Œåªèƒ½å®ç°çŠ¶æ€è‡ªèº«çš„æ›´æ–°é€»è¾‘ å·¥å…·ç±» IStateMachine æ¥å£ï¼ŒCondition æ˜¯ç”¨äºè½¬æ¢è¾¹çš„æ–¹æ³•ï¼ˆè¿”å›trueå°±è½¬æ¢ï¼Œå¦åˆ™å°±ä¸è½¬æ¢ï¼‰ æ»¡è¶³AssertTo.condition åˆ™è½¬æ¢åˆ°AssertTo.nextState Transitionçš„å±æ€§ç”¨äºæ ‡å¿—è¯¥æ–¹æ³•æ˜¯åˆ¤æ–­å“ªä¸ªçŠ¶æ€è½¬ç§»åˆ°å“ªä¸ªçŠ¶æ€çš„ public interface IStateMachine { void Transition(string current); void Start(string name); void Exit(); } public delegate bool Condition(); public class AssertTo : Godot.Object { public Condition condition; public string nextState; public AssertTo(Condition _condition, string _nextState) { condition = _condition; nextState = _nextState; } } [System.AttributeUsage(System.AttributeTargets.Method)] public class Transition : System.Attribute { public string from; public string to; public Transition(string _from, string _to) { from = _from; to = _to; } } çŠ¶æ€æœºç±» çŠ¶æ€æœºç±»ç»§æ‰¿è‡ª StateBaseï¼Œå› æ­¤çŠ¶æ€æœºæ˜¯å¯åµŒå¥—çš„ public class StateMachineBase : StateBase, IStateMachine { public IState CurrentState = null; protected Dictionary&lt;string, Array&lt;AssertTo&gt;&gt; TransitionMap = new Dictionary&lt;string, Array&lt;AssertTo&gt;&gt;(); public Dictionary&lt;string, Godot.Object&gt; Name2State = new Dictionary&lt;string, Godot.Object&gt;(); // çŠ¶æ€æœºé»‘æ¿ protected Dictionary&lt;string, object&gt; blackboard; public override void Init(Godot.Object _agent, Dictionary&lt;string, object&gt; _blackboard = null, IStateMachine _machine = null) { base.Init(_agent, _blackboard, _machine); if(blackboard == null) { blackboard = new Dictionary&lt;string, object&gt;(); } if(_machine == null) { } // åˆå§‹åŒ–çŠ¶æ€åˆ—è¡¨ &amp;&amp; åˆå§‹åŒ–çŠ¶æ€å foreach(var info in this.GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)) { if(info.ReflectedType.IsSubclassOf(typeof(StateMachine.Base.StateBase))) { if(Name2State.ContainsKey(info.Name)) { GD.Print(&quot;[FSM runtime] duplicate state &quot;, info.Name); } else { IState state = info.GetValue(this) as IState; if(state == null) { // current state is null before start continue; } Name2State[info.Name] = state as Godot.Object; state.Init(agent, blackboard, this as IStateMachine); (state as Godot.Object).Set(&quot;_StateName&quot;, info.Name); } } } // åˆå§‹åŒ–è½¬æ¢è¾¹åˆ—è¡¨ foreach(var info in this.GetType().GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)) { if(info.GetCustomAttribute&lt;Transition&gt;() is Transition transition) { if(!Name2State.ContainsKey(transition.from) || !Name2State.ContainsKey(transition.to)) { return; } if(!TransitionMap.ContainsKey(transition.from)) { TransitionMap[transition.from] = new Array&lt;AssertTo&gt;(); } TransitionMap[transition.from].Add(new AssertTo((Condition)Delegate.CreateDelegate(typeof(Condition), this, info), transition.to)); } } } #region life cycle public override void OnEnter() { Start(&quot;entry&quot;); } public override void Update(float delta) { if(CurrentState == null) return; CurrentState.Update(delta); } public override void PhysicsUpdate(float delta) { if(CurrentState == null) return; CurrentState.PhysicsUpdate(delta); } public override void Exit() { if(machine == null) { CurrentState = null; } else { base.Exit(); } } // API public void Transition(string current) { if(CurrentState == null) return; if(CurrentState is ExitState) { CurrentState.OnExit(); Exit(); return; } if(!Name2State.ContainsKey(current)) { return; } if(TransitionMap == null) { return; } if(!TransitionMap.ContainsKey(current)) { return; } foreach(AssertTo edge in TransitionMap[current]) { if(edge.condition.Invoke()) { // æ·»åŠ ä¿¡å· CurrentState.OnExit(); CurrentState = Name2State[edge.nextState] as IState; CurrentState.OnEnter(); return; } } } public void Start(string name) { if(Name2State.ContainsKey(name)) { CurrentState = Name2State[name] as IState; CurrentState.OnEnter(); } } } Demo // çŠ¶æ€å®šä¹‰ public class Idle : StateBase { public override void OnEnter() { PlayAnimation(&quot;Idle&quot;); } public override void PhysicsUpdate(float delta) { if(InputCache != null) { Exit(); } } } public class Run : StateBase { public override void OnEnter() { PlayAnimation(&quot;Run&quot;); } public override void PhysicsUpdate(float delta) { Position += velocity * delta; } } public class PlayerStateMachine : StateMachineBase { // ç»‘å®šçŠ¶æ€åå’ŒçŠ¶æ€ç±»å‹ EntryState entry = new EntryState(); Run run = new Run(); Idle idle = new Idle(); ExitState exit = new ExitState(); // å®šä¹‰è½¬æ¢ [Transition(&quot;entry&quot;, &quot;idle&quot;)] public bool transition_1() { return true; } [Transition(&quot;idle&quot;, &quot;run&quot;)] public bool transition_2() { if(horizontalInput != 0) { return true; } return false; } [Transition(&quot;run&quot;, &quot;idle&quot;)] public bool transition_3() { if(agent.IsOnGround() &amp;&amp; velocity == agent.GetGroundVelocity()) { return true; } return false; } } è¿™æ ·å†™å°±æŠŠçŠ¶æ€ å’Œ çŠ¶æ€è½¬ç§» åˆ†ç¦»å¼€äº†ï¼Œå¦å¤–è¿˜å¯ä»¥å®ç°ä¸€äº›ç¼–è¾‘å™¨å·¥å…·æ¥ç”ŸæˆçŠ¶æ€æœºçš„æ–‡ä»¶ï¼Œä»¥åŠä¸ºæŒ‡å®šèŠ‚ç‚¹ç»‘å®šçŠ¶æ€æœºä»¥ç®€åŒ–æ“ä½œ Todo: æ¯ä¸ªçŠ¶æ€æœºç»‘å®šçš„å¯¹è±¡ç±»å‹ä¸å›ºå®šï¼Œä½†æ˜¯çŠ¶æ€æœºç»§æ‰¿åº”è¯¥ä¸ agent å¯¹è±¡ç»§æ‰¿å…·æœ‰ç›¸ä¼¼çš„å±‚çº§ï¼Œæ‰€ä»¥æ¯å†™ä¸€ä¸ªæ–°çš„çŠ¶æ€æœºå°±å¼ºåˆ¶è½¬æ¢agentç±»å‹è¿‡äºç¹çï¼Œå°è¯•æ‰¾åˆ°ä¼˜åŒ–æ–¹æ³•ï¼ ","link":"https://xuaii.github.io/post/zhuang-tai-ji-de-ji-chong-xie-fa/"},{"title":"å­¦ä¹ è®¡åˆ’","content":"è¿‘æœŸè®¡åˆ’ GAMES101 è®¡ç®—æœºå›¾å½¢å­¦å…¥é—¨ æ—¶é—´ : 22 * 1.5h = 33h é“¾æ¥ : GAMES101 ç›®çš„ : åŸºæœ¬æ¦‚å¿µå’ŒåŸç†ï¼ŒåŸºæœ¬æ¸²æŸ“ç®¡çº¿ GAMES102 å‡ ä½•å»ºæ¨¡ä¸å¤„ç† æ—¶é—´ : 1.5 * 15 = 22.5hs é“¾æ¥ : GAMES102 ç›®çš„ : æ¸¸æˆå¼•æ“ä¸­å‡ ä½•ä½“çš„è¡¨è¾¾å’Œè®¡ç®— GAMES203 ä¸‰ç»´é‡å»ºå’Œç†è§£ æ—¶é—´ : 14 * 1h = 14h é“¾æ¥ : GAMES203 ç›®çš„ : åŸºæœ¬æ¦‚å¿µ, GAMES202 *é«˜è´¨é‡å®æ—¶æ¸²æŸ“ æ—¶é—´ : 14 * 2h = 28h é“¾æ¥ : GAMES202 ç›®çš„ : shader?? GAMES104 ç°ä»£æ¸¸æˆå¼•æ“ æ—¶é—´ : 20 * 2h = 40h é“¾æ¥ : GAMES104 ç›®çš„ : ç†è§£æ¸¸æˆå¼•æ“ä¸­ ç°å­˜çš„/æœªå­˜ çš„ åŠŸèƒ½/hack çš„åŸç†ï¼Œå„ä¸ªæ¨¡å—çš„åŠŸèƒ½å’Œä¸ºä»€ä¹ˆå­˜åœ¨è¿™ç§åŠŸèƒ½ã€‚ Todo List TheBook of Shaders ä¸»è¦æ˜¯é€ å‹å‡½æ•°ï¼Œå™ªå£°ç­‰ å„ä¸ªæ¸¸æˆå¼•æ“ä¸­å®ç°çš„å…‰ç…§æ–¹æ¡ˆğŸ”¦ğŸ”¦ è®¾è®¡æ¨¡å¼ï¼ˆc#ï¼‰ Carbonè¯­è¨€ğŸ­ æ¸¸æˆå¸¸ç”¨ç³»ç»Ÿæ¨¡å—è®¾è®¡ï¼ˆå¯¹è±¡æ± ï¼Œæ¶ˆæ¯æ€»çº¿ï¼Œå­˜æ¡£ç³»ç»Ÿï¼‰ æ¸¸æˆç©æ³•åŠŸèƒ½è®¾è®¡ï¼ˆæ‚ï¼‰ ğŸ® æ¸¸æˆå¼•æ“æ’ä»¶/æœåŠ¡ æ¸¸æˆè®¾è®¡ç›¸å…³ï¼ˆui/å…³å¡/å°±è¯·/è¾“å…¥å¸ƒå±€/æ ¸å¿ƒèƒ½åŠ›/è®¾è®¡æ–¹æ³•ï¼‰ è¾…åŠ©å·¥å…·ï¼ˆå¯è§†åŒ–çŠ¶æ€æœºï¼Œå¯è§†åŒ–è¡Œä¸ºæ ‘ï¼ŒæŠ€èƒ½ç¼–è¾‘å™¨ï¼‰ğŸ’» ç¾æœ¯ç›¸å…³è½¯ä»¶ï¼ˆblenderï¼ŒGIMPï¼‰ï¼ˆä¸ä¼šå­¦çš„ğŸ‘ ","link":"https://xuaii.github.io/post/xue-xi-ji-hua/"},{"title":"Fourier Transform","content":"1. Dirichlet Conditions ä¸€ä¸ªå‘¨æœŸå†…, è¿ç»­æˆ–è€…æœ‰æœ‰é™ä¸ªç¬¬ä¸€ç±»é—´æ–­ç‚¹ ä¸€ä¸ªå‘¨æœŸå†…, æœ‰é™ä¸ªæå€¼ç‚¹ ä¸€ä¸ªå‘¨æœŸå†…å¯ç§¯ 2. Trangle Transform å‡è®¾ f(t)=c0+âˆ‘n=1âˆcncosâ¡(nÏ‰t+Ï†)=c0+âˆ‘n=1âˆ[cncosâ¡Ï†cosâ¡(nÏ‰t)âˆ’cnsinâ¡Ï†sinâ¡(nÏ‰t)]f(t) = c_0+\\sum_{n=1}^{\\infty}c_n\\cos(n \\omega t + \\varphi) =c_0+\\sum_{n=1}^{\\infty}[c_n\\cos\\varphi\\cos(n\\omega t)- c_n\\sin\\varphi \\sin(n\\omega t)] f(t)=c0â€‹+n=1âˆ‘âˆâ€‹cnâ€‹cos(nÏ‰t+Ï†)=c0â€‹+n=1âˆ‘âˆâ€‹[cnâ€‹cosÏ†cos(nÏ‰t)âˆ’cnâ€‹sinÏ†sin(nÏ‰t)] ä»¤ an=cncosâ¡Ï†,bn=âˆ’cnsinâ¡Ï†a_n = c_n \\cos\\varphi,\\qquad b_n = -c_n\\sin\\varphianâ€‹=cnâ€‹cosÏ†,bnâ€‹=âˆ’cnâ€‹sinÏ† f(t)=c0+âˆ‘n=1âˆ[ancosâ¡(nÏ‰t)+bnsinâ¡(nÏ‰t)]âˆ«0Tf(t)sinâ¡(kÏ‰t)dt=âˆ«0Tc0sinâ¡(kÏ‰t)dt+âˆ«0Tsinâ¡(kÏ‰t)âˆ‘n=1âˆ[ancosâ¡(nÏ‰t)+bnsinâ¡(nÏ‰t)]dtâˆ«0Tf(t)sinâ¡(nÏ‰t)dt=0+bnT2bn=2Tâˆ«0Tf(t)sinâ¡(nÏ‰t)dt f(t) = c_0+\\sum_{n=1}^{\\infty}[a_n\\cos(n\\omega t) + b_n \\sin(n\\omega t)]\\\\ \\int_0^T f(t)\\sin(k\\omega t) dt= \\int_0^Tc_0\\sin(k\\omega t) dt + \\int_0^T\\sin(k\\omega t)\\sum_{n=1}^{\\infty}[a_n\\cos(n\\omega t) + b_n \\sin(n\\omega t)] dt\\\\ \\int_0^T f(t)\\sin(n\\omega t) dt= 0 + b_n \\frac{T}{2}\\\\ b_n = \\frac{2}{T} \\int_0^T f(t)\\sin(n\\omega t) dt f(t)=c0â€‹+n=1âˆ‘âˆâ€‹[anâ€‹cos(nÏ‰t)+bnâ€‹sin(nÏ‰t)]âˆ«0Tâ€‹f(t)sin(kÏ‰t)dt=âˆ«0Tâ€‹c0â€‹sin(kÏ‰t)dt+âˆ«0Tâ€‹sin(kÏ‰t)n=1âˆ‘âˆâ€‹[anâ€‹cos(nÏ‰t)+bnâ€‹sin(nÏ‰t)]dtâˆ«0Tâ€‹f(t)sin(nÏ‰t)dt=0+bnâ€‹2Tâ€‹bnâ€‹=T2â€‹âˆ«0Tâ€‹f(t)sin(nÏ‰t)dt ä¸ 2 ç›¸ä¼¼çš„å¯ä»¥è®¡ç®—å¾—åˆ° cn,an,Ï†,c0c_n, a_n, \\varphi, c_0cnâ€‹,anâ€‹,Ï†,c0â€‹ 3. Fourier çº§æ•° æ ¹æ®æ¬§æ‹‰å…¬å¼: ejx=cosâ¡x+jsinâ¡xcosâ¡(nÏ‰t)=ejnÏ‰t+eâˆ’jnÏ‰t2sinâ¡(nÏ‰t)=ejnÏ‰tâˆ’eâˆ’jnÏ‰t2je^{jx} = \\cos x + j\\sin x\\\\ \\cos(n\\omega t) = \\frac{e^{jn\\omega t} + e^{-jn\\omega t}}{2}\\\\ \\sin(n\\omega t) = \\frac{e^{jn\\omega t} - e^{-jn\\omega t}}{2j}\\\\ ejx=cosx+jsinxcos(nÏ‰t)=2ejnÏ‰t+eâˆ’jnÏ‰tâ€‹sin(nÏ‰t)=2jejnÏ‰tâˆ’eâˆ’jnÏ‰tâ€‹ (8) (9)ä»£å…¥(3) f(t)=c0+âˆ‘n=1âˆ[anejnÏ‰t+eâˆ’jnÏ‰t2+bnejnÏ‰tâˆ’eâˆ’jnÏ‰t2j] f(t) = c_0+\\sum_{n=1}^{\\infty}[a_n \\frac{e^{jn\\omega t} + e^{-jn\\omega t}}{2} + b_n \\frac{e^{jn\\omega t} - e^{-jn\\omega t}}{2j}]\\\\ f(t)=c0â€‹+n=1âˆ‘âˆâ€‹[anâ€‹2ejnÏ‰t+eâˆ’jnÏ‰tâ€‹+bnâ€‹2jejnÏ‰tâˆ’eâˆ’jnÏ‰tâ€‹] ç”±äº : an=2Tâˆ«0Tf(t)cosâ¡(âˆ’nÏ‰t)dt=aâˆ’nåŒç†:âˆ’bn=bâˆ’n a_n = \\frac{2}{T} \\int_0^T f(t)\\cos(-n\\omega t)dt = a_{-n}\\\\ åŒç†:-b_n = b_{-n} anâ€‹=T2â€‹âˆ«0Tâ€‹f(t)cos(âˆ’nÏ‰t)dt=aâˆ’nâ€‹åŒç†:âˆ’bnâ€‹=bâˆ’nâ€‹ æ•´ç†å¾—åˆ°: f(t)=c0+âˆ‘n=1âˆ[anâˆ’jbn2ejnÏ‰t+ aâˆ’nâˆ’jbâˆ’n2eâˆ’jnÏ‰t]f(t)=c0+âˆ‘n=1âˆanâˆ’jbn2ejnÏ‰t+âˆ‘n=âˆ’âˆâˆ’1anâˆ’jbn2ejnÏ‰tåˆå¹¶å¾—åˆ°:f(t)=âˆ‘n=âˆ’âˆâˆanâˆ’jbn2ejnÏ‰tä»¤:An=anâˆ’jbn2f(t)=âˆ‘n=âˆ’âˆâˆAnejnÏ‰t f(t) = c_0 + \\sum_{n=1}^{\\infty}[\\frac{a_n-jb_n}{2}e^{jn\\omega t} + \\ \\frac{a_{-n} - jb_{-n}}{2}e^{-jn\\omega t}]\\\\ f(t) = c_0 + \\sum_{n=1}^{\\infty}\\frac{a_n-jb_n}{2}e^{jn\\omega t} + \\sum_{n = -\\infty}^{-1} \\frac{a_n - jb_n}{2}e^{jn\\omega t}\\\\ åˆå¹¶å¾—åˆ°:\\\\ \\qquad\\qquad f(t) = \\sum_{n=-\\infty}^{\\infty}\\frac{a_n - jb_n}{2}e^{jn\\omega t}\\\\ ä»¤:\\\\ \\qquad\\qquad A_n = \\frac{a_n - jb_n}{2}\\\\ f(t) = \\sum_{n=-\\infty}^{\\infty}A_ne^{jn\\omega t}\\\\ f(t)=c0â€‹+n=1âˆ‘âˆâ€‹[2anâ€‹âˆ’jbnâ€‹â€‹ejnÏ‰t+ 2aâˆ’nâ€‹âˆ’jbâˆ’nâ€‹â€‹eâˆ’jnÏ‰t]f(t)=c0â€‹+n=1âˆ‘âˆâ€‹2anâ€‹âˆ’jbnâ€‹â€‹ejnÏ‰t+n=âˆ’âˆâˆ‘âˆ’1â€‹2anâ€‹âˆ’jbnâ€‹â€‹ejnÏ‰tåˆå¹¶å¾—åˆ°:f(t)=n=âˆ’âˆâˆ‘âˆâ€‹2anâ€‹âˆ’jbnâ€‹â€‹ejnÏ‰tä»¤:Anâ€‹=2anâ€‹âˆ’jbnâ€‹â€‹f(t)=n=âˆ’âˆâˆ‘âˆâ€‹Anâ€‹ejnÏ‰t åœ¨ 4. ä¸­å¾—åˆ° Fourier çº§æ•°, å†ä¸¤è¾¹åŒæ—¶ ä¹˜ä»¥ eâˆ’jkÏ‰te^{-jk\\omega t}eâˆ’jkÏ‰t å¹¶åœ¨ä¸€ä¸ªå‘¨æœŸå†…ç§¯åˆ†å¾—åˆ°: âˆ«0Tf(t)eâˆ’jnÏ‰tdt=âˆ«0Tâˆ‘n=âˆ’âˆ+âˆAnej(nâˆ’k)Ï‰tdtâˆ«0Tf(t)eâˆ’jnÏ‰tdt=AnTAn=1Tâˆ«0Tf(t)eâˆ’jnÏ‰tdt \\int_{0}^{T}f(t)e^{-jn\\omega t}dt = \\int_{0}^{T}\\sum^{+\\infty}_{n = -\\infty}A_ne^{j(n-k)\\omega t}dt\\\\ \\int_0^Tf(t)e^{-jn\\omega t}dt = A_nT\\\\ A_n = \\frac{1}{T}\\int_0^Tf(t)e^{-jn\\omega t}dt âˆ«0Tâ€‹f(t)eâˆ’jnÏ‰tdt=âˆ«0Tâ€‹n=âˆ’âˆâˆ‘+âˆâ€‹Anâ€‹ej(nâˆ’k)Ï‰tdtâˆ«0Tâ€‹f(t)eâˆ’jnÏ‰tdt=Anâ€‹TAnâ€‹=T1â€‹âˆ«0Tâ€‹f(t)eâˆ’jnÏ‰tdt 4. Fourier Transform 1 An=1Tâˆ«0Tf(t)eâˆ’jnÏ‰tdtF(Ï‰)=limâ¡Tâ†’âˆAnT=âˆ«0âˆf(t)eâˆ’jnÏ‰tdt(FourierTransform+)limâ¡Tâ†’âˆAn=limâ¡Tâ†’âˆF(Ï‰)T=limâ¡Tâ†’âˆF(Ï‰)â‹…Ï‰2Ï€ A_n = \\frac{1}{T}\\int_0^Tf(t)e^{-jn\\omega t}dt\\\\ F(\\omega) = \\lim_{T\\rightarrow \\infty}A_nT = \\int_0^\\infty f(t)e^{-jn\\omega t}dt\\qquad (Fourier Transform + )\\\\ \\lim_{T\\rightarrow \\infty}A_n = \\lim_{T\\rightarrow \\infty}\\frac{F(\\omega)}{T} = \\lim_{T\\rightarrow \\infty}\\frac{F(\\omega)\\cdot \\omega}{2\\pi}\\\\ Anâ€‹=T1â€‹âˆ«0Tâ€‹f(t)eâˆ’jnÏ‰tdtF(Ï‰)=Tâ†’âˆlimâ€‹Anâ€‹T=âˆ«0âˆâ€‹f(t)eâˆ’jnÏ‰tdt(FourierTransform+)Tâ†’âˆlimâ€‹Anâ€‹=Tâ†’âˆlimâ€‹TF(Ï‰)â€‹=Tâ†’âˆlimâ€‹2Ï€F(Ï‰)â‹…Ï‰â€‹ ç»“åˆ (19)(25) å¾—åˆ° f(t)=limâ¡Tâ†’âˆâˆ‘n=âˆ’âˆâˆAnejnÏ‰t=limâ¡Tâ†’âˆâˆ‘n=âˆ’âˆâˆF(Ï‰)â‹…ejnÏ‰t2Ï€dÏ‰=12Ï€âˆ«âˆ’âˆâˆF(Ï‰)â‹…ejnÏ‰tdÏ‰(FourierTransformâˆ’) f(t) = \\lim_{T\\rightarrow \\infty}\\sum^\\infty_{n=-\\infty}A_n e^{jn\\omega t} =\\lim_{T\\rightarrow \\infty}\\sum^\\infty_{n=-\\infty}\\frac{F(\\omega)\\cdot e^{jn\\omega t}}{2\\pi} d\\omega =\\frac{1}{2\\pi}\\int^\\infty_{-\\infty}F(\\omega)\\cdot e^{jn\\omega t}d\\omega \\qquad (Fourier Transform -)\\\\ f(t)=Tâ†’âˆlimâ€‹n=âˆ’âˆâˆ‘âˆâ€‹Anâ€‹ejnÏ‰t=Tâ†’âˆlimâ€‹n=âˆ’âˆâˆ‘âˆâ€‹2Ï€F(Ï‰)â‹…ejnÏ‰tâ€‹dÏ‰=2Ï€1â€‹âˆ«âˆ’âˆâˆâ€‹F(Ï‰)â‹…ejnÏ‰tdÏ‰(FourierTransformâˆ’) 5. Convolution Theorem å®šç†æè¿°è®¾:f1(t)çš„Fourierå˜æ¢ä¸ºF1(Ï‰),f2(t)çš„Fourierå˜æ¢ä¸ºF2(Ï‰),é‚£ä¹ˆ:æ—¶åŸŸ:F[f1(t)âŠ—f2(t)]=F1(Ï‰)â‹…F2(Ï‰)é¢‘åŸŸ:F[f1(t)â‹…f2(t)]=12Ï€F1(Ï‰)âŠ—F2(Ï‰)è®¾:f_1(t) çš„Fourierå˜æ¢ä¸ºF_1(\\omega), f_2(t) çš„Fourierå˜æ¢ä¸ºF_2(\\omega), \\\\ é‚£ä¹ˆ:\\\\ æ—¶åŸŸ:\\\\ \\qquad\\qquad F[f_1(t)\\otimes f_2(t)] = F_1(\\omega)\\cdot F_2(\\omega)\\\\ é¢‘åŸŸ:\\\\ \\qquad\\qquad F[f_1(t)\\cdot f_2(t)] = \\frac{1}{2\\pi}F_1(\\omega)\\otimes F_2(\\omega)\\\\ è®¾:f1â€‹(t)çš„Fourierå˜æ¢ä¸ºF1â€‹(Ï‰),f2â€‹(t)çš„Fourierå˜æ¢ä¸ºF2â€‹(Ï‰),é‚£ä¹ˆ:æ—¶åŸŸ:F[f1â€‹(t)âŠ—f2â€‹(t)]=F1â€‹(Ï‰)â‹…F2â€‹(Ï‰)é¢‘åŸŸ:F[f1â€‹(t)â‹…f2â€‹(t)]=2Ï€1â€‹F1â€‹(Ï‰)âŠ—F2â€‹(Ï‰) 6. Fourier æ—¶ç§»æ€§è´¨ F[f(t)]=F(Ï‰)åˆ™:F[f(tâˆ’Ï„)]=F(Ï‰)eâˆ’jnÏ‰Ï„F[f(t)] = F(\\omega) \\qquadåˆ™: F[f(t - \\tau)] = F(\\omega)e^{-jn\\omega \\tau} F[f(t)]=F(Ï‰)åˆ™:F[f(tâˆ’Ï„)]=F(Ï‰)eâˆ’jnÏ‰Ï„ è¯æ˜: F[f(tâˆ’Ï„)]=âˆ«âˆ’âˆ+âˆf(tâˆ’Ï„)eâˆ’jnÏ‰tdtF[f(t - \\tau)] = \\int^{+\\infty}_{-\\infty}f(t-\\tau)e^{-jn\\omega t}dt\\\\ F[f(tâˆ’Ï„)]=âˆ«âˆ’âˆ+âˆâ€‹f(tâˆ’Ï„)eâˆ’jnÏ‰tdt ä»¤ x=tâˆ’Ï„:x= t - \\tau:x=tâˆ’Ï„: F[f(tâˆ’Ï„)]=âˆ«âˆ’âˆ+âˆf(x)eâˆ’jnÏ‰(x+Ï„)dx=ejnÏ‰Ï„âˆ«âˆ’âˆ+âˆf(x)eâˆ’jnÏ‰xdx=F(Ï‰)â‹…ejnÏ‰Ï„ F[f(t - \\tau)] = \\int^{+\\infty}_{-\\infty}f(x)e^{-jn\\omega (x+\\tau)}dx =e^{jn\\omega\\tau}\\int^{+\\infty}_{-\\infty}f(x)e^{-jn\\omega x}dx = F(\\omega)\\cdot e^{jn\\omega\\tau} F[f(tâˆ’Ï„)]=âˆ«âˆ’âˆ+âˆâ€‹f(x)eâˆ’jnÏ‰(x+Ï„)dx=ejnÏ‰Ï„âˆ«âˆ’âˆ+âˆâ€‹f(x)eâˆ’jnÏ‰xdx=F(Ï‰)â‹…ejnÏ‰Ï„ 7. Convolution Theorem è¯æ˜ å®šä¹‰å·ç§¯è¿ç®— f1(t)âŠ—f1(t)=âˆ«âˆ’âˆ+âˆf1(Ï„)f2(tâˆ’Ï„)dÏ„f_1(t)\\otimes f_1(t) = \\int_{-\\infty}^{+\\infty}f_1(\\tau)f_2(t - \\tau)d\\tau\\\\ f1â€‹(t)âŠ—f1â€‹(t)=âˆ«âˆ’âˆ+âˆâ€‹f1â€‹(Ï„)f2â€‹(tâˆ’Ï„)dÏ„ å°† (35) å¸¦å…¥(24) F[f1(t)âŠ—f1(t)]=âˆ«âˆ’âˆ+âˆ[âˆ«âˆ’âˆ+âˆf1(Ï„)f2(tâˆ’Ï„)dÏ„]eâˆ’jnÏ‰tdt=âˆ«âˆ’âˆ+âˆf1(Ï„)[âˆ«âˆ’âˆ+âˆf2(tâˆ’Ï„)eâˆ’jnÏ‰tdt]dÏ„(è°ƒæ¢ç§¯åˆ†é¡ºåº)=âˆ«âˆ’âˆ+âˆf1(Ï„)F2(Ï‰)eâˆ’jnÏ‰Ï„dÏ„=F2(Ï‰)â‹…F1(Ï‰) F[f_1(t)\\otimes f_1(t)] = \\int_{-\\infty}^{+\\infty}[\\int_{-\\infty}^{+\\infty}f_1(\\tau)f_2(t - \\tau)d\\tau]e^{-jn\\omega t}dt\\\\ = \\int_{-\\infty}^{+\\infty}f_1(\\tau)[\\int_{-\\infty}^{+\\infty}f_2(t - \\tau)e^{-jn\\omega t}dt]d\\tau \\qquad(è°ƒæ¢ç§¯åˆ†é¡ºåº)\\\\ = \\int_{-\\infty}^{+\\infty}f_1(\\tau)F_2(\\omega)e^{-jn\\omega \\tau}d\\tau\\\\ = F_2(\\omega)\\cdot F_1(\\omega)\\\\ F[f1â€‹(t)âŠ—f1â€‹(t)]=âˆ«âˆ’âˆ+âˆâ€‹[âˆ«âˆ’âˆ+âˆâ€‹f1â€‹(Ï„)f2â€‹(tâˆ’Ï„)dÏ„]eâˆ’jnÏ‰tdt=âˆ«âˆ’âˆ+âˆâ€‹f1â€‹(Ï„)[âˆ«âˆ’âˆ+âˆâ€‹f2â€‹(tâˆ’Ï„)eâˆ’jnÏ‰tdt]dÏ„(è°ƒæ¢ç§¯åˆ†é¡ºåº)=âˆ«âˆ’âˆ+âˆâ€‹f1â€‹(Ï„)F2â€‹(Ï‰)eâˆ’jnÏ‰Ï„dÏ„=F2â€‹(Ï‰)â‹…F1â€‹(Ï‰) ","link":"https://xuaii.github.io/post/fourier-transform/"}]}